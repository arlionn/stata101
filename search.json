[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Stata 101",
    "section": "",
    "text": "连享会主页\n课程\n视频\n资料\n\n\n课件下载：Click\n观看配套视频：\n\n连享会视频课堂：View\nB 站：View\n\n\n\n\n主页 || 课程 || 视频 || 推文 || 资料",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Stata 101</span>"
    ]
  },
  {
    "objectID": "body/_home.html",
    "href": "body/_home.html",
    "title": "About",
    "section": "",
    "text": "连享会小课堂：在线视频课程\n连享会 由中山大学连玉君老师团队创办，定期分享各类实证分析经验，主要栏目如下：",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "body/_home.html#连享会小课堂在线视频课程",
    "href": "body/_home.html#连享会小课堂在线视频课程",
    "title": "About",
    "section": "",
    "text": "\\({\\color{red}{NEW}}\\) 连享会在线课堂：lianxh-class.cn\n\n\n连玉君，Stata 33 讲，观看量超过 100 万人次的 Stata 入门课\n连玉君，直击面板数据模型，2 小时，公开课\nStata 软件及计量基础, 五次课，Stata 入门必备\n因果推断：控制变量如何选？，2 小时, 9.9 元\n因果推断：反事实架构及主流计量方法, 2 小时, 9.9 元\n我的特斯拉-实证研究设计，2.4 小时\n连玉君，我的甲壳虫-论文精讲与重现，两次课，共 6 小时\n连玉君，动态面板数据模型，2.2 小时，理论+实操 ……",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "body/_home.html#资源分享",
    "href": "body/_home.html#资源分享",
    "title": "About",
    "section": "资源分享",
    "text": "资源分享\n\n详情：主页 - 资料分享\n\n\nData\n\nCSMAR-国泰安 | Wind-万德 | Resset-锐思\n常用数据库 | 人文社科数据库\n\n\n\n论文复现\n\n论文重现网站大全\n\n\nDiscover Mendeley Data\nICPSR Data\nHarvard Dataverse\nFind Economic Articles with Data\n\n包含 9000 多篇经济金融论文，可检索软件类型、期刊名称等。\n\nReplication in the social sciences\n\n\n\n推文\n\nStata 教程 | 资料 | 新命令 | 结果输出 | 绘图 | 数据处理 | 程序\n回归分析 | 面板数据 | 交乘项-调节 | IV-GMM | Logit | 空间计量\n因果推断 | DID | RDD | PSM | 合成控制 | 文本分析\nMarkdown | 工具软件 | 机器学习 | 其它\nPDF 合集",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "body/_home.html#联系我们",
    "href": "body/_home.html#联系我们",
    "title": "About",
    "section": "联系我们",
    "text": "联系我们\n\nE-mail： StataChina@163.com\n微信公众号： lianxh_cn (连享会)\n\n\n数字连享会\n截至 2024.12.18，连享会 共发布推文 1351 篇，累积阅读量 13,043,554 次。篇均阅读次数为 9654。连享会 知乎账号 回答了 1360 个经济、管理领域的问题，发布推文 1036 篇，累积阅读量为 58,564,198 次。\n\n\n欢迎赐稿\n\n推文风格：参见 分类推文。\n录用 2 篇 以上，即可 免费 获得一期 Stata 现场培训资格\n投稿信箱: StataChina@163.com / arlionn@163.com 。\n邮件标题：推文投稿-姓名：推文标题。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>About</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html",
    "href": "body/B0-Stata概览.html",
    "title": "B0. Stata 概览",
    "section": "",
    "text": "0.0 实证分析的流程\n这份讲义旨在介绍 Stata 的界面、主要功能，以及使用 Stata 进行实证分析的工作流程。\n我一直秉承「干中学」的理念。因此，在阅读这份讲义时，我强烈建议大家不时停下来，在 Stata 中亲自操作一下。将重点内容记录下来，并形成两份笔记：一份是包含关键 Stata 代码的 dofile，以便日后查阅和调用；另一份是 Markdown 笔记，内含每个知识点的相关链接和参考资料，以及你对关键命令和代码的解释。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#实证分析的流程",
    "href": "body/B0-Stata概览.html#实证分析的流程",
    "title": "B0. Stata 概览",
    "section": "",
    "text": "[1] 一个想法：研究假设\n[2] 模型设定\n[3] 变量界定\n[4] 收集数据、数据清洗、生成变量\n[5] 统计和回归分析\n\n支持 → [6]\n不支持 → [1]-[5]\n\n[6] 解释结果、结论\n\n\n:dog: 讨论：在上述过程中，Stata 的角色和作用是什么？",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-工作流程",
    "href": "body/B0-Stata概览.html#stata-工作流程",
    "title": "B0. Stata 概览",
    "section": "0.1 Stata 工作流程",
    "text": "0.1 Stata 工作流程\n图 Figure 3.1 呈现了 Stata 的基本工作流程。\n\n\n\n\n\n\nFigure 3.1: Stata_intro_实证分析流程",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-基本语法格式",
    "href": "body/B0-Stata概览.html#stata-基本语法格式",
    "title": "B0. Stata 概览",
    "section": "0.2 Stata 基本语法格式",
    "text": "0.2 Stata 基本语法格式\n在 Stata 命令窗口中输入 help language 命令，可以查看其基本语法规则。\n\n[U] 11 Language syntax ← Stata 的基本语法格式都在这里\n\n\n\n\nStata 语法格式",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-学习资源",
    "href": "body/B0-Stata概览.html#stata-学习资源",
    "title": "B0. Stata 概览",
    "section": "0.3 Stata 学习资源",
    "text": "0.3 Stata 学习资源\n\n连玉君, Stata 33 讲：b 站视频, 课件\n连玉君老师经验分享：一个资深 Stata 用户的若干思考 -\n\n连享会：推文列表 | Stata入门 | Stata资源 | Stata程序\n\nDATA ANALYSIS NOTES: LINKS AND GENERAL GUIDELINES\nInternet Guide to Stata\nSSCC 在线课程\nGitHub\n\n提供了大量用 Stata 完成的项目的完整数据和 dofile 等。\n可以在 github.com, 中搜索 stata。\n点击 fork 按钮，克隆之 → Clone 到国内 码云 (gitee.com) 账户",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-用户指南最好的入门资料",
    "href": "body/B0-Stata概览.html#stata-用户指南最好的入门资料",
    "title": "B0. Stata 概览",
    "section": "0.4 Stata 用户指南：最好的入门资料",
    "text": "0.4 Stata 用户指南：最好的入门资料\n\n\n务必通读 [U] User Guide (PDF)\n\n\n\n\n\nStata_手册目录",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-命令概览",
    "href": "body/B0-Stata概览.html#stata-命令概览",
    "title": "B0. Stata 概览",
    "section": "0.5 Stata 命令概览",
    "text": "0.5 Stata 命令概览\nStata 各类方法和模型汇总 → stata.com/features\n\nLinear models\n\nregression • censored outcomes • endogenous regressors • bootstrap, jackknife, and robust and cluster–robust variance • instrumental variables • quantile regression • GLS • DID • more\n\nPanel/longitudinal data\n\nRE and FE • linear mixed models • RE probit • GEE • RE/FE Poisson • dynamic panel-data models • IV • DID • panel unit-root tests • more\n\nBinary, count, and limited outcomes\n\nlogit, probit, tobit • Poisson • nbreg • conditional, multinomial, nested, ordered, Logit • mprobit • zero-inflated and left-truncated models • selection models • marginal effects • more\n\nChoice models | Extended regression models (ERMs) | Generalized linear models (GLMs)\nSpatial autoregressive models | DSGE models | Tests, predictions, and effects\nContrasts, pairwise comparisons, and margins | Resampling and simulation methods",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-帮助和搜索功能help-和-search",
    "href": "body/B0-Stata概览.html#stata-帮助和搜索功能help-和-search",
    "title": "B0. Stata 概览",
    "section": "0.6 Stata 帮助和搜索功能：help 和 search",
    "text": "0.6 Stata 帮助和搜索功能：help 和 search\n\nhelp regress // [R] help   |   完整攻略\n\n适用：想要了解某个具体命令的使用细节\nihelp regress：外部命令 ihelp 可以快速打开 PDF 版本的帮助文档\n\n\nsearch panel data // [R] search\n\nfindit dynamic threshold // 旧版命令\nsearch Lian Yujun // 搜索人名\n搜索建议：help searchadvice\n\n\n. search dynamic panel data\n\n\n\n\nStata 搜索结果页面",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#推文-数据-代码lianxh-和-songbl",
    "href": "body/B0-Stata概览.html#推文-数据-代码lianxh-和-songbl",
    "title": "B0. Stata 概览",
    "section": "0.7 推文 · 数据 · 代码：lianxh 和 songbl",
    "text": "0.7 推文 · 数据 · 代码：lianxh 和 songbl\n\n安装\n\n. ssc install lianxh\n. ssc install songbl\n\n使用：\n\n. lianxh \n. lianxh DID\n. songbl \n. songbl 静态面板\n\n\n\nlianxh 命令和 songbl 命令",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#stata-功能概览",
    "href": "body/B0-Stata概览.html#stata-功能概览",
    "title": "B0. Stata 概览",
    "section": "0.8 Stata 功能概览",
    "text": "0.8 Stata 功能概览\n\nNote：点击蓝色链接可以直接打开对应的 PDF 手册，查看命令清单\n\n\nhelp language // [U] 11 Language syntax ← Stata 的基本语法格式都在这里\nhelp data_management // [D] data_management\nhelp program // [P] program → [U] 18 Programming Stata\nhelp graph // [G-2] graph\n\nhelp graph intro // [G-1] graph intro，图形编辑器\n\nhelp estcom // 统计和回归分析\n\n[U] 27 Overview of Stata estimation commands，各类计量模型概览",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B0-Stata概览.html#你必须掌握的一些-stata-命令",
    "href": "body/B0-Stata概览.html#你必须掌握的一些-stata-命令",
    "title": "B0. Stata 概览",
    "section": "0.9 你必须掌握的一些 Stata 命令",
    "text": "0.9 你必须掌握的一些 Stata 命令\n\n:apple: PDF：[U] 28 Commands everyone should know\n\n\nGetting help\n\nhelp, search,\nssc install, net install\nlianxh\n\nKeeping Stata up to date\n\nado, net, update, ado update\n\nOperating system interface\n\npwd, cd, dir, sysdir, adopath, shellout\n\nUsing and saving data from disk\n\nuse, save, sysuse, webuse, bcuse\n\nInputting data into Stata\n\nimport excel, insheet, edit\n\nBasic data reporting\n\ndescribe, des2, codebook, fre\nlist, browse, count, inspect\ntable, tabulate, summarize, fsum\n\nData manipulation\n\nclear\nappend, merge, reshape\ngenerate, replace, egen, drop, keep, rename\nsort, gsort, order\nencode, decode\nby, bysort\nframes\n\nGraphing data\n\ntwoway scatter / line\nhistogram, kdensity, graph bar\ngraph export\n\nConvenience\n\ndisplay, cls",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>B0. Stata 概览</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html",
    "href": "body/B1-Stata界面.html",
    "title": "B1. Stata 界面和菜单",
    "section": "",
    "text": "1. 窗口布局及小技巧\n对于新手来讲，请务必花点时间全面了解一下 Stata 的用户界面，以便了解 Stata 的主要功能，这对于有效地使用Stata进行数据分析至关重要。详情参见 Stata user interface。\n默认情况下，Stata 的主界面会显示以下五个窗口：",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#窗口布局及小技巧",
    "href": "body/B1-Stata界面.html#窗口布局及小技巧",
    "title": "B1. Stata 界面和菜单",
    "section": "",
    "text": "结果窗口：正中间面积最大的窗口，用于展示分析结果。\n\n右击后选择「首选项 (P)」，即可设定窗口的配色、字体大小等外观参数。\n\n命令窗口：在此可临时输入简短命令，如 help regress、findit winsor、ssc hot、adopath、lianxh DID 等。\n\n按 Esc 键可清空命令窗口中的全部内容。\n按 PgUp / PgDn 键可翻看此前执行过的命令。\n输入变量名首字母后按 Tab 键，可自动补全变量名或显示备选变量列表。\n输入 cls 并回车，可一键清空结果窗口。\n\n历史窗口 (Review Window)：列示此前执行过的所有命令。\n\n单击某条命令，则其会显示在命令窗口中，便于修改与检查。\n双击某条命令，则立即再次执行该指令。\n\n变量窗口：列出当前数据集中的所有变量及其标签信息。\n\n双击某个变量名，即可将该变量名直接插入至命令窗口中，减少手动输入量。\n\n属性窗口：显示所选变量或数据集的详细信息，包括数据类型、格式、值标签、注释以及存储类型等。这有助于你快速了解并管理变量的属性。\n\n\n小技巧 (Tips)：\n\n\n窗口布局（适合有一定使用经验的用户）：\n\n如果你偏好「一边执行命令，一边查看结果」的简洁工作环境，可只保留 结果窗口 和 命令窗口，同时将 dofile 编辑器 调整至屏幕半侧大小，方便同时查看代码和结果。\n如需恢复先前关闭的窗口，只需从主菜单中选择「窗口」进行还原。\n\n窗口属性设置（适用于大多数窗口）：\n\n在窗口空白处右击，可设定字体、字号、配色等界面参数。\n按 PgUp / PgDn 键可以翻页浏览内容。\n\n\n\n极简版窗口布局\n我平时关闭主界面中的多余窗口，仅保留 命令窗口 和 结果窗口；同时，我会把 dofile 编辑器设定为屏幕宽度的一半。这样，我就可以在右侧的 dofile 中执行命令，在左侧的结果窗口中查看结果。需要切换窗口时，可以使用快捷键 Alt + Tab。当然，如果你是两个显示器双屏显示，那就更方便了。\n若需恢复已经关闭的窗口，可以点击 窗口 (W) 菜单进行设置。\n\n\n\n图 2：简洁版 Stata 界面\n\n\n\n图 2：简洁版 Stata 界面",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#主菜单",
    "href": "body/B1-Stata界面.html#主菜单",
    "title": "B1. Stata 界面和菜单",
    "section": "2. 主菜单",
    "text": "2. 主菜单\n\n\n\nStata 主菜单\n\n\n\n顶部和底部\n\n顶部：显示了 Stata 版本和当前内存中已经读入的数据集\n底部：左下角显示了当前的工作路径。若执行 dir, use 等命令，默认是浏览或调用该文件夹下的文件。\n\n主菜单：\n\n文件 (F)：打开/保存文件、导入/导出数据、打开示例数据集、管理项目文件\n编辑 (E)：复制、粘贴、查找/替换文本、清除结果窗口、用户偏好设定\n数据 (D)：浏览/编辑数据、创建或修改变量、对数据进行排序、合并拆分数据集、设定变量标签和数值标签\n统计 (S)：运行回归、检验、面板数据分析、时间序列分析、计量经济学模型估计、非参数统计等各种统计分析方法\n图形 (G)：绘制散点图、柱状图、线形图、箱线图等图形，定制图表外观与格式\n用户 (U)：加载用户编写的程序扩展、插件、脚本文件等 (很少用)\n窗口 (W)：在命令窗口、历史命令窗口、变量窗口等界面元素之间切换与管理\n\n可以临时关闭 / 开启特定窗口\n\n帮助 (H)：访问 Stata 帮助文档、检索命令手册、查看更新日志、联系技术支持\n\n\n建议新用户依次点击上述菜单，以便快速了解 Stata 的主要功能。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#按钮条-图标",
    "href": "body/B1-Stata界面.html#按钮条-图标",
    "title": "B1. Stata 界面和菜单",
    "section": "3. 按钮条 (图标)",
    "text": "3. 按钮条 (图标)\n主菜单下方有一行图标，是一些常用功能的直达通道：\n\n\n\nStata 按钮条\n\n\n\n：日志文件 [GSW] 16 Saving and printing results by using logs files\n：图形浏览器，点击下拉按钮可以选择需要浏览的图片 [GSW] 14 Graphing data\n：dofile 编辑器 [GSW] 13 Using the Do-file Editor。点击打开一个新的 dofile 文档。\n：数据编辑器 [GSW] 6 Using the Data Editor。点击查看内存中的数据表 (可编辑模式)。\n：数据浏览器。[GSW] 6 Using the Data Editor。点击浏览内存中的数据表 (无法编辑)。\n：强制中断当前运行的程序 (平时是灰色的 )。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#文件-f-菜单",
    "href": "body/B1-Stata界面.html#文件-f-菜单",
    "title": "B1. Stata 界面和菜单",
    "section": "4. 文件 (F) 菜单",
    "text": "4. 文件 (F) 菜单\n文件 (F) 菜单主要涵盖如下功能：\n\n打开数据文件\n导入/导出数据\n更改工作路径\n……\n全都可以用命令实现 (尽量用命令)\n\n\n这里重点说明一下 导入 (I) 和 示例数据集 两个菜单：\n\n导入 (I)：支持多种数据格式的导入，如 .xlsx, .txt\n示例数据集：提供了一些可供演练的数据集，包括：\n\nStata 自带的 26 个数据文件，这些文件都可以使用 sysuse 命令调用，如 sysuse auto.dta, clear；\nStata 手册中使用的各类范例数据文档清单，均可使用 webuse 命令调用，如 webuse nlswork.dta, clear。除了点击菜单，也可以使用如下命令查看上述数据文件列表：\n\nhelp dta_examplels\nsysuse dir  // 此处列出的数据文件都可以用 sysuse 命令调用\nhelp dta_manuals",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#edit-e-菜单界面风格",
    "href": "body/B1-Stata界面.html#edit-e-菜单界面风格",
    "title": "B1. Stata 界面和菜单",
    "section": "5. Edit (E) 菜单：界面风格",
    "text": "5. Edit (E) 菜单：界面风格\n\n\n\nStata 主界面：Edit 菜单\n\n\n编辑菜单中的多数功能都一目了然，不再赘述。需要特别关注的是「首选项 (Preference)」子菜单。我们可以根据自己的喜好设定多种 Stata 界面的配色、字体等的风格，并将这些设定风格保存为模板，以便随后调用。\n\n个性化设定\n\n在 Stata 的任何一个窗口中都可以通过 右击鼠标 来设定 字体属性；\nStata 主界面设定：在 Stata 结果窗口中，右击鼠标 → Preference 可以进一步设定结果窗口(Results)、文件浏览器(Viewer)、数据编辑器(Data Editor)等窗口的属性，主要涉及字体是否加粗、颜色、窗口背景色等。\ndofile 编辑器设定：打开 dofile 编辑器 (快捷键为：Ctrl+9，或者在命令窗口中输入 doedit )，依次点击 Edit → Preferences，会弹出如下 Do-file Editor Preferences→ 通用属性 (General) 设定的对话框。详情参阅后文 dofile 编辑器 小节。\n保存/更换模板：上述设定，都可以保存到一个模板中。Stata 支持多种模板，可以让你在早、中、晚使用不同的模板，既能调节心情，又能保护视力。\n\n\n\n模板的使用\n你可以根据不同场景的需要，设置不同的风格，并保存为多个模板，随后根据需要调用即可。\n\n新建模板：编辑 (Edit) → 首选项 → 保存首选项设置 (S) → 新建首选项设置，自行定义模板名称，然后 确认 即可。\n更换模板：编辑 (Edit) → 首选项 → 加载首选项设置 (L)",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#数据图形统计菜单",
    "href": "body/B1-Stata界面.html#数据图形统计菜单",
    "title": "B1. Stata 界面和菜单",
    "section": "6. 数据/图形/统计菜单",
    "text": "6. 数据/图形/统计菜单\n这三组菜单集合了 Stata 最主要的功能。菜单栏包括文件、编辑、数据、图形、统计、用户、窗口和帮助等功能。每个主菜单下都有多个子选项，提供各种数据管理和分析工具。\n\n数据（D）：涉及数据管理与分析，如数据汇总、描述性统计、线性模型、数据编辑器等。常用命令包括：\n\nbrowse: 浏览数据表\nedit: 编辑数据表\ndescribe: 描述内存中的数据概况\n\n图形（G）：包含多种图表选项，如散点图、折线图、条形图、饼图、直方图、箱线图等。\n统计（S）：提供高级统计分析功能，如假设检验、广义线性模型、时间序列分析、生存分析等。\n用户（U）：可能包含用户设置或自定义选项，如界面布局的个性化设置。\n窗口（W）：管理打开的窗口，如排列或切换窗口，以便更有效地组织工作空间。\n帮助（H）：提供文档、教程和支持资源的访问，是一个全面的帮助系统。\n\n此外，界面可能还包括工具栏，其中有常用功能的图标，如新建数据、打开文件、保存等。软件可能还具有数据编辑器或数据查看器，位于中心位置，配有输出、图表和脚本的面板或窗口。\n\n\n\n数据/图形/统计菜单",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B1-Stata界面.html#stata-的系统路径",
    "href": "body/B1-Stata界面.html#stata-的系统路径",
    "title": "B1. Stata 界面和菜单",
    "section": "7. Stata 的系统路径",
    "text": "7. Stata 的系统路径\nStata 会在不同的路径下分类存储文档。输入 sysdir 命令可以列示这些系统路径 (因人而异)：\n. sysdir\n\n   STATA: D:/stata17           // !! Stata安装根目录\n    BASE: D:/stata17/ado/base  // 官方命令都存放于此\n    SITE: D:/stata17/ado/site  // 可以忽略\n    PLUS: D:/stata/plus        // (可能没有)\nPERSONAL: D:/stata/personal    // (可能没有)\n详情参见：[P] sysdir，[P] sysdir，以及 [GSM] profile。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>B1. Stata 界面和菜单</span>"
    ]
  },
  {
    "objectID": "body/B2a-Stata工作流程.html",
    "href": "body/B2a-Stata工作流程.html",
    "title": "B2a. Stata 工作流程",
    "section": "",
    "text": "1. 工作流程概览\n图 3 展示了一个典型的实证分析工作流程。你在本地或网盘中的文件夹中存如原始数据文件，然后在 Stata 中执行命令，以实现数据读入、清洗和分析，最后把结果输出成表格和图形，嵌入到 Word 或 TeX 文档中。\n简言之，我们要实现「数据 → 代码 → 结果 → 文档」的有机衔接，让研究流程清晰透明，也方便日后重复或更新分析。\n本地文件夹：D:/paper/myAER，其中包含三个文件夹和一个 dofile：\n采用这种分类管理方式，无论是查看数据源还是寻找输出文件，都能快速定位。与合作者分享论文复现资料时，也只需分享 dofile_myAER.do 和 “./data0” 子文件夹即可。合作者运行 dofile_myAER.do 后变会自动生成清洗后的数据文件和结果文档。\n右上角打开的 dofile_myAER.do 是我们向 Stata 下达指令的脚本文件 (dofile)。具体解释如下：\n在 Stata 的主界面中会呈现回归结果、显示输出的图片等。比如，\n总之，dofile 就像一个中心控制台：我们在 dofile 中下达命令，以便从指定路径中导入 Excel, txt, dta 等格式的数据文件，进而进行统计和回归分析，并最终将输出的图形、表格等结果保存到指定文件夹中，以便随后插入 Word, TeX 等写作文档中。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>B2a. Stata 工作流程</span>"
    ]
  },
  {
    "objectID": "body/B2a-Stata工作流程.html#工作流程概览",
    "href": "body/B2a-Stata工作流程.html#工作流程概览",
    "title": "B2a. Stata 工作流程",
    "section": "",
    "text": "Source: 连玉君, 陈鑫梅, 2020, 可重复性研究：如何保证你的研究结果可重现？, 连享会 No.124.\n\n\n\n\n\n\nStata 工作流程示意图\n\n\n\n图 3：Stata 工作流程示意图\n\n\n左：本地文件夹\n\n\n\n“./data0”：存放原始数据文件，如 data_org.xlsx\n“./dataClean”：存放清洗后的数据文件，如 data_clean.dta\n“./out”：存放输出结果，如回归表格 Table01.rtf 和图形 Fig01.png\ndofile_myAER.do：Stata do 文档，记录所有处理过程。\n\n\n\n右：dofile\n\n\n\n首先，使用 global path \"D:/paper/myAER\" 命令，指定了项目文件所在路径，并以此为基础定义了几个相对路径。在后续命令中，便可以使用 $path，$data0 等全局暂元来引用这些路径，而不必每次都手动输入完整路径。你的合作者只需酌情修改第 4 行的文件路径 (绝对路径)，而无需做其他更改。\n接下来，在 dofile 中写好一系列命令，以便完成数据导入、清洗、回归以及结果输出等一整套流程。有了 dofile，只需轻轻点一下执行按钮，就能让整套分析重复进行，也可以让修改和完善工作更有效率。\ndofile 中的第 15, 20 和 24 行都用于输出结果，分别将清洗后的中间数据，回归表格，以及生成的图形存储到项目文件夹 D:/paper/myAER 中的指定子文件中。随后你只需将这些表格和图形插入论文 Word 文档中即可。\n\n\n中：Stata 主界面\n\n\n\n执行 reg price wei mpg, robust 命令后，可以在 Stata 的结果窗口查看回归结果\n进一步执行 esttab using \"$path/out/Table01.rtf\", replace 命令时，结果窗口中会显示自动输出的 .rtf 文档 (等同于 word 文档) 的存储路径 (单击蓝色链接可以打开此文档)。\n执行第 22-23 行的命令后，就会绘制散点图，并将图片以 .png 格式存储到 $out 文件夹中。\n\n\n小结",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>B2a. Stata 工作流程</span>"
    ]
  },
  {
    "objectID": "body/B2a-Stata工作流程.html#stata-安装路径和个人文件夹的设置",
    "href": "body/B2a-Stata工作流程.html#stata-安装路径和个人文件夹的设置",
    "title": "B2a. Stata 工作流程",
    "section": "2. Stata 安装路径和个人文件夹的设置",
    "text": "2. Stata 安装路径和个人文件夹的设置\n安装 Stata 时，文件路径中尽量不要包含中文、空格和特殊字符。否则，会导致涉及读写或保存文档的程序无法运行。我个人通常将 Stata 安装在 D 盘根目录下，如 D:/stata17。\n我会在 D 盘中另外建立一个文件夹 D:/stata，其中，\n\n新建 personal 文件夹，用以保存我自己的数据和程序文件；\n新建 plus 文件夹，用以存放外部命令。\n\n这样做的好处是，无论 Stata 更新到哪个版本，我个人的文件都不会受到任何影响。例如，更新到 Stata 18 后，我只需将 D:/stata17/profile.do 文档复制到 D:/stata18 目录下即可。\n\n2.1 Stata 17 目录下的文档结构\nStata 安装目录 D:/stata17/ 的文档结构如下：\nD:/stata17:: \n                             --- 解释 ---\n├── ado\n│   └── base           |  Stata 官方提供的程序文件（按 _, A-Z 分类）\n├── docs               |  Stata 电子手册（PDF 格式），便于查阅\n└── utilities          |  包含 JAVA、Python 等插件和工具\n│  profile.do          |  Stata 启动时自动执行该文件中的命令\n│  mp-64.dll           |  Stata 运行所需的动态链接库文件\n│  STATA.LIC           |  Stata 的许可证文件，用于验证软件合法性\n│  StataMP-64.exe      |  Stata 的主执行文件，用于启动程序\n│  StataMP-64_old.exe  |  旧版本的 Stata 执行文件（备份或兼容用途）\n说明如下：\n\n不要随意修改 ado/base 目录中的文件，以免影响 Stata 的正常运行。\n可以通过编辑 profile.do 文件来定制 Stata 的启动行为，例如设置工作目录或加载常用脚本。后文会详细介绍。\n如果需要使用插件或外部工具，可以将相关文件放置在 utilities 目录中，确保路径正确。我们通常无需自行设定，再安装或关联外部插件时，Stata 会自动将相关文件存入此处。\n\n\n\n2.2 个人文件夹的文档结构\n存放我个人文档的目录 D:/stata/ 的结构如下：\nD:/stata::\n                             --- 解释 ---\n├── personal           |  存放个人文档 (数据, dofiles 等)\n│   ├── data\n│   ├── paper\n│   └── ... \n├── do                 |  存放自动生成的日志文件\n└── plus               |  存放外部命令\n说明如下：\n\npersonal 目录下可以根据需要设定多个子文件夹，用于分类存储不同项目的文件。基本原则是，一个项目一个文件夹。\ndo 目录用于存放自动生成的日志文件 (log 文件)，记录 Stata 运行过程中的命令和输出结果，复现分析过程或排查问题。随后在 profile 文档 部分会有详细介绍。\nplus 目录用于存放通过 net install 或 ssc install 等命令安装的外部命令 (ado 文件)。\n\n当然，你也可以酌情添加其他文件夹。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>B2a. Stata 工作流程</span>"
    ]
  },
  {
    "objectID": "body/B2a-Stata工作流程.html#工作路径-working-directory",
    "href": "body/B2a-Stata工作流程.html#工作路径-working-directory",
    "title": "B2a. Stata 工作流程",
    "section": "3. 工作路径 (Working Directory)",
    "text": "3. 工作路径 (Working Directory)\n在 Stata 主界面的右下角会显示当前 工作路径/目录（Working Directory），是 Stata 默认的文件读取和保存位置。比如，执行 use mydata.dta 时，默认从当前工作目录下读取 mydata.dta 数据文件 (如果该目录下未保存 mydata.dta 文件，则 Stata 会报错)；执行 save newdata.dta, replace 时，newdata 文件会自动保存到当前工作目录下。\n要在结果窗口中显示当前工作路径，可以执行 cd 或 pwd 命令。若需切换工作路径，只需在 cd (_c_hange _d_irectory) 命令后写上新的工作路径名称即可，例如 cd \"D:/Projects/SJ_paper\" (注意：必须是已经存在的文件夹路径)。合理设置工作目录不仅能减少重复输入路径的麻烦，还能让文件管理更加清晰高效，是 Stata 使用中的一项基础但重要的操作。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>B2a. Stata 工作流程</span>"
    ]
  },
  {
    "objectID": "body/B2a-Stata工作流程.html#stata执行命令和工作机制",
    "href": "body/B2a-Stata工作流程.html#stata执行命令和工作机制",
    "title": "B2a. Stata 工作流程",
    "section": "4. Stata：执行命令和工作机制",
    "text": "4. Stata：执行命令和工作机制\n我们可以通过三种方式与 Stata 互动：\n\n点击菜单 (新手适用，老手偶尔为之)\n命令窗口 (简单的测试性任务)\ndofile (主要方式)\n\n\n\n\nStata 命令的三种执行方式\n\n\n\n4.1 机制 1：把数据和程序拖入内存中\n初学者很怕见到 clear 命令。事实上，如果你了解 Stata 的运行机制，就会明白，clear 是一个非常安全的命令。具体说明如下：\n启动 Stata 时，电脑会分配给 Stata 一块 内存空间 (一座大房子)。解读如下：\n\n当我们执行 use D:/myData/auto.dta 命令时，Stata 会把存储于 D:/myData 文件夹中的 auto.dta 文件复制 (copy) 一份，读入内存。随后，执行 sum, reg 等命令时，Stata 都是从内存中读取这个副本数据，而无需再访问硬盘中的数据文件，即 D:/myData/auto.dta。这样的好处是，可以大幅提高运算速度。缺陷在于，但计算机可以分配给 Stata 的内存空间有限时，Stata 会因为无法读入大文件，或运行中出现卡顿现象。\nStata 执行程序时也采用了上述逻辑。当我们执行 tabstat var1 时，Stata 会先到 D:/stata17/base/t/ 文件夹下找到名为 tabstat.ado 的程序文件，进而将其读入内存中再执行。当我们再次执行 tabstat var2 时，Stata 会直接从内存中执行 tabstat.ado 副本，而无需再访问硬盘的原始程序文件，即 D:/stata17/base/t/tabstat.ado。\n\nStata 会把「大房子」分成若干个小房间，分类存储 Data, Matrix, 返回值, 程序 等对象。若想清空某个「小房间」，可以使用 clear 房间类型 命令，例如：\n\nclear：清空内存中的数据 (分配给 Stata 的内存中的 【Data】 那一块空间)\nclear matrix：清空内存中的矩阵对象\nclear results：清空内存中的返回值，如 r(mean), r(N), e(r2) 等\nclear all：清空分配给 Stata 的所有内存空间\n\n\n\n\nstata-intro-clear-001\n\n\n有关 clear 命令的详情，请参阅 help clear，或 [D] clear。\n作为例子，我们来解释一下如下命令的的含义：\nuse \"D:/myData/auto.dta\", clear\n上述命令等价于：\nclear\nuse \"D:/myData/auto.dta\"\n也就说，虽然 clear 选项置于命令的末尾，但却是最先被执行的，它会清空内存中已有的数据文件。然后，Stata 从硬盘 (D:/myData/) 中拷贝 auto.dta 文件，并将该副本读入内存。\n\n\n4.2 机制 2：结果呈现和输出\n当我们按下图的方式执行 sum price 命令后，Stata 会同时以两种方式输出结果：\n\n方式 1：将部分结果直接呈现于 结果窗口，通常会以特定的格式排列，可读性强。\n方式 2：所有计算结果都会存入 内存 (按类别存入不同的 房间)。\n\n这些结果统称为返回值 (return values)。对于 sum, tabstat 等命令，可以使用 return list 命令显示之；对于 regress, logit, xtreg 等回归类命令，可以使用 ereturn list 命令显示之。\n这些结果可以被后续代码调用，如 gen x_mean = r(mean)\n也可以借助 esttab, outreg2, reg2docx 等命令调用后，输出到 Word 等文档中。\n\n\n\n\n\nStata 的返回值机制\n\n\n简言之，你在 Stata 结果窗口中看到的只是一部分结果，这些结果以及其他相关结果都会被分门别类地存储在内存中，以便其他程序调用。如此以来，我们就可以让多个程序合作，采用「接力」的方式完成复杂的分析任务。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>B2a. Stata 工作流程</span>"
    ]
  },
  {
    "objectID": "body/B2b-profile文档.html",
    "href": "body/B2b-profile文档.html",
    "title": "B2b. profile 文档：启动时自动执行的命令",
    "section": "",
    "text": "1. 创建和修改 profile.do\nStata 启动时，会到安装目录下查找名为 profile.do 的文档，若有则自动执行该文档中的所有命令 (即，do profile.do)。因此，你可以把一些常规的设定都放在 profile.do 中，比如，plus 和 personal 文件夹的默认路径，默认工作路径，回归结果的显示格式等。\nStep 1： 打开/新建 profile.do 文档。执行如下命令：\nStep 2： 修改 → 保存。如下是一个最基本的 profile.do：\n此处使用 sysdir set 命令 ([P] sysdir) 指定了 plus 和 personal 文件夹的位置。需要说明的是：\nStep 3： 更多设定 (可选)。如下是我正在使用的 profile.do 文档，你可以根据自己的需要酌情修改。注意：更新后的 profile.do 在 重启 Stata 时才会生效。\n我在码云仓库中放置了两份 profile 文档：\n如果想在 profile.do 中添加更多的设置，可以输入 set 命令查看 Stata 的系统参数设定 ([R] set)，也可以输入 cret list 查看你电脑中当前的参数设定。\nStep 4： 查验。重启 Stata，结果窗口应该显示如下信息：\n其中，Stata-Path 表示 Stata 的安装路径，可以输入 sysdir 查看。我电脑中显示的结果为：\n你还可以尝试一下外部命令是否会安装到 PLUS 文件夹中：在命令窗口中输入 ssc install jwdid, replace，安装外部命令 jwdid，结果窗口会显示信息如下：\n可以看到，jwdid 的相关程序文件被正确安装到 Step 2 中设定的 plus 文件夹中。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>B2b. profile 文档：启动时自动执行的命令</span>"
    ]
  },
  {
    "objectID": "body/B2b-profile文档.html#创建和修改-profile.do",
    "href": "body/B2b-profile文档.html#创建和修改-profile.do",
    "title": "B2b. profile 文档：启动时自动执行的命令",
    "section": "",
    "text": "doedit \"`c(sysdir_stata)'profile.do\"\n\n如果你此前没有创建过 profile.do 文档，则上述命令执行后会自动打开一个空白的 dofile。可以参照 Step 2 和 Step 3 的介绍添加设置。\nc(sysdir_stata) 是 Stata 系统自建的暂元，用于存储 Stata 的安装路径的名称。\n\n你可以使用 sysdir 命令来列示 Stata 的系统路径，其中列出的第一个路径就是 Stata 的安装路径，如\nSTATA: D:/stata17/ 因此，c(sysdir_stata) 中存储的内容是 D:/stata17/。\n\n\n\n*----------------------- profile.do ------------ Sample A--\n\n*-文件路径设定：外部命令的存放位置\n  global path         \"D:/stata\"         // 个人路径，酌情修改\n  sysdir set PLUS     `\"$path/plus\"'     // 外部命令的存放位置\n  sysdir set PERSONAL `\"$path/personal\"' // 个人文件夹位置\n\n*----------------------- profile.do ------------ Sample A--\n\n\n你需要根据你的文件夹设定情况，酌情修改 global path \"D:/stata\" 这一行中的路径名称 ，并在该路径下预先新建名为 plus 和 personal 的文件夹。\nsysdir set …… 后的 PLUS 和 PERSONAL 要大写。\n\n\n*----------------------- profile.do ------------ Sample B--\n\n*-基本设定\n  set update_query  off         // 不要自动更新\n  set more off, perma           // 不显示 -more- 分页提示信息\n\n*-文件路径设定：外部命令的存放位置, 参见 help set \n  global path \"D:/stata\"        // 统一存放地址\n  \n  sysdir set PLUS `\"$path/plus\"'         // 外部命令的存放位置\n  sysdir set PERSONAL `\"$path/personal\"' // 个人文件夹位置  \n\n  cd `\"$path/personal\"'         // 默认工作路径\n\n*-结果显示格式\n  set cformat  %4.3f  //回归结果中系数的显示格式\n  set pformat  %4.3f  //回归结果中 p 值的显示格式      \n  set sformat  %4.2f  //回归结果中 se值的显示格式   \n\n*-log 文件：自动以当前日期为名存放于 stata/do 文件夹下\n* 若 D:/stata/ 下没有 do 文件夹，则本程序会自动建立一个 \n  cap cd `\"$path/do\"'\n  if _rc{\n     mkdir `\"$path/do\"'  //检测后发现无 do 文件夹，则自行建立一个\n  }\n  cap log close\n  cap cmdlog close \n  local fn = subinstr(\"`c(current_time)'\",\":\",\"-\",2)\n  local fn1 = subinstr(\"`c(current_date)'\",\" \",\"\",3)\n  log    using $path/do/log-`fn1'-`fn'.log, text replace\n  cmdlog using $path/do/cmd-`fn1'-`fn'.log, replace\n\n*----------------------- profile.do ------------ Sample B--\n\n\n简化版本 - profile.do\n完整版本 - profile.do\n\n\n\nrunning Stata-Path\\profile.do ...\n\n. sysdir\n   STATA:  D:\\stata17\\           // Stata-Path (Stata 安装路径)\n    BASE:  D:\\stata17\\ado\\base\\\n    SITE:  D:\\stata17\\ado\\site\\\n    PLUS:  D:/stata/plus\\\nPERSONAL:  D:/stata/personal\\\n\n. ssc install jwdid\n\n   checking jwdid consistency and verifying not already installed...\n   installing into D:/stata/plus\\...\n   installation complete.",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>B2b. profile 文档：启动时自动执行的命令</span>"
    ]
  },
  {
    "objectID": "body/B2b-profile文档.html#临时更改外部命令的下载路径",
    "href": "body/B2b-profile文档.html#临时更改外部命令的下载路径",
    "title": "B2b. profile 文档：启动时自动执行的命令",
    "section": "2. 临时更改外部命令的下载路径",
    "text": "2. 临时更改外部命令的下载路径\n你可以临时更改外部命令的安装路径 (如，为某个项目下载所依赖的外部命令，以实现版本控制的目的)，命令为：\n\nnet set ado   dirname1 (存放 .ado 和 .hlp 文件的路径)；\n\nnet set other dirname2 (存放作者提供的数据文件和范例 dofiles 等附件文件)。\n\n其中，dirname 表示你存放外部命令的文件夹的路径名称 (请确保该文件夹实际存在)，比如\nnet set ado \"F:/paper/Wang_AER/adofiles\" \nnet set ado \"F:/paper/Wang_AER/appendix\"\n当你重新启动 Stata 时，上述设定会自动失效。因为，每次重启后，Stata 会按照 profile.do 中的设定设置初始参数。因此，若希望在一段时间内保持上述设定，可以将它们写入 profile.do 文档，并将此前的设定临时注释掉 (在行首添加 * 或 // 等注释符号)，例如：\n*----------------------- profile.do ------------ Sample C--\n*-基本设定\n  ……\n\n*-文件路径设定：外部命令的存放位置, 参见 help set \n  global path \"D:/stata\"        // 统一存放地址\n  \n//sysdir set PLUS `\"$path/plus\"'         // 外部命令的存放位置\n//sysdir set PERSONAL `\"$path/personal\"' // 个人文件夹位置  \n\n  net set ado \"F:/paper/Wang_AER/adofiles\" \n  net set ado \"F:/paper/Wang_AER/appendix\"\n  \n  ……\n\n*----------------------- profile.do ------------ Sample C--\n若想在不重启 Stata 的情况下恢复此前的设定，可以执行一遍 profile.do 即可：\ndo \"`c(sysdir_stata)'profile.do\"\n或者执行如下命令：\nnet set ado \"`c(sysdir_plus)'\"",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>B2b. profile 文档：启动时自动执行的命令</span>"
    ]
  },
  {
    "objectID": "body/B2b-profile文档.html#参考资料",
    "href": "body/B2b-profile文档.html#参考资料",
    "title": "B2b. profile 文档：启动时自动执行的命令",
    "section": "3. 参考资料",
    "text": "3. 参考资料\n\n连玉君, 2020, 聊聊Stata中的profile文件\nStata profile.do: nice tips\nThe profile and sysprofile Do-Files\nWernow, J.B., StataCorp, How can I automatically execute certain commands every time I start Stata?\nStatalist, 2017, profile.do - useful startups?\nSTATA ON A MAC: Setting up a profile.do file，针对苹果用户。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>B2b. profile 文档：启动时自动执行的命令</span>"
    ]
  },
  {
    "objectID": "body/B3-Stata语法格式.html",
    "href": "body/B3-Stata语法格式.html",
    "title": "B3. Stata 命令的语法格式",
    "section": "",
    "text": "1. Stata 的一般语法格式\nStata 编程最基本的是要掌握 Stata 命令的语法格式，本文将从4个方面介绍 Stata 常用的语法格式。\n首先以 summarize 命令为例，介绍其语法以说明语法的一般格式。了解语法格式可通过 help 命令，help summarize 部分结果下图。\n注意事项\n逗号后为 options, 整条命令只能有一个「裸露」在外的逗号，各个选项之间无需重复添加逗号。\n其他更具体的语法说明可通过命令 help language 查看。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>B3. Stata 命令的语法格式</span>"
    ]
  },
  {
    "objectID": "body/B3-Stata语法格式.html#stata-的一般语法格式",
    "href": "body/B3-Stata语法格式.html#stata-的一般语法格式",
    "title": "B3. Stata 命令的语法格式",
    "section": "",
    "text": "图1 一般语法格式\n\n\n\n命令名称中的下划线部分表示该命令可以简写为 su\n[*] 代表可选项，可加可不加\nvarlist 为变量列表，是用户设定的一个或多个变量名称\n\n. sysuse \"nlsw88.dta\", clear\n. sum wage hours \n\n Variable |    Obs      Mean   Std. Dev.       Min        Max\n----------+--------------------------------------------------\n     wage |  2,246  7.766949   5.755523   1.004952   40.74659\n    hours |  2,242  37.21811   10.50914          1         80\n\n[if] 选项：满足特定条件的子样本\n\n. sum wage if race==1 // 限定样本为 race==1时的子样本\n\n Variable |    Obs      Mean   Std. Dev.       Min        Max\n----------+--------------------------------------------------\n     wage |  1,637  8.082999   5.955069   1.004952   40.19808\n\n[in] 选项：限定观察值范围\n\n\n. sum wage in 1/10 // 对前10个观测的 wage 进行描述\n\n Variable |  Obs       Mean   Std. Dev.      Min        Max\n----------+------------------------------------------------\n     wage |   10   9.343055    3.89733   4.62963   17.20612\n\n[, options]：其它选项。这里以 detail 选项为例介绍\n\n. sum wage, detail  // wage 的详细信息\n\n                         hourly wage\n---------------------------------------------------------\n      Percentiles      Smallest\n 1%     1.930993       1.004952\n 5%     2.801002       1.032247\n10%     3.220612       1.151368     Obs             2,246\n25%     4.259257       1.344605     Sum of Wgt.     2,246\n\n50%      6.27227                    Mean         7.766949\n                        Largest     Std. Dev.    5.755523\n75%     9.597424       40.19808\n90%     12.77777       40.19808     Variance     33.12604\n95%     16.52979       40.19808     Skewness     3.096199\n99%     38.70926       40.74659     Kurtosis     15.85446\n\nbysort 前缀：根据类别变量进行分组统计\nStata 支持多种前缀写法，大大提高了命令的灵活性和执行效率，详见 help prefix。\n\n\n. bysort married: sum wage // 分婚姻状态对 wage 描述统计\n\n-----------------------------------------------------------------------\n-&gt; married = single\n\n Variable |  Obs      Mean  Std. Dev.      Min        Max\n----------+----------------------------------------------\n     wage |  804  8.080765  6.336071  1.151368   40.19808\n\n-----------------------------------------------------------------------\n-&gt; married = married\n\n Variable |    Obs      Mean   Std. Dev.       Min        Max\n----------+--------------------------------------------------\n     wage |  1,442  7.591978   5.399229   1.004952   40.74659\n\n\n. sysuse nlsw88, clear\n\n. tabstat wage hours married age, by(race) s(mean) f(%3.2f) \n\nSummary statistics: mean\n  by categories of: race (race)\n\n  race |      wage     hours   married       age\n-------+----------------------------------------\n white |      8.08     36.90      0.70     39.27\n black |      6.84     38.12      0.47     38.81\n other |      8.55     36.81      0.69     39.31\n-------+----------------------------------------\n Total |      7.77     37.22      0.64     39.15\n------------------------------------------------",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>B3. Stata 命令的语法格式</span>"
    ]
  },
  {
    "objectID": "body/B3-Stata语法格式.html#变量的引用",
    "href": "body/B3-Stata语法格式.html#变量的引用",
    "title": "B3. Stata 命令的语法格式",
    "section": "2. 变量的引用",
    "text": "2. 变量的引用\n任何统计分析都是以变量为基础的，为使数据分析更加高效，熟悉引用变量非常关键。\n通配符 可以使变量引用变得更简捷，以下将以系统文件 nlsw88.dta 为例，介绍三种常用通配符。\nsysuse \"nlsw88.dta\", clear\n\n通配符：-\n要对数据集第2-6个变量描述统计，常规方法： stata  sum age race married never_married grade 使用通配符 - stata  sum age-grade  // 只需列出头尾两个变量\n通配符：*\n可代表任意字符 ```stata . sum s* // 以 s 开头的变量\n  Variable |        Obs        Mean    Std. Dev.       Min        Max\n————-+——————————————————— south | 2,246 .4194123 .4935728 0 1 smsa | 2,246 .7039181 .4566292 0 1\n除此之外，`*` 可以放在任何位置\n\n```stata\n. sum *arr*  // 任何中间包含 `arr` 的变量\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n     married |      2,246    .6420303    .4795099          0          1\nnever_marr~d |      2,246    .1041852    .3055687          0          1\n\n通配符：?\n与 * 类似，但只能指代一个字符，因此较少使用。\n\n更多详细用法，可通过命令 help varlist 查看。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>B3. Stata 命令的语法格式</span>"
    ]
  },
  {
    "objectID": "body/B3-Stata语法格式.html#因子变量变量的前缀",
    "href": "body/B3-Stata语法格式.html#因子变量变量的前缀",
    "title": "B3. Stata 命令的语法格式",
    "section": "3. 因子变量：变量的前缀",
    "text": "3. 因子变量：变量的前缀\n在回归分析时，对因子变量采用前缀（i.）能够跳过生成虚拟变量的步骤，提高效率。\n在系统数据集 nlsw88.dta 中，考虑因子变量 race ：\n. tab race\n\n       race |      Freq.     Percent        Cum.\n------------+-----------------------------------\n      white |      1,637       72.89       72.89\n      black |        583       25.96       98.84\n      other |         26        1.16      100.00\n------------+-----------------------------------\n      Total |      2,246      100.00\n考虑一个自变量包含 race 的回归分析：\nreg wage tenure hours i.race i.industry  // 种族和行业都是虚拟变量，省去了另生成虚拟变量的步骤。\n此外，当回归分析中需要引入交乘项 时，可以通过 # 使输入更加简捷。\nreg wage tenure hours i.marr i.marr#c.hours // 交乘项\n该命令等价于\nreg wage tenure i.marr##c.hours  // 当交乘项的两个变量也在自变量中，可用 `##` 代替这两个变量单独输入。\n注意：当交乘项为两个相同变量组成时，即为该变量的平方项。\n更多详细用法，可通过命令 help fvvarlist ([U] fvvarlist) 查看。 如下推文对此也进行了详细介绍：\n\n连玉君, 杨柳, 2020, Stata：因子变量全攻略, 连享会 No.160.",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>B3. Stata 命令的语法格式</span>"
    ]
  },
  {
    "objectID": "body/B3-Stata语法格式.html#时间序列变量的简写",
    "href": "body/B3-Stata语法格式.html#时间序列变量的简写",
    "title": "B3. Stata 命令的语法格式",
    "section": "4. 时间序列变量的简写",
    "text": "4. 时间序列变量的简写\n假设时间序列变量 \\(x_t\\) (或 \\(x_{it}\\))，各简写命令如下表所示。\n\n\n\n命令\n含义\n示例\n\n\n\n\nL.\n一阶滞后项\n\\(L.x=x_{t-1}\\)\n\n\nF.\n一阶前推项\n\\(F.x = x_{t+1}\\)\n\n\nD2.\n一阶差分项\n\\(D.x = x_t - x_{t-1}\\)\n\n\nD2.\n二阶差分项\n\\(D2.x = (x_t - x_{t-1}) - (x_{t-1} - x_{t-2})\\)\n\n\nS2.\n2 步长差分项\n\\(S2.x = x_{t} - x_{t-2}\\)\n\n\n\n利用系统数据集 sp500.dta，可以进一步了解时间序列变量简写的应用。\nsysuse \"sp500.dta\", clear\n\ntsset date\ngen t = _n               // 生成连续变量\ntsset t\n\ngen lnP = ln(close)      // 股票收盘价的对数\ngen return = D.lnP       // 生成收益率（一阶差分）\ngen Lreturn  = L.return  // 前一天的收益率（一阶滞后项）\ngen L2return = L2.return // 前两天的收益率（二阶滞后项）\n我们可以列出前六个观察值以查验变量生成机制：\n. format lnP return L* %6.4f\n. list date t lnP return L* in 1/6, clean noobs\n\n      date   t      lnP    return   Lreturn   L2return\n 02jan2001   1   7.1572         .         .          .\n 03jan2001   2   7.2061    0.0489         .          .\n 04jan2001   3   7.1954   -0.0106    0.0489          .\n 05jan2001   4   7.1688   -0.0266   -0.0106     0.0489\n 08jan2001   5   7.1669   -0.0019   -0.0266    -0.0106\n 09jan2001   6   7.1707    0.0038   -0.0019    -0.0266\n在回归中，可以不产生这些变量而直接应用，例如，对于如下模型：\n\\[R_t = \\alpha + \\sum_{p=1}^{3} \\beta_{p} R_{t-p} + \\sum_{q=1}^{2} \\beta_{q} R_{t+q} + u_t\\]\n相应的 Stata 命令可以简写为：\nreg return L(1/3).return F(1/2).return  \n更多详细用法，可通过命令 help tsvarlist ([U] tsvarlist) 查看。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>B3. Stata 命令的语法格式</span>"
    ]
  },
  {
    "objectID": "body/B4-帮助文件和外部命令.html",
    "href": "body/B4-帮助文件和外部命令.html",
    "title": "B4. 帮助文件和外部命令",
    "section": "",
    "text": "1. 命令帮助及检索\n帮助文件是学习与进阶 Stata必不可少的学习内容，而使用外部命令则可以保证方法与工具的与时俱进，提高效率。\n如想查看某命令 command 的帮助文件，最直接的方法即命令 help command，也可以对帮助本身进行查询 help help 。\n这种方法在知道命令具体的名称时较为高效，但作为初学者可能并不熟悉名称，因此可以用 findit 实现模糊查询。\n如想了解 动态面板 相关命令，则命令：\n即可在弹出窗口了解相关的命令说明。每行命令说明前会有不同类型的标识符，以区分该命令的来源。[XT] 为 Stata 官方命令； SJ* 为来源于 Stata Journal 的命令 ； 无标识则是用户自行编写命令。\n和在浏览器搜索时一样，注意以下事项，可以实现更高效的搜索：",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>B4. 帮助文件和外部命令</span>"
    ]
  },
  {
    "objectID": "body/B4-帮助文件和外部命令.html#命令帮助及检索",
    "href": "body/B4-帮助文件和外部命令.html#命令帮助及检索",
    "title": "B4. 帮助文件和外部命令",
    "section": "",
    "text": "findit dynamic panel\n\n\n\n单词的大小写和顺序 不影响检索结果\n介词可以省略\n尽量不用复数形式，distribution 优于 distributions\n不用进行时， median test 优于 medians testing\n逐渐缩小检索范围：distribution –&gt; normal distribution\n可以用如下名词限定检索范围：\ndata                        e.g.  findit data outlier\n\nstatistics  || 简写为 stat   e.g.  findit stat median\n\ngraph                       e.g.  findit graph kdensity\n\nprogram     || 简写为 prog   e.g.  findit loop",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>B4. 帮助文件和外部命令</span>"
    ]
  },
  {
    "objectID": "body/B4-帮助文件和外部命令.html#管理来自-ssc-的外部命令",
    "href": "body/B4-帮助文件和外部命令.html#管理来自-ssc-的外部命令",
    "title": "B4. 帮助文件和外部命令",
    "section": "2. 管理来自 SSC 的外部命令",
    "text": "2. 管理来自 SSC 的外部命令\nStata 外部命令主要来源于 Stata Journal 、 SSC 、 用户、会议 等，其中， SSC (Statistical Software Components) 非常常用。\n\n2.1 基本命令\nssc 相关的命令可以通过 help ssc 查询，以下列出了较为常用的几个命令：\n\n\n\n\n\n\n\n命令\n功能\n\n\n\n\nssc new\n查看新增 / 更新的命令\n\n\nssc describe b\n查看以 b 开头的所有命令\n\n\nssc describe command\n对 command 命令进行描述\n\n\nssc install command, replace\n安装 command 命令并覆盖旧版本（如果有的话）\n\n\n\n\n\n2.2 外部命令存放位置\n设置之后安装外部命令的路径（该目录相关文件夹需要事先创建）：\nnet set ado \"D:\\stata\\personal\\myplus\"\n\n\n2.3 查询已安装的外部命令\n如果想查询自己电脑上已经安装的外部命令，可以输入 ado 相关命令：\nado                   //呈现本机上安装的所有外部命令\nado, find(winsor)     //仅呈现包含特定关键词的外部命令\nado, find(panel unit)\n更便捷地，使用 mypkg 可以按首字母顺序呈现出的安装的外部命令：\nmypkg                 //呈现本机上已安装的外部命令\nmypkg xt*             //呈现 xt 开头的所有外部命令 \n若想查看命令的版本和发布时间等信息，可以使用 which 命令：\nwhich winsor2         //列示外部命令的基本信息",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>B4. 帮助文件和外部命令</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html",
    "href": "body/B5-Stata变量名称.html",
    "title": "B5. Stata中的变量名称",
    "section": "",
    "text": "1. 新变量的名称\n新变量命名的基本规则主要有 3 个：\n示例:",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html#新变量的名称",
    "href": "body/B5-Stata变量名称.html#新变量的名称",
    "title": "B5. Stata中的变量名称",
    "section": "",
    "text": "由英为 字母、数字 或 _ 组成，至多不超过 32 个字符\n首字符必须为 字母 或 _\n英文字母的大写和小写具有不同的含义\n\n\n\n合理变量名: roa, abc_1, a1, Gdp_growth\n非法变量名: 5gdp, 2invest\n\n\n特别注意：建议不要使用 _ 作为变量的第一个字母，因为许多 Stata 的内部变量都是以 _ 开头的，如：_n, _N, _cons, _b 等等。 详情参见 help _variables ([U] variables)。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html#变量重命名",
    "href": "body/B5-Stata变量名称.html#变量重命名",
    "title": "B5. Stata中的变量名称",
    "section": "2. 变量重命名",
    "text": "2. 变量重命名\n我们往往需要对原始数据进行加工，如取对数，计算比率、增长率等。这涉及到对旧变量的更名。这里主要介绍三个命令：\n\n单个变量重命名：help rename\n批量重命名：help rename group\n批量添加前缀或后缀：help renvars\n\n下面使用 Stata 自带的 auto.dta 数据集进行展示:\nsysuse \"auto.dta\", clear\n\norder make price rep78 mpg foreign trunk\n\nrename make mk\n\nrename (price rep78) (Price REP78) // 批量重命名\n\nrename mpg foreign trunk, upper    // 大写\n\nrenvars hea wei len, prefix(d1_)\n\n\n\n图1：变量命名\n\n\n\n图一:变量名称更改前后对比",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html#变量标签",
    "href": "body/B5-Stata变量名称.html#变量标签",
    "title": "B5. Stata中的变量名称",
    "section": "3. 变量标签",
    "text": "3. 变量标签\n因为变量的命名有字符长度限制，更详细的解释内容可以放入变量标签内。为变量附加文字标签可以使用 label var 命令，例如\nsysuse \"nlsw88.dta\", clear\n\nlabel var price \"汽车价格($)\"\nlabel var rep78 \"维修次数\"`\ndes\n\n\n\n图2：变量标签\n\n\n\n图二",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html#数字-文字对应表",
    "href": "body/B5-Stata变量名称.html#数字-文字对应表",
    "title": "B5. Stata中的变量名称",
    "section": "4. 数字-文字对应表",
    "text": "4. 数字-文字对应表\n在数据分析中，类别变量通常是以数字表示的。为了便于理解和解读，我们可以为这些数字赋予相应的文字标签，从而使得数据的展示更加直观。通过 Stata 中的 label define 和 label value 命令 ([D] label)，我们可以方便地为数字变量添加标签。\n例如，假设我们有一个代表满意度的类别变量，该变量的数值范围从 1 到 5，分别代表不同的满意度级别：1 - 很好、2 - 较好、3 - 中等、4 - 较差、5 - 很差。通过这种方式，数据的含义变得更加清晰易懂。\n\n示例\n假设我们使用 Stata 内置的 auto.dta 数据集，其中有一个变量 rep78 代表某些汽车的维修评级。我们可以通过以下命令为该变量定义数字与文字之间的映射关系：\nsysuse \"auto.dta\", clear\n\nlabel define rep78 1 \"很好\" 2 \"较好\" 3 \"中等\" 4 \"较差\" 5 \"很差\"   \nlabel value rep78 rep78\n\nbrowse rep78\n执行上述命令后，rep78 变量的数值将以文字形式显示。例如，原本的数值 1 会显示为 “很好”，2 显示为 “较好”，以此类推。部分代码解释如下：\n\nlabel define rep78 1 \"很好\" 2 \"较好\" 3 \"中等\" 4 \"较差\" 5 \"很差\"：这行命令定义了一个标签 rep78，并将数字 1 到 5 分别映射到相应的文字标签。\nlabel value rep78 rep78：这行命令将已定义的标签应用到变量 rep78 上，使得该变量的数值显示为对应的文字标签。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html#列示和查看变量",
    "href": "body/B5-Stata变量名称.html#列示和查看变量",
    "title": "B5. Stata中的变量名称",
    "section": "5. 列示和查看变量",
    "text": "5. 列示和查看变量\n常用的命令有：\n\ndescribe：查看数据概况，包括存贮路径、样本数、变量个数、变量名称和标签等信息 (可以简写为 d)\nds：仅列示变量名称\nds, alpha：按首字母顺序列示变量名称\ndes2：外部命令，点击蓝色链接可查看类别变量频数分布和数字-文字对应表\n\nsysuse \"nlsw88.dta\", clear\n\ndes\n\nContains data from /Applications/Stata/ado/base/n/nlsw88.dta\n  obs:         2,246                          NLSW, 1988 extract\n vars:            17                          1 May 2016 22:52\n size:        60,642                          (_dta has notes)\n---------------------------------------------------------------------\n              storage   display    value\nvariable name   type    format     label      variable label\n---------------------------------------------------------------------\nidcode          int     %8.0g                 NLS id\nage             byte    %8.0g                 age in current year\nrace            byte    %8.0g      racelbl    race\nmarried         byte    %8.0g      marlbl     married\nnever_married   byte    %8.0g                 never married\ngrade           byte    %8.0g                 current grade completed\ncollgrad        byte    %16.0g     gradlbl    college graduate\nsouth           byte    %8.0g                 lives in south\nsmsa            byte    %9.0g      smsalbl    lives in SMSA\n---------------------------------------------------------------------\nSorted by: idcode\n\n.   ds\nidcode        race          never_marr~d  collgrad      smsa          industry      union         hours         tenure\nage           married       grade         south         c_city        occupation    wage          ttl_exp\n\n.   ds, alpha\nage           collgrad      hours         industry      never_marr~d  race          south         ttl_exp       wage\nc_city        grade         idcode        married       occupation    smsa          tenure        union\ndes2命令提供的蓝色链接，点击可查看更详细的数据特征。可以完全替代 des 命令。\n\n\n\n图4：列示变量\n\n\n其中，value label 下方的蓝色链接点开会显示该变量里分类细分。点击左侧的变量，会显示该变量的频数、占比和累计占比。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B5-Stata变量名称.html#查找变量",
    "href": "body/B5-Stata变量名称.html#查找变量",
    "title": "B5. Stata中的变量名称",
    "section": "6. 查找变量",
    "text": "6. 查找变量\n对大型数据而言，变量数量太多，从右上角的变量窗口浏览查找也不高效。look for 命令可以帮助我们迅速缩小搜寻范围，快速找到目标。下面我们分别用系统自带的 nlsw8.dta 数据集和一个包含 444 个变量的大型数据样本来展示如何快速找到相关的变量：\n. sysuse nlsw88, clear\n\n. lookfor age\n\n              storage   display    value\nvariable name   type    format     label      variable label\n-----------------------------------------------------------------------\nage             byte    %8.0g                 age in current year\nwage            float   %9.0g                 hourly wage\nuse d_lookfor, clear\n\ndes\n\nContains data from d_lookfor.dta\n  obs:            30                          \n vars:           444                          1 Nov 2018 14:55\n size:        65,520                          \n----------------------------------------------------------------------------------------------------------------------------------\n              storage   display    value\nvariable name   type    format     label      variable label\n----------------------------------------------------------------------------------------------------------------------------------\nstkcd           double  %12.0g                证券代码\naccper          double  %8.0g                 会计期间\nsgnyea          str1    %9s                   年度标识\ntyprep          str1    %9s                   报表类型\nspetre          str1    %9s                   特殊处理\na110101         float   %9.0g                 货币资金\na110201         float   %9.0g                 短期投资\na110213         float   %9.0g                 短期投资跌价准备\na110227         float   %9.0g                 短期投资净额\na110235         float   %9.0g                 股票投资跌价准备\n【此处省略中间的变量】\nv379st          str3    %9s                   下市原因\n----------------------------------------------------------------------------------------------------------------------------------\nSorted by: stkcd  accper\n\nlookfor \"现金流\"\n\n              storage   display    value\nvariable name   type    format     label      variable label\n----------------------------------------------------------------------------------------------------------------------------------\nd110000         double  %10.0g                经营活动产生的现金流入小计\nd120000         double  %10.0g                经营活动产生的现金流出小计\nd100000         float   %9.0g                 经营活动产生的现金流量净额\nd210000         float   %9.0g                 投资活动产生的现金流入小计\nd220000         float   %9.0g                 投资活动产生的现金流出小计\nd200000         float   %9.0g                 投资活动产生的现金流量净额\nd310000         double  %10.0g                筹资活动产生的现金流入小计\nd320000         float   %9.0g                 筹资活动产生的现金流出小计\nd300000         float   %9.0g                 筹资活动产生的现金流量净额\nd610000         float   %9.0g                 经营活动产生的现金流量净额\n\nlookfor \"报酬\"\n\n              storage   display    value\nvariable name   type    format     label      variable label\n----------------------------------------------------------------------------------------------------------------------------------\ny1002b          double  %10.0g                董事、监事及高管前三名报酬总额\ny1003b          double  %10.0g                董事前三名报酬总额\ny1005b          double  %10.0g                高管前三名报酬总额\ny1101a          byte    %8.0g                 未领取报酬的董事、监事及高管人数\ny1102a          byte    %8.0g                 未领取报酬董事人数\ny1103a          byte    %8.0g                 未领取报酬监事人数\n与 look for 相关的另外两个外部命令，同学们可以使用帮助文件 help lookfor_all、 help findname，按照自己需要进行了解。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>B5. Stata中的变量名称</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html",
    "href": "body/B6-do文档-dofile.html",
    "title": "B6. do 文档",
    "section": "",
    "text": "1. 新建、保存和打开 dofile\nStata 有三种命令执行方式，对比如下：\n任何一个好的研究项目的必备特征就是具有好的重复性，而借助 Do-file 可以轻松地实现结果的可重复性。下面介绍如何使用 Do-file。本节内容主要源于如下推文 (. lianxh dofile do文档)：",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#新建保存和打开-dofile",
    "href": "body/B6-do文档-dofile.html#新建保存和打开-dofile",
    "title": "B6. do 文档",
    "section": "",
    "text": "A. 新建和保存 Do-file\n方法 1：点击菜单。点击 Stata 主界面第二行倒数第六个按钮 (形似一个空白的记事本上有一支黄色铅笔)。\n\n\n\n采用菜单方式新建 dofile\n\n\n方法 2：使用 doedit 命令。在 Stata 命令窗口中输入 doedit 即可新建一个空白的 Do-file，默认名称为 Untitled.do。更好的处理方法是指定 dofile 的名称和存储路径，例如\n\n输入 doedit myAER，则会在当前工作路径下自动创建一个名为 myAER.do 的 dofile。\n输入 doedit D:/paper/myAER，则会在 D:/paper/ 路径下创建一个名为 myAER.do 的 dofile。\n\n\n\n\nStata_intro_create_dofile_01\n\n\n我们可以在 dofile 中输入 Stata 命令，随后点击 「保存」 按钮，将其存入指定路径即可。例如，我们可以把新建的 Do-file 保存在 D:/Stata_Ex 文件夹下，名称为 Ex01.do，则该文件的完整存储路径为 D:/Stata_Ex/Ex01.do。\n\n注意：Stata 的 do文档 有自己专属的文件类型，后缀为 .do。因此，保存时，请不要更改其默认的文件类型：「Do-file (*.do)」。至于文件名，则没有特殊要求，中英文均可。\n\n\n\n\nB. 打开 dofile\n有两种方式可以打开电脑上已经存在的 dofile：命令行方式和菜单方式。\n\n命令行方式\n\n刚才我们新建的 Do-file 的完整存储路径为 D:/Stata_Ex/Ex01.do，因此，我们只需在 Stata 命令窗口中输入如下命令即可打开之 (当文件路径包含空格时，请务必附加半角模式下的双引号)：\n. doedit \"D:/Stata_Ex/Ex01.do\"\n\n菜单方式\n\n只需单击 Do-file 编辑器中的 「文件夹」按钮，定位至 Do-file 所在文件夹，找到需要打开的 Do-file 后，双击之即可打开。\n\n\n\n打开 Do-file：菜单方式",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#dofile-的编写",
    "href": "body/B6-do文档-dofile.html#dofile-的编写",
    "title": "B6. do 文档",
    "section": "3. dofile 的编写",
    "text": "3. dofile 的编写\n如果你已经尝试过在命令窗口执行命令，那么，dofile 无非是将这些命令统一记录在一个文档中，以便后需修改和反复执行。\n下面就是一个简单的 dofile：\n*------------------------sample01.do ----\nsysuse \"auto.dta\", clear\n\nsummarize price weight mpg  \nscatter mpg weight  \nreg mpg weight foreign\nesttab, nogap\n*------------------------sample01.do ----\n在上述代码中，我们按照以下步骤逐步完成分析：\n\n加载数据：使用 sysuse 命令加载 Stata 自带的 auto.dta 数据集。\n描述性统计：使用 summarize 命令对变量 price、weight 和 mpg 进行描述性统计，了解数据的基本特征。\n\n可视化分析：使用 scatter 命令绘制 mpg 与 weight 的散点图，直观展示两者之间的关系。\n\n回归分析：使用 reg 命令以 mpg 为因变量，weight 和 foreign 为自变量进行回归分析，探究变量之间的统计关系。\n\n结果输出：使用 esttab 命令将回归结果以简洁的表格形式输出，便于进一步解读和报告。\n\n通过将上述步骤整合到 dofile 中，不仅提高了代码的可重复性，还使得分析过程更加清晰和高效。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#dofile-的执行",
    "href": "body/B6-do文档-dofile.html#dofile-的执行",
    "title": "B6. do 文档",
    "section": "4. dofile 的执行",
    "text": "4. dofile 的执行\n你可以执行 dofile 中的部分代码，也可以一次性执行所有代码。你甚至可以在一个 dofile 中执行另一个 dofile 中的所有代码。\n\n局部执行：\n\n多数情况下，我们只需要执行 dofile 中的部分命令。做法很简单：选中目标代码，点击下图所示按钮按钮；或按下快捷键 Ctrl+D\n\n\n\nStata_intro_excute_dofile_01\n\n\n需要说明的是，你只需要选中某行中的一个以上的字符 (包括空格)，Stata 就会执行该行的代码 (这与 R 不同)。\n\n全部执行：\n\n若不选中任何代码块，而直接按快捷键 Ctrl+D，则 Stata 会一次性你执行 dofile 中的所有代码。\n有时候，这种操作可能不是你的本意，而是误操作，此时你可以点击 Stata 主界面中的红色叉号 (第二行最后一个按钮)，即可强制中断执行过程。\n\n使用命令：\n\n我们也可以通过命令来执行整份 dofile：\ndo \"D:/stata/personal/paper01/sample01.do\"\n这种方式主要用于大型项目。例如，对于复杂的项目，我们可以将不同的处理任务写在不同的 dofile 中，并将这些 dofile 统一放置在 ../codes 文件夹中。然后，可以在项目的根目录下设定一个名为 master.do 的主文档。这有几个好处：其一，整个项目的文档结构非常清楚；其二，我们可以单独执行某一部分，也可以执行 master.do 中的所有命令，以便运行项目中涉及的所有代码。\n*------------------------ master.do ------begin---\nglobal path  \"D:/stata/personal/paper01\"\ncd \"$path/codes\"\n\ndo \"01_data_clean.do\"\ndo \"02_summarize.do\"\ndo \"03_regression.do\"\ndo \"04_graph.do\"\n*------------------------ master.do ------over----",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#添加注释语句",
    "href": "body/B6-do文档-dofile.html#添加注释语句",
    "title": "B6. do 文档",
    "section": "5. 添加注释语句",
    "text": "5. 添加注释语句\n为了增加 dofile 的可读性，我们需要添加一些注释语句，主要包括：\n\n列明文档的标题、作者、生成日期等\n添加一些大标题，以便使文档结构清晰\n解释关键语句的目的和作用\n\nStata 中有三种添加注释语句的方法：\n\n单行注释： 在行首使用 * 号，则该行内容会被自动忽略。一次只能注释一行语句。\n行尾注释： 在一行命令之后至少加一个空格再加 // 字符，该行命令中 // 后的内容将被视为注释而忽略。快捷键：选中需要注释的语句，按 Ctrl + /。\n多行注释： 将需要注释的内容放在 /*  */ 组合字符里边，被该组字符括起来的内容会被忽略。快捷键：选中需要注释的语句，按 Ctrl + Shift + /。",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#断行三种方法",
    "href": "body/B6-do文档-dofile.html#断行三种方法",
    "title": "B6. do 文档",
    "section": "6. 断行：三种方法",
    "text": "6. 断行：三种方法\n当所使用的命令很长需要换行的时候，可以使用以下三种方法来实现对命令的分行操作，从而实现分行后的命令承接上一行的操作：\n\nM1. 配合使用 #delimit ; 和 #delimit cr。使用 #delimit ; 命令，可以将换符设置为 ; (Stata 的默认换行符是回车键)；使用#delimit cr 命令用来恢复默认换行符。\nM2. 使用字符组合 /// 来实现上下行的连接。\nM3. 用注释符 /* */ 来连接上下行，在操作过程中只需将上下行使用注释字符连接起来即可。\n\n下面是一些典型的例子：\n\n\n\n三种断行方式",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#dofile-编辑器的美化和语法高亮",
    "href": "body/B6-do文档-dofile.html#dofile-编辑器的美化和语法高亮",
    "title": "B6. do 文档",
    "section": "7. dofile 编辑器的美化和语法高亮",
    "text": "7. dofile 编辑器的美化和语法高亮\n在 dofile 编辑器中，依次点击：编辑 → 首选项，可以在 常规、颜色、自动完成 等子选项卡中对 dofile 编辑器的配色、字体等进行个性化设定。\n\n注意：完成本节介绍的各项设定后，可以参照 1.5 小节的方法保存为模板。\n\n详情参见 help dofile，[U] 16 Do-files，以及如下推文：\n\n刘聪聪, 2020, Stata 中 dofile 编辑器的配置 —— 来个漂亮的编辑器.\n连享会, 2020, Stata：私人定制-dofile-编辑器模板.md.\n\n\n常规-选项卡：字体、字号、缩进等\n\n依次点击：编辑 → 首选项 → 常规\n\n\n\n\ndofile 编辑器设置：常规选项卡\n\n\n\n\n颜色-选项卡：语法高亮\n\n依次点击：编辑 → 首选项 → 颜色 (Colors)。\n\n可以根据自己的喜好设定各类元素的配色。\n\n\n\n\ndofile 编辑器设置：颜色选项卡",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#良好的代码写作习惯",
    "href": "body/B6-do文档-dofile.html#良好的代码写作习惯",
    "title": "B6. do 文档",
    "section": "8. 良好的代码写作习惯",
    "text": "8. 良好的代码写作习惯\n为了满足可重复性研究的要求，我们的代码不但要能正确执行，还应该清晰、易读。如下是一些 基本建议：\n\n所有的操作 (包括: 数据处理、绘图、回归分析、结果输出等) 都要记录在 dofile 中，尽量避免手动处理\n每个项目 (每篇论文) 一个文件夹；文件分类存放，文件尽可能按照特定规则命名\n工作中，实时保存的是 dofiles，而不是 数据文件\n多加注释，以便增强代码的可读性\n注意排版，保证美观的同时，也便于查错\n\n这里，先提供一个虚构的「dofile 样本」，以便让各位了解上述原则的基本精神。\n\n首先，在 dofile 的开头，标明了文件的生成日期、作者、作用等；\n其次，在「A. 基本设定」部分用全局暂元 global 定义了文件的存储路径和子文件夹的名称简写，以便后续将不同类新的文件分门别类地存放起来；\n再次，D#.xxx，S#.xxx，R#.xxx 等部分依次为数据处理、统计分析和回归分析等内容。如此以来，即使 dofile 写的很长，仍然可以通过 Ctrl+F 快捷键快速搜索关键词定位。\n最后，值得注意是，我们频繁地使用了 local 和 global，尤其是【R. 回归分析】部分。这种做法好处很多，比如，代码的结构看起来很清晰；很容易修改，只需在定义暂元的地方统一做一次修改即可，这可以大幅降低出错的概率；代码变得很简洁，可读性自然就提高了。\n\n*------------------\n*- 一个 dofile 范本    www.lianxh.cn\n*------------------\n\n* Version 1.2, 2035/1/2\n* Author: 连家大公子\n* 目的：分析家庭收入对子女学习成绩的影响\n\n*------------\n*-A. 基本设定\n\n  global path \"D:/myPaper/Income_Mark\" //定义项目目录 \n  \n  // 需要预先在生成子文件夹：data, refs, out, adofiles\n  global D    \"$path/data\"      //数据文件\n  global R    \"$path/refs\"      //参考文献\n  global Out  \"$path/out\"       //结果：图形和表格\n  adopath +   \"$path/adofiles\"  //自编程序+外部命令 \n  cd \"$D\"                       //设定当前工作路径\n  set scheme s2color   \n\n*-核心参考资料 (参考文献和文档都存放于 $R 文件夹下)\n  shellout \"$R/Safin_Federer_2005_Aust.pdf\"\n\n*------------\n*-D1. 数据导入\n  import excel using \"$D/Income_Mark.xlsx\", first clear\n  save \"_temp_\"  // $D\\ 可以省略，应为当前工作路径就是 $D\n                 // 如果原始数据文件不大，此步骤可以省略\n\n*------------\n*-D2. 数据处理\n  gen ……\n  winsor2 ……\n  ……\n  save \"data_dealed.dta\", replace\n\n*----------------------\n*-S1. 基本描述性统计分析\n  // 如果数据处理部分未作更新，可直接这里进行后续分析\n\n  *-----表x：基本统计量-------\n  use \"data_dealed.dta\", clear \n  local v \" \" //填入变量名\n  local s \"$Out/Table1_sum\" //存储的文件名(或路径\\文件名)\n  logout, save(\"`s'\") excel replace: ///\n          tabstat `v', stat(mean sd p50 min max) f(%6.2f) c(s) \n\n  *-----表x：相关系数矩阵-------\n  local v \" \" //填入变量名\n  local s \"$Out/Table2_corr\" //存储的文件名(或路径\\文件名)\n  logout, save(\"`s'\") excel replace: ///\n          pwcorr_a `v', format(%6.2f) //star(0.05)\n\n*-----------------\n*-S2. 分组统计分析\n  use \"data_dealed.dta\", clear  \n  *-----表x：组间均值差异检验-------\n  local v \" \" //填入变量名\n  local s \"$Out/ttable2\" //存储的文件名(或路径\\文件名)\n  logout, save(\"`s'\") excel replace: ///\n          ttable2 `v', by(variable) format(%6.2f)\n\n*-------------\n*-R. 回归分析\n  use \"data_dealed.dta\", clear    \n  global y   \"Mark\"   //被解释变量\n  global x   \"Income\" //基本解释变量\n  global z   \"edu_Dad edu_Mum Age##Age ……\" //基本控制变量\n  global w   \"i.year i.industry i.race\"    //虚拟变量\n *global opt \", vce(robust)\" \n  global opt \", vce(cluster industry)\" \n  \n  reg $y $x        $opt\n  est store m1\n  reg $y $x $z     $opt\n  est store m2\n  reg $y $x $z $w  $opt\n  est store m3\n\n  *-----表x：回归结果-------\n  local s \"using $Out/Table3_reg.csv\" //执行时包括这一行会输出Excel表格\n  local m \"m1 m2 m3\"\n  esttab `m' `s', nogap compress replace   ///\n         b(%6.3f) s(N r2_a) drop(`drop')   ///\n         star(* 0.1 ** 0.05 *** 0.01)      ///\n         addnotes(\"*** 1% ** 5% * 10%\")    ///\n         indicate(\"行业效应 =*.industry\" \"年度效应 =*.year\")\n事实上，你若能在开始时遵守上述基本原则，就会慢慢发现它的好处远远大于你花费在排版上的成本。久而久之，你也会形成自己的代码风格。\n下面，着重解释一些最重要的原则。\n\nA. 实时保存 dofile 而不是数据文件\n有些人在下班前喜欢把当天处理好的数据另存一份，这是个非常糟糕的习惯！\n我的建议是：保存 dofile，而不是数据文件！ 原因很简单，一个 dofile 只有几 k 或几十 k，但数据文件往往很大。如果保存了太多版本的数据文件，随后会导致严重的混乱，也就很难保证研究结果的可重复性。有些时候，数据处理环节比较复杂，代码运行时间也较长，可以保存 1-2 次过程数据，从而加快后续处理效率。要注意的是，在 dofile 中保存过程数据时，一定要添加注释语句，并将过程数据与原始数据存放到不同的文件夹中，以免混淆或误删。\n\n\nB. 空格和注释语句\nStata没有空格和制表符的限制，为了让代码更加美观和易读，要合理使用空格和缩进。\nrename k12_unique_id sid \nrename class_unique_id class_id \nrename teacher_name teacher \n\n*或者这样\nrename k12_unique_id     sid \nrename class_unique_id   class_id \nrename teacher_name      teacher \n//可以看到后者更直观。\n缩进对代码的跨行阅读也有帮助，在视觉上更容易接受：\n// Good \nkeep   sid class_id teacher grade1 /// \n       grade2 grade3 pass\n\n// Bad  \nkeep sid class_id teacher grade1 /// \ngrade2 grade3 pass",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B6-do文档-dofile.html#文档结构",
    "href": "body/B6-do文档-dofile.html#文档结构",
    "title": "B6. do 文档",
    "section": "8. 文档结构",
    "text": "8. 文档结构\n合理设置文档结构也是实现可重复研究的关键。请参阅如下推文：\n\n邹恬华, 2022, Stata论文复现：做一个优雅的码农, 连享会 No.928.\n张弛, 2024, Stata代码规范指南, 连享会 No.1452.\n汪京, 2024, Stata代码规范指南, 连享会 No.1377. 秦范, 2022, Stata：论文重现代码模板, 连享会 No.882.\n\n如下论文的复现文档都设置了非常严谨的文档结构，供参考：\n\nEwens, M., Xiao, K., & Xu, T. (2024). Regulatory costs of being public: Evidence from bunching estimation. Journal of Financial Economics, 153, 103775. Link (rep), PDF, Google. -Appendix-, github-part-of-Data, -Replication-\nNagengast, A. J., & Yotov, Y. V., 2025. “Staggered Difference-in-Differences in Gravity Settings: Revisiting the Effects of Trade Agreements.” American Economic Journal: Applied Economics, forthcoming. Link, PDF, -Appendix-, Google, -Replication-\nBarwick, Panle Jia, Shanjun Li, Liguo Lin, and Eric Yongchen Zou. 2024. \"From Fog to Smog: The Value of Pollution Information.\" American Economic Review, 114 (5): 1338–81. DOI: 10.1257/aer.20200956 Link, PDF, -Replication-, -Appendix-, Google",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>B6. do 文档</span>"
    ]
  },
  {
    "objectID": "body/B7_Stata函数功能-需要修改完善.html",
    "href": "body/B7_Stata函数功能-需要修改完善.html",
    "title": "B7. Stata 中的函数功能",
    "section": "",
    "text": "B7.1 数学运算函数 (Math functions)\nStata 提供了非常丰富的函数功能，可以大幅提高我们的工作效率。输入 help functions 即可查看 Stata 的函数列表：\n亦可输入 ihelp functions 在线查看 PDF 手册文档 ([FN] functions)：\n下面，我们挑选一些常用的函数，以便说明 Stata 调用函数的基本语法规则。\n取自然对数或以 10 为底的对数：\n对小数取整或四舍五入：\n对类别变量可以直接分析或将其转成虚拟变量\nindustry 取 7，8 或 11 的，dummy = 1，否则 dummy = 0",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>B7. Stata 中的函数功能</span>"
    ]
  },
  {
    "objectID": "body/B7_Stata函数功能-需要修改完善.html#b7.1-数学运算函数-math-functions",
    "href": "body/B7_Stata函数功能-需要修改完善.html#b7.1-数学运算函数-math-functions",
    "title": "B7. Stata 中的函数功能",
    "section": "",
    "text": "sysuse nlsw88.dta,clear\ngen ln_wage = ln(wage)\ngen log_wage = log10(wage)\n\ngen int_tenure = int(tenure)\ngen round_tenure = round(tenure)\n\ndes2 industry\ngen dummy = inlist(industry,7,8,11)",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>B7. Stata 中的函数功能</span>"
    ]
  },
  {
    "objectID": "body/B7_Stata函数功能-需要修改完善.html#b7.2-处理字符串的函数-string-functions",
    "href": "body/B7_Stata函数功能-需要修改完善.html#b7.2-处理字符串的函数-string-functions",
    "title": "B7. Stata 中的函数功能",
    "section": "B7.2 处理字符串的函数 (String functions)",
    "text": "B7.2 处理字符串的函数 (String functions)\n\n例 1：年-月-日的分离\n\n. use \"tostring2.dta\", clear\n\n. tostring date_pub,gen(date1)\n. gen year  = substr(date1,1,4)\n. gen month = substr(date1,5,2)\n. gen day   = substr(date1,7,2)\n. destring year month day, replace\n\n     +------------------------------------------------+\n     | date_pub      date1   div   year   month   day |\n     |------------------------------------------------|\n  1. | 20070930   20070930    .5   2007       9    30 |\n  2. | 20080823   20080823    .3   2008       8    23 |\n  3. | 20090102   20090102    .7   2009       1     2 |\n  4. | 20081130   20081130    .3   2008      11    30 |\n  5. | 20061204   20061204    .4   2006      12     4 |\n     +------------------------------------------------+\n\n例 2：银企关系数据中银行名称的提取\n\n想把总行的名称取出来，如从「中国农业银行深圳光明支行」中取出「中国农业银行」：\n. use \"bankname.dta\", clear\n. compress\n\n. gen bank = objnm\n. replace bank = \"中国农业银行\" if strmatch(bank,\"*农业银行*\")\n. replace bank = \"招商银行\"     if strmatch(bank,\"*招商*\")\n. replace bank = \"中国银行\"     if strmatch(bank,\"*中国银行*\")\n. replace bank = \"中国工商银行\" if strmatch(bank,\"*工商*\")\n. replace bank = \"兴业银行\"     if strmatch(bank,\"*兴业*\")\n. replace bank = \"光大银行\"     if strmatch(bank,\"*光大*\")\n. replace bank = \"交通银行\"     if strmatch(bank,\"*交通*\")\n. replace bank = \"北京银行\"     if strmatch(bank,\"*北京*\")\n\n. list bank objnm in 1/10\n\n     ----------------------------------------------\n              bank                           objnm \n     ----------------------------------------------\n  1.  中国农业银行            中国农业银行深圳光明支行\n  2.      招商银行        招商银行股份有限公司兰州分行\n  3.      光大银行               光大银行深圳罗湖支行\n  4.  中国工商银行     中国工商银行股份有限公司萍乡分行\n  5.      中国银行                   中国银行吉首支行\n     ----------------------------------------------\n  6.      中国银行      中国银行股份有限公司深圳市分行\n  7.      北京银行                   北京银行上海分行\n  8.      中国银行                          中国银行\n  9.      兴业银行               兴业银行深圳科技支行\n 10.  中国农业银行             中国农业银行大连市分行\n     ----------------------------------------------\n写命令本身并不复杂，但需要对数据进行仔细查看，总结规律。\n其他字符函数\nhelp substr()     //截取\nhelp strmatch()   //查找替换\nhelp strpos()     //字符出现的位置\nhelp strinstr()   //替换字符\nhelp strinword()  //替换单词",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>B7. Stata 中的函数功能</span>"
    ]
  },
  {
    "objectID": "body/B7_Stata函数功能-需要修改完善.html#b7.3-生成随机数的函数-random-number-functions",
    "href": "body/B7_Stata函数功能-需要修改完善.html#b7.3-生成随机数的函数-random-number-functions",
    "title": "B7. Stata 中的函数功能",
    "section": "B7.3 生成随机数的函数 (Random-number functions)",
    "text": "B7.3 生成随机数的函数 (Random-number functions)\n在蒙特卡洛模拟分析中，我们需要生成服从特定分布的随机数，Stata 提供了多数常见随机数发生器。\nclear\nset obs 10000\n\ngen x_u = runiform()  // 服从 U~(0,1)均匀分布的随机数\ngen x_n = rnormal()   // 服从标准正态分布的随机数\ngen x_p = rpossion(5) // 服从自由度为5的泊松分布\n进一步可用 simulate 命令做蒙特卡洛模拟或用 bootstrap 命令做 bootstrap。\nhelp simulate\nhelp bootstrap",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>B7. Stata 中的函数功能</span>"
    ]
  },
  {
    "objectID": "body/B7_Stata函数功能-需要修改完善.html#相关推文",
    "href": "body/B7_Stata函数功能-需要修改完善.html#相关推文",
    "title": "B7. Stata 中的函数功能",
    "section": "相关推文",
    "text": "相关推文\n\nStata 命令：. lianxh 抽样 蒙特 随机数 函数, m\n\n\n专题：数据处理\n\nStata：gen 和 egen 中的 sum() 函数异同\nStata: gen 命令中的 group() 函数的潜在风险\n\n专题：Stata程序\n\nStata：蒙特卡洛模拟A-(Monte-Carlo-Simulation)没那么神秘\nStata程序：Monte-Carlo-模拟之产生符合特定分布的随机数\nStata程序：是否有类似-Python-中的-zip()-函数\nStata: Bootstrap-自抽样-自举法\nStata：蒙特卡洛模拟分析 (Monte Carlo Simulation)\n\n专题：文本分析-爬虫\n\nStata: 正则表达式和文本分析",
    "crumbs": [
      "Stata 入门",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>B7. Stata 中的函数功能</span>"
    ]
  },
  {
    "objectID": "body/D1-数据导入和导出.html",
    "href": "body/D1-数据导入和导出.html",
    "title": "D1. 数据的导入与导出",
    "section": "",
    "text": "1.简介\n本讲主要介绍数据在 Stata 中的导入与导出，具体包括 3 个部分：简介；Excel 数据导入；将 Stata 数据导出为 Excel 数据。\n一般情况我们拿到的数据为两种类型：(a) Excel 格式; (b) 文本文档。 Excel 格式又区分成 Excel 2003 的格式 (.xls) 与 Excel 2007&2010 (.xlsx)。我们需要把这些数据格式转换为 Stata 专属的格式 (.dta) 才能进行统计和回归分析。\n针对两种不同的情况，使用的命令也有所差别，Excel 格式导入时使用的命令是 import，对于文本文档使用的是 insheet 或者 infile。insheet 对应的文本文件是用 Tab 键来分割的，而 infile 对应的文本文件是用逗号或者空格来分隔两列的。本讲主要介绍第一种类型，即用 Excel 来存储的数据。\n这里先对 Excel 进行简要说明：\n实际上 txt 文档更为灵活，因为它没有上述单元格行数列数以及文字字符的要求，而且 txt 文档没有专属的格式，不容易损坏。一些重要的资料还是建议大家备份一份存储为文本文档。\n有时候还需要使用其他的一些软件比如 Eviews、SAS、R 等的数据格式导入 Stata 中，这些软件想要转化成 Stata 格式 (.dta) 有两种途径：",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>D1. 数据的导入与导出</span>"
    ]
  },
  {
    "objectID": "body/D1-数据导入和导出.html#简介",
    "href": "body/D1-数据导入和导出.html#简介",
    "title": "D1. 数据的导入与导出",
    "section": "",
    "text": "对于 Office 2003 定义的 Excel 在存储上有一个很大的限制，最大行数是 65536 行，最大列数是 256 列，单元格存储最大的字符数是 255 个，所以有时候可能不能满足需要。\n相对而言，采用 Office 2007 及以上版本，要求就会更加宽松一些，上限为 1048576 行，16384 列，文字变量 32767 个字符。\n\n\n\n\n第一种方式可以用 Excel 或 txt 文档作为中介进行转换\n第二种方式可以用 Stat-Transfer 软件进行转换，该软件可以实现在几十种软件之间进行数据格式的转换。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>D1. 数据的导入与导出</span>"
    ]
  },
  {
    "objectID": "body/D1-数据导入和导出.html#excel-数据的导入",
    "href": "body/D1-数据导入和导出.html#excel-数据的导入",
    "title": "D1. 数据的导入与导出",
    "section": "2. Excel 数据的导入",
    "text": "2. Excel 数据的导入\n把 Excel 数据转换成 Stata 格式，可以使用 import excel 命令 (help import excel, [D] import excel)。打开的 Excel 文档界面如下所示，第一行是变量名称。\n\n\n\n图1：Excel数据导入1\n\n\n如何将上述 Excel 文档快速导入 Stata 中呢？可以使用 import excel 命令。语法格式如下：\n\n具体应用法如下：\nimport excel auto.xls, firstrow sheet(Sheet1) clear\n\n*-Note: \n* (1) firstrow 表示把 Excel 的第一行视为变量名称\n*\n* (2) sheet()  中填入 Excel 中的 sheet 名称\n*     若导入第一个 sheet 可以不附加此选项\n*\n* (3) Excel2003 文件后缀为 .xls, \n*     Excel2007 文件后缀为 .xlsx\n具体而言，import excel 是导入 Excel 文档的固定命令格式，在 import excel 后面跟上接 Excel 文档的名称和后缀，Office 2003 的格式后缀 .xls，如果是 2007 的格式后缀要写 .xlsx 。此外，后面还有两个选项，第一个选项是 firstrow，表明了在导入 Excel 时把第一行数据当做变量的名称，第二个选项是 sheet，需要指定将 Excel 中哪个工作表导入到 Stata 中。最后一个 clear 的作用是把当前 Stata 内存清空，然后再导入 Excel 中的数据。导入 Stata 后，可在 Stata 命令框输入 browse 查看导入后的数据。如下图所示：\n\n\n\n图2：Excel数据导入2\n\n\n可以看到第一行就是变量的名称，对应上面 Excel 的第一行。数据框中有黑色的数字，也有红色的字符。对于红色的字符（文字类型）的变量一般需要做进一步处理。需要转化为Stata能够识别的变量。转化命令为encode，具体如下：\nencode Cartype, gen(Cartype2) label(foreign)\nencode后面跟上想要转换的变量名，此处为 Cartype，随后的 gen (Cartype2) 是转换后新生成的变量，label (foreign) 是为新生成的变量加上标签。转化完成后会产生一个新变量，即 Cartype2，为蓝色，表面上它显示一个文字信息，实际上它对应一个数字，Stata 会自动进行编码。最后存储为 Stata 格式，并保存在 Stata 左下角显示的路径下。 Stata 数据保存命令为 save，命令如下：\nsave \"myauto.dta\", replace\n\n* myauto 是保存的数据名称\n* replace 是指替换路径下已有的 myauto.dta 文件",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>D1. 数据的导入与导出</span>"
    ]
  },
  {
    "objectID": "body/D1-数据导入和导出.html#如何导出为-excel-数据",
    "href": "body/D1-数据导入和导出.html#如何导出为-excel-数据",
    "title": "D1. 数据的导入与导出",
    "section": "3. 如何导出为 Excel 数据",
    "text": "3. 如何导出为 Excel 数据\n使用的命令为 export，其他的写法与 import 非常相似。需要注意的是，在设定选项 firstrow() 时，有两个填项：\n\n若设定 firstrow(variables)，导出时首行为变量名；\n若设定 firstrow(varlabels)，导出时首行为变量标签。\n\nsysuse \"auto.dta\", clear\n\nexport excel auto, firstrow(variables) replace  //首行为变量名称\n\nexport excel auto, firstrow(varlabels) replace  //首行为变量标签\n除了以上介绍的命令，Stata 还有许多命令可以进行数据格式的转换。可以看以下的帮助文件。\nhelp insheet  //导入 -tab- 分隔的数据\nhelp infile   //导入  逗号 分隔的数据 \nhelp usespss  //将 SPSS 格式的数据导入 Stata\nhelp fdasave  //Save and use datasets in FDA (SAS XPORT) format\nhelp usesas   //将 SAS 格式的数据导入 Stata",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>D1. 数据的导入与导出</span>"
    ]
  },
  {
    "objectID": "body/D1-数据导入和导出.html#扩展阅读",
    "href": "body/D1-数据导入和导出.html#扩展阅读",
    "title": "D1. 数据的导入与导出",
    "section": "4. 扩展阅读",
    "text": "4. 扩展阅读\n\n廖俊超, 2020, Stata数据处理：FRED数据导入问题的解决方案, 连享会 No.313.\n张春雷, 2022, Stata+Python：导入超大Excel文档的新思路-以国泰安为例, 连享会 No.1021.\n朱菲菲, 2023, Stata：导入年度、季度、月度等频数面板数据-xtimportu, 连享会 No.1276.\n谢作翰, 连玉君, 2020, Stata小白系列之一：调入数据, 连享会 No.311.\n连享会, 2021, Stata-Python交互-8：将Stata数据导入Python, 连享会 No.558.\n连享会, 2021, Stata-Python交互-9：将python数据导入Stata, 连享会 No.559.\n连享会, 2020, Stata数据处理：import-fred-命令导入联邦储备经济数据库-FRED, 连享会 No.315.\n连享会, 2020, multimport : 一次性导入并合并多个文件, 连享会 No.228.\n连玉君, 2020, Stata数据处理：物价指数-(CPI)-的导入和转换, 连享会 No.323.",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>D1. 数据的导入与导出</span>"
    ]
  },
  {
    "objectID": "body/D2-资料的合并与追加.html",
    "href": "body/D2-资料的合并与追加.html",
    "title": "D2. 资料的合并与追加",
    "section": "",
    "text": "1. 横向合并：增加变量\n一般而言，我们在实证分析过程中用到的数据会有多个来源，只有把他们都合并起来才可以做最终的分析。本节我们介绍资料的合并与追加，主要包括横向合并与纵向合并。\n第一种情形：横向合并，即增加变量。如下图所示，假设我们的数据有两个来源： A 和 B，A 里可能包含 10 个变量，B 里包含另外 10 个变量，横向合并的基本要求就是将A和B这两份资料放到一起。关键之处是 A 和 B 中每一行的数据要一一对应，例如时间序列数据合并之后的同一交易日的数据要一一对应；如果是面板数据资料，则同一家公司在同一会计年度的数据要一一对应。\n在 Sata 中我们可以使用 merge命令进行合并。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>D2. 资料的合并与追加</span>"
    ]
  },
  {
    "objectID": "body/D2-资料的合并与追加.html#横向合并增加变量",
    "href": "body/D2-资料的合并与追加.html#横向合并增加变量",
    "title": "D2. 资料的合并与追加",
    "section": "",
    "text": "横向合并的基本原理\n\n\n\n\n\n图1 横向合并的基本原理\n\n\n\nhelp merge\n\n1.1 一对一合并 [1:1]\n\n数据形态\n\n在合并前先查看需要合并的两份数据：\nuse merge_m.dta, clear\nbrowse\n第一份数据是 merge_m.dta，包含 2001 年 1 月 2 日- 2001 年 12 月 31 日共 248 个交易日的三个变量，这三个变量分别是 x1_close、x2_volume 和 x3_change，如下图所示：\n\n\n\n图2 merge_m 数据查看\n\n\nuse merge_u.dta, clear\nbrowse\n第二份数据是 merge_n.dta，包含 2001 年 1 月 2 日- 2001 年 12 月 31 日共 248 个交易日的三个变量，这三个变量分别是 x4_open、x5_high、x6_low，如下图所示：\n\n\n\n图3 merge_n 数据查看\n\n\n我们的目的是要将这两份数据的六个变量合并起来。\n\n合并方法\n\nuse merge_m.dta, clear        // master dataset 调入需要合并的数据\nmerge 1:1 date using merge_u  // using  dataset\nbr\n请注意 merge 命令的语法，两份待合并的数据中都包含同一个变量 date 交易日，以保证两份数据合并之后同一交易日的数据一一对应； using 之后是用来合并的第二份数据 merge_u.dta；1:1 表示两份数据的维度是相同的，接下来我们会看到一维对多维或多维对一维的数据的合并。\n\n结果如下：\n\n. use merge_m.dta, clear        // master dataset\n(S&P 500)\n. merge 1:1 date using merge_u  // using  dataset\n    Result                           # of obs.\n    -----------------------------------------\n    not matched                             0\n    matched                               248  (_merge==3)\n    -----------------------------------------\n.       br\n\n\n\n图4 合并结果显示\n\n\n合并结果显示，六个变量一一对应，并生成了一个新变量_merge，_merge取值为 1 表示该行数据仅来自第一份数据，_merge取值为 2 表示该行数据仅来自第二份数据，_merge取值为 3 表示该行数据同时来自两份合并数据。\n\n\n1.2 多对一合并 [m:1]\n\n数据形态\n\nuse GTA_FS.dta,clear    //上市公司财务资料，id-year, Panel\nbr \nuse GTA_basic.dta,clear //上市公司基本资料，只有 id 没有 year\nbr\n第一份数据是来自上市公司的财务资料，是一份面板数据（截面变量为 id ，时间变量为 year ）；第二份数据是上市公司的基本资料，只有 id 没有 year。\n\n合并方法\n\nuse GTA_FS.dta, clear\nmerge m:1 id using GTA_basic.dta\nbr\n注意此处 merge 命令的写法：两份数据的共有变量是 id ，m:1 表示第一份资料的维度比第二份资料的维度高，即多维对一维的数据合并。\n\nmerge变量的含义：\n_merge==1 obs. from master dataset\n_merge==2 obs. from only using dataset\n_merge==3 obs. from at least both datasets\n\n\n\n1.3 一对多合并 [1:m]\n\n合并方法\n\n*-Note: m:1 的逆向操作\n    use GTA_basic.dta, clear\n    merge 1:m id using GTA_FS.dta, nogen\n    browse\n    order id year\n    xtset id year\n注意此处 merge 命令的写法：两份数据的共有变量是 id ，m:1 表示第一份资料的维度比第二份资料的维度低，即一维对多维的数据合并。 nogen 选项表示合并后不生成新变量_merge。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>D2. 资料的合并与追加</span>"
    ]
  },
  {
    "objectID": "body/D2-资料的合并与追加.html#纵向合并追加样本",
    "href": "body/D2-资料的合并与追加.html#纵向合并追加样本",
    "title": "D2. 资料的合并与追加",
    "section": "2 纵向合并：追加样本",
    "text": "2 纵向合并：追加样本\n\n纵向合并的基本原理\n\n资料合并的第二种情形是纵向合并，即追加样本。例如，我们在某个数据库中获得了 2001 - 2010 年的数据资料，进一步又从另一个数据库获得了 2011 - 2013 年的资料并想将其追加到第一份资料的底部，即实现纵向合并。 基本原理如下图直观显示：A 是旧资料，需将新资料 B 追加到 A 的底部。追加的基本原则是 A 中的变量要与 B 中的变量一一对应，Stata 内部会自动查找 A 和 B 数据中同名的变量并匹配。\n\n\n\n图5 纵向追加的基本原理\n\n\n在 Sata 中我们可以使用 append命令进行合并。\nhelp append\n\n两个数据库中的”同名变量”会自动对应累叠\n\n*-数据形态\n     use append_m.dta, clear\n         br\n     use append_u.dta, clear\n         br  \n*-纵向追加方法\n     use append_m.dta, clear\n     append using append_u.dta\n         br\n\n几个注意事项：\n\n两个数据库中的变量名称要相同，大小写也要完全相同。PRICE 和 price 是不同的变量。\n\n\n两个数据库中的同名变量要具有相同的存储类型。同为文字变量或同为数值变量。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>D2. 资料的合并与追加</span>"
    ]
  },
  {
    "objectID": "body/D2-资料的合并与追加.html#also-see",
    "href": "body/D2-资料的合并与追加.html#also-see",
    "title": "D2. 资料的合并与追加",
    "section": "Also See",
    "text": "Also See\n  help mergeall\n  help mergemany\n  help nearmrg\n  help factmerg\n  help cross\n  help jionby\n  help addinby",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>D2. 资料的合并与追加</span>"
    ]
  },
  {
    "objectID": "body/D2-资料的合并与追加.html#扩展阅读",
    "href": "body/D2-资料的合并与追加.html#扩展阅读",
    "title": "D2. 资料的合并与追加",
    "section": "扩展阅读",
    "text": "扩展阅读\n\nStata数据处理：reshape - 纵横变换-长宽转换 view browse “https://www.lianxh.cn/news/c48db52c26ba5.html”\n连享会：数据处理专题 view browse “https://www.lianxh.cn/blogs/25”",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>D2. 资料的合并与追加</span>"
    ]
  },
  {
    "objectID": "body/D3-缺漏值.html",
    "href": "body/D3-缺漏值.html",
    "title": "D3. 缺漏值的处理",
    "section": "",
    "text": "1. 缺漏值定义/简介\n实证分析中的原始数据资料往往存在缺漏值，而不同数据来源对于缺漏值的标记符号也存在一定差异。本讲将通过4个小节重点介绍实证分析中不同类型缺漏值的处理。\nStata中，缺漏值统一用符号 . 表示，其取值大于任意自然数。\n通过以下实例，了解不同命令对缺漏值的处理：\nsummarize主要用于展示基本统计量，缺漏值不参与基本统计，所以该命令会忽略缺漏值的情况。根据上述结果obs=11，可知维修次数超过4次的有11辆车\ncount是用于计数的命令，缺漏值大于任意自然数。当统计超过 4 次的个数时，也会考虑缺漏值；若要剔除缺漏值，需添加附加条件rep78!=.",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>D3. 缺漏值的处理</span>"
    ]
  },
  {
    "objectID": "body/D3-缺漏值.html#缺漏值定义简介",
    "href": "body/D3-缺漏值.html#缺漏值定义简介",
    "title": "D3. 缺漏值的处理",
    "section": "",
    "text": "*- 调用Stata自带数据——汽车价格资料\nsysuse auto,clear\n*- 统计1978年汽车维修次数超过4次的车辆数\n** 命令1：summarize，可简写为sum\nsum rep78 if rep78&gt;4\n\n Variable |  Obs   Mean   Std. Dev.   Min    Max\n----------+-------------------------------------\n    rep78 |   11      5          0      5      5\n\n** 命令2：count\n* 错误用法\ncount if rep78&gt;4\n16\n* 正确用法\ncount if rep78&gt;4 & rep78!=.\n11\n\n\n需注意：\n\n有些命令，如 sum, regress, generate 等，会自动忽略缺漏值；\n有些命令，如 count, keep 等，则会将 . 视为一个无穷大的数值。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>D3. 缺漏值的处理</span>"
    ]
  },
  {
    "objectID": "body/D3-缺漏值.html#缺漏值的标记",
    "href": "body/D3-缺漏值.html#缺漏值的标记",
    "title": "D3. 缺漏值的处理",
    "section": "2. 缺漏值的标记",
    "text": "2. 缺漏值的标记\n一般在数据资料中，缺漏值的标记方式有：N.A.、N/A、-97、-99、-999、-9999 等方式。\n通过以下数据文件演示如何在Stata中将数据资料中缺漏值的不同标记方式统一转换为 . ，可以通过 import 命令将 excel、txt 等格式的文件导入 Stata，导入后数据资料如下所示：\n. list\n     +----------------------+\n     | y    x1     x2    x3 |\n     |----------------------|\n  1. | 2   -97   -999   N/A |\n  2. | 6     2      3     8 |\n  3. | 3     5   -999     7 |\n  4. | 5   -97      0   N/A |\n     +----------------------+\n其中，缺漏值在x1中用-97表示，x2中用-999表示，x3中用 N/A 表示。x3因为缺漏值的标记符号为英文字母而被Stata识别为字符变量，后续需要将其转化成数值变量。因此，在缺漏值处理中，我们需要对x1和x2中数值型缺漏值进行标记转换，也需要对x3中字符型缺漏值进行标记转换。\n\n数值型缺漏值的转换：mvdecode\n\nmvdecode x1 x2,mv(-97 -999)\n命令 mvdecode中“mv”表示多变量，“decode”表示重新编码，后面的选项mv(#)可填写实例中数值型缺漏值的标记符号，多个标记符号间需用空格区分。 mvencode 可将缺漏值 . 转换为数值型取值，这里不多做演示。\n转换后结果：\n\n. list\n     +-------------------+\n     | y   x1   x2    x3 |\n     |-------------------|\n  1. | 2    .    .   N/A |\n  2. | 6    2    3     8 |\n  3. | 3    5    .     7 |\n  4. | 5    .    0   N/A |\n     +-------------------+\n\n文字型缺漏值的转换：通过替换命令 replace 可直接处理\n\n** 错误方式\n. replace x3 = . if x3== \"N/A\"\n以上命令会显示错误信息”type mismatch”，因为 replace 前后的变量类型不一致。其中x3应该为字符型变量，而 . 在此识别为数值型变量，因此需要添加双引号用 \".\" 来将其表示为字符型。转换为字符型变量后可用 destring 将字符型变量x3转换为数值型变量。\n** 正确方式\nreplace x3=\".\" if x3==\"N/A\"\ndestring x3,replace\n处理后结果显示：\n. list\n     +---------------------+\n     | y    x1     x2   x3 |\n     |---------------------|\n  1. | 2     .      .    . |\n  2. | 6     2      3    8 |\n  3. | 3     5      .    7 |\n  4. | 5     .      0    . |\n     +---------------------+\n经过以上基本处理后，可以进行统计和回归分析。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>D3. 缺漏值的处理</span>"
    ]
  },
  {
    "objectID": "body/D3-缺漏值.html#标记不包含缺漏值的样本",
    "href": "body/D3-缺漏值.html#标记不包含缺漏值的样本",
    "title": "D3. 缺漏值的处理",
    "section": "3. 标记不包含缺漏值的样本",
    "text": "3. 标记不包含缺漏值的样本\n通过以下实例展示如何标记不包含缺漏值的样本。\n调用美国1988年妇女工资数据资料，首先展示基本统计量：\nsysuse \"nlsw88.dta\", clear\n\nsum wage industry tenure hours \n\n Variable |    Obs       Mean   Std. Dev.       Min        Max\n----------+---------------------------------------------------\n     wage |  2,246   7.766949   5.755523   1.004952   40.74659\n industry |  2,232   8.189516   3.010875          1         12\n   tenure |  2,231    5.97785   5.510331          0   25.91667\n    hours |  2,242   37.21811   10.50914          1         80\n以上结果显示各变量的观测值个数并不完全相同，说明部分变量存在缺漏值。若在此数据基础上直接进行回归分析，如下结果所示，参与回归的样本数仅为2213，低于wage变量对应的2246个观测值。\nsysuse \"nlsw88.dta\", clear\nreg wage industry tenure hours\n\n  Source |       SS     df       MS   Number of obs =  2,213\n---------+-------------------------   F(3, 2209)    =  37.70\n   Model | 3592.478      3  1197.49   Prob &gt; F      = 0.0000\nResidual | 70175.16  2,209  31.7678   R-squared     = 0.0487\n---------+-------------------------   Adj R-squared = 0.0474\n   Total | 73767.64  2,212  33.3488   Root MSE      = 5.6363\n------------------------------------------------------------\n    wage |   Coeff    SE       t      P&gt;|t|      [95% CI]\n---------+--------------------------------------------------\nindustry |   0.065   0.040    1.63    0.104   -0.013   0.143\n  tenure |   0.159   0.022    7.21    0.000    0.116   0.202\n   hours |   0.075   0.012    6.42    0.000    0.052   0.098\n   _cons |   3.549   0.571    6.21    0.000    2.428   4.669\n------------------------------------------------------------\n在学术论文中，描述性统计量中的样本个数应该与参与回归的样本个数一致，在本实例中即指应该针对2213个样本进行描述性统计。因此，需将各变量的样本数进行统一。\n在Stata中，可以在回归后利用 ereturn list 呈现一些相关的返回信息数据，信息数据主要包括以下四部分：scalars（常数，如N是样本数，r2_a是调整后的\\(R^2\\)）、macros（暂元）、matrices（矩阵）、function（函数）。其中，function中的 e(sample) 是我们关心的部分，它只有0和1两种取值：0值表示该行观测值未参与之前的回归，1值表示该行观测值参与之前的回归。因此我们可用 e(sample) 识别参与了回归的样本。\n\n基本思路：先做回归，再对参与回归的样本描述基本统计量，以获得样本完全一致的各变量的基本统计量。\n\nreg wage industry tenure hours\nereturn list\nsum wage industry tenure hours if e(sample)\n* 等价于 sum wage industry tenure hours if e(sample)==1\n结果显示：\nVariable |   Obs      Mean   Std. Dev.       Min        Max\n---------+-------------------------------------------------\n    wage | 2,213  7.816986   5.774846   1.004952   40.74659\nindustry | 2,213   8.18075   3.014709          1         12\n  tenure | 2,213  6.003314   5.510447          0   25.91667\n   hours | 2,213  37.25395   10.46896          1         80\n现在各变量的样本数已完全一致。\n若觉得用条件语句 if e(sample)==1 较繁琐，可先生成一个虚拟变量标记参与回归的样本，然后选择虚拟变量的相应取值作为限定条件进行描述性统计。\ngen yes = e(sample)  //标记样本，非缺漏值取值1，缺漏值则取值0\nsort yes             //针对yes变量的取值升序排序\nsum wage industry tenure hours if yes==1\n结果显示：\nVariable |   Obs      Mean  Std. Dev.       Min        Max\n---------+------------------------------------------------\n    wage | 2,213  7.816986  5.774846   1.004952   40.74659\nindustry | 2,213   8.18075  3.014709          1         12\n  tenure | 2,213  6.003314  5.510447          0   25.91667\n   hours | 2,213  37.25395  10.46896          1         80",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>D3. 缺漏值的处理</span>"
    ]
  },
  {
    "objectID": "body/D3-缺漏值.html#删除缺漏值",
    "href": "body/D3-缺漏值.html#删除缺漏值",
    "title": "D3. 缺漏值的处理",
    "section": "4. 删除缺漏值",
    "text": "4. 删除缺漏值\n若整个回归分析中只想用不包含缺漏值的变量，还可以用 keep 保留非缺漏值的样本：\nkeep if yes==1 //或drop if yes!=1\n之后就可按照常规方法用 tabstat 展示基本统计量、reg等进行回归分析。\n*-Table 1   Also see: R1_regress, R3_table\ntabstat wage industry tenure hours, stat(N mean sd min max) format(%6.3f) column(stat) \n\n*-Table 2   Also see: R8_esttab       \nreg wage i.industry tenure hours\nesttab, nogap stat(r2_a N)",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>D3. 缺漏值的处理</span>"
    ]
  },
  {
    "objectID": "body/D4-离群值.html",
    "href": "body/D4-离群值.html",
    "title": "D4. 离群值的处理",
    "section": "",
    "text": "1. 离群值的简介\n在实证分析中，原始数据的离群值会对回归结果产生直接影响，因此在估计模型参数之前，我们经常需要对离群值进行检查和校正。基于此，本讲将通过如下几节重点介绍离群值的来源、影响以及处理方式。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>D4. 离群值的处理</span>"
    ]
  },
  {
    "objectID": "body/D4-离群值.html#离群值的简介",
    "href": "body/D4-离群值.html#离群值的简介",
    "title": "D4. 离群值的处理",
    "section": "",
    "text": "1.1 离群值的来源\n\n来源1：记录错误, 衡量偏误\n  成人身高:       max = 3.5m \n  新生儿体重:     max = 33kg\n\n一般而言，论文中需要呈现数据的基本统计量, 以便读者了解资料形态。我们通过 min, max, sd 等统计量可以初步判断是否存在严重的离群值。\n举个例子，最大最小值可以用来判断这个变量的取值是否超过了合理的范围。例如我们在研究成人身高的决定因素时，假设在基本统计量里面看到成人身高的最大值为3.5m，那么很容易怀疑这是一个离群值。类似的还有新生儿体重最大值为33kg，这也超过了合理的范围。\n\n来源2：混合分布\n  举重运动员  v.s.  篮球运动员\n  体操运动员  v.s.  相扑运动员\n\n混合分布是指同一变量内部的数据结构存在两种及以上的不同分布。\n举个例子，假设要研究运动员的体重受哪些因素的影响，那么就不能将举重运动员和篮球运动员的数据混在一起进行研究，需要进行分组回归。类似的还有体重运动员和相扑运动员，他们的体重数据也完全是两种不同的分布形态，在研究时也不能将他们的体重数据混在一起进行分析。\n\n\n1.2 离群值的影响\n在本节中，我们通过使用1978年汽车价格资料作为实例来了解离群值对回归结果的影响。具体来说，我们比较全样本和删除汽车价格离群值之后，不同因素对汽车价格的影响。\nsysuse auto, clear\nhistogram price\n\n\n\n图1 变量分布柱状图\n\n\n从密度图中可以看出，price的数据分布呈现出向右拖尾的形态，price大多在10000以下。在本例中，我们删除price超过13000的离群值。\ncount if price &gt; 13000\n4\n\nreg price weight length foreign\nest store r1\nreg price weight length foreign if price&lt;13000\nest store r2\nesttab r1 r2, mtitle(\"with\" \"without\")\n\n--------------------------------------------------\n                      (1)             (2)   \n                     with         without   \n--------------------------------------------------\nweight              5.775***        3.183***\n                   (6.02)          (3.74)   \n\nlength             -91.37**        -21.79   \n                  (-2.78)         (-0.78)   \n\nforeign            3573.1***       3383.8***\n                   (5.59)          (6.70)   \n\n_cons              4838.0          -698.8   \n                   (1.29)         (-0.23)   \n-------------------------------------------------\nN                      74              70   \n-------------------------------------------------\n通过比较删除离群值前后的回归结果可以看出，虽然price超过13000的离群值只有4个，但对回归结果的影响却很大。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>D4. 离群值的处理</span>"
    ]
  },
  {
    "objectID": "body/D4-离群值.html#离群值的处理方法",
    "href": "body/D4-离群值.html#离群值的处理方法",
    "title": "D4. 离群值的处理",
    "section": "2. 离群值的处理方法",
    "text": "2. 离群值的处理方法\n\n2.1 对数转换\n\n原理：对数变换后的数据之间的差异将减少很多\n\ndis %2.1f ln(10)\n 2.3\n\ndis %2.1f ln(100)\n 4.6\n\ndis %2.1f ln(1000)\n 6.9\n再举个例子：\nsysuse nlsw88, clear\ngen ln_wage = ln(wage)\n\ntwoway (histogram    wage, color(green))  ///\n        (histogram ln_wage, color(yellow)) \n\n\n\n图2 对数转换后的变量分布\n\n\n从密度图中可以看出，wage的原始数据分布是比较分散的。但在取对数之后，ln_wage取值在0到5的区间内，它的分布更加集中。\nNote: 对数转换后,系数估计值的含义会发生变化,解释结果时要慎重。\n\n\n2.2 删除或截尾处理 (Trimming)\n\n以某一百分位上的数值为临界点，删除在此区间外的样本，我们可以使用 winsor2 命令来进行结尾处理。\n\n举个例子：以 1th 和 99th 百分位数值为临界点进行缩尾。\nsysuse nlsw88, clear\nwinsor2 wage, cuts(1 99)  suffix(_tr) trim \nsumm wage*\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n        wage |      2,246    7.766949    5.755523   1.004952   40.74659\n     wage_tr |      2,205    7.566545    4.972783   1.932367   38.70926\n可以看到，在删除1th 和 99th 百分位以外的数值之后，虽然数据会更加集中，但样本量会有所损失。\n\n\n2.3 缩尾处理(winsor)\n在公司财务领域里面，当我们需要对多个变量进行处理时，应用比较广泛的是缩尾处理，因为它能够避免样本量的损失。\n\n缩尾处理的原理\n\n以 1th 和 99th 百分位的缩尾为例，缩尾处理是将小于 1th 百分位的数值设定为 1th 的数值，将大于 99th 百分位的数值设定为 99th 的数值。\nsysuse nlsw88, clear\nsum wage, detail\n\n                          wage\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%     1.930993       1.004952\n 5%     2.801002       1.032247\n10%     3.220612       1.151368       Obs               2,246\n25%     4.259257       1.344605       Sum of Wgt.       2,246\n\n50%      6.27227                      Mean           7.766949\n                        Largest       Std. Dev.      5.755523\n75%     9.597424       40.19808\n90%     12.77777       40.19808       Variance       33.12604\n95%     16.52979       40.19808       Skewness       3.096199\n99%     38.70926       40.74659       Kurtosis       15.85446\n\nreplace wage=1.930993 if wage&lt;1.930993 \nreplace wage=38.70926 if wage&gt;38.70926\n我们也可以直接用 winsor2 命令直接进行缩尾\nsysuse nlsw88, clear\nwinsor2 wage, cuts(1 99) \nsumm wage*\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n        wage |      2,246    7.766949    5.755523   1.004952   40.74659\n      wage_w |      2,246     7.75842    5.686979   1.930993   38.70926\n从结果中可以看到，对数据缩尾之后数据标准差会变小，同时样本量不会发生变化。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>D4. 离群值的处理</span>"
    ]
  },
  {
    "objectID": "body/D5-egen函数.html",
    "href": "body/D5-egen函数.html",
    "title": "D5. egen 系列函数",
    "section": "",
    "text": "1. egen 命令简介\negen(Extention to generate) 是 gen 的扩展，提供了大量生成新变量的函数，其中主要有生成变量的统计量（均值、标准差、中位数等）、对变量进行编码、对变量进行标准化等。在研究工作的开展过程中，灵活使用 egen 提供的函数有助于我们提高工作效率。\negen 的语法结构如下：",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>D5. egen 系列函数</span>"
    ]
  },
  {
    "objectID": "body/D5-egen函数.html#egen-命令简介",
    "href": "body/D5-egen函数.html#egen-命令简介",
    "title": "D5. egen 系列函数",
    "section": "",
    "text": "egen [type] newvar = fcn(arguments) [if] [in] [, options]\n\n1.1 简单例子\n下面我们通过调用 Stata 中的 “nlsw88.dta” 数据，演示如何使用 egen 命令生成行业工资水平中位数、行业工资水平标准差和根据行业类别与职业对数据进行重新编码。\nsysuse \"nlsw88.dta\", clear //调用数据\nsort industry wage //根据行业和工资水平进行排序\n\n*-计算行业工资水平中位数   \nbysort industry: egen wage_p50 = median(wage) //计算行业工资水平中位数\ngen wage_diff = wage-wage_p50 //计算个体工资水平与其所在行业中位数的差异\n\n*-计算行业工资水平标准差     \nbysort industry: egen wage_sd = sd(wage) //运用 egen 命令的 sd 函数计算标准差\n\n*-根据个体所属行业和职业类别，对样本进行重新编码\n  \nsort industry occupation //根据行业和职业类别进行排序\negen indocc123 = group(industry occupation) //运用 group 函数对样本进行重新编码\n更多关于 egen 命令提供的函数，可以通过查看 Stata 提供的帮助文档进行了解\nhelp egen // 查看官方命令提供的函数",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>D5. egen 系列函数</span>"
    ]
  },
  {
    "objectID": "body/D5-egen函数.html#egen-函数应用范例",
    "href": "body/D5-egen函数.html#egen-函数应用范例",
    "title": "D5. egen 系列函数",
    "section": "2. egen 函数应用范例",
    "text": "2. egen 函数应用范例\n在国际贸易领域的研究中，企业会将产品出口到不同的国家，在计算企业面临的实际汇率时，往往不是对各国汇率进行简单地算数平均，常见的计算方法为以企业的出口额为权重，计算企业几何加权实际汇率，具体公式如下所示：\n\\[EER=\\prod_{i=1}^{n}(X_i^{W_i})\\]\n即\n\\[EER=X_1^{W_1} \\times X_2^{W_2} ...  \\times X_n^{W_n}\\]\n其中, \\(X=\\text{exchange}\\)，\\(W=\\text{weight}\\)，\\(\\sum_{i=1}^{n}W_i=1\\)。\n下面结合实际例子，说明如何运用 egen 命令完成企业几何加权实际汇率的计算。\nclear //清空内存\n* firm: 企业编号 country: 出口目的国\n* exch: 汇率    export: 出口额\n\n//输入数据\ninput firm   country  exch    export \n       1    1   8       60 \n       1    2   0.03    50 \n       1    3   10      80 \n       2    2   0.03    68 \n       2    4   3       80 \n       3    2   0.03    200 \n       3    3   10      90 \n       3    4   3       250 \n       3    5   1.1     120\nend\n\n*-计算权重\nbysort firm: egen weight = pc(export), prop //计算每家公司出口到各个国家的权重\nlist, sepby(firm) //分公司列举计算结果\n     +-------------------------------------------+\n     | firm   country   exch   export     weight |\n     |-------------------------------------------|\n  1. |    1         1      8       60   .3157895 |\n  2. |    1         2    .03       50   .2631579 |\n  3. |    1         3     10       80   .4210526 |\n     |-------------------------------------------|\n  4. |    2         2    .03       68   .4594595 |\n  5. |    2         4      3       80   .5405405 |\n     |-------------------------------------------|\n  6. |    3         2    .03      200   .3030303 |\n  7. |    3         3     10       90   .1363636 |\n  8. |    3         4      3      250   .3787879 |\n  9. |    3         5    1.1      120   .1818182 |\n     +-------------------------------------------+\n\n*-计算 EER，由于几何加权实际汇率是连乘的形式，取对数可以方便计算\ngen lnexch = ln(exch) //取对数处理\ngen lnexch_x_weight = lnexch*weight \nbysort firm: egen sum_exch = total(lnexch_x_weight) //将连乘转为连加的形式\ngen EER = exp(sum_exch) //将上述计算结果取指数，得到 EER\n\n*-查验结果\nlist firm-weight EER, sepby(firm) //查验计算结果\n     +------------------------------------------------------+\n     | firm   country   exch   export     weight        EER |\n     |------------------------------------------------------|\n  1. |    1         1      8       60   .3157895   2.020605 |\n  2. |    1         2    .03       50   .2631579   2.020605 |\n  3. |    1         3     10       80   .4210526   2.020605 |\n     |------------------------------------------------------|\n  4. |    2         2    .03       68   .4594595   .3615783 |\n  5. |    2         4      3       80   .5405405   .3615783 |\n     |------------------------------------------------------|\n  6. |    3         2    .03      200   .3030303   .7296909 |\n  7. |    3         3     10       90   .1363636   .7296909 |\n  8. |    3         4      3      250   .3787879   .7296909 |\n  9. |    3         5    1.1      120   .1818182   .7296909 |\n     +------------------------------------------------------+",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>D5. egen 系列函数</span>"
    ]
  },
  {
    "objectID": "body/D5-egen函数.html#egen-命令的扩展",
    "href": "body/D5-egen函数.html#egen-命令的扩展",
    "title": "D5. egen 系列函数",
    "section": "3. egen 命令的扩展",
    "text": "3. egen 命令的扩展\n为了满足研究工作的需要，Stata 用户对 egen 函数进行了一定的扩展，其中主要有 egen_inequal (生成不平等和贫困指数的函数)、 egenmmed (生成移动中位数) 、 egenmore 、 ereplace 等，这里我们重点介绍一下 egenmore 和 ereplace。\n\n3.1 egenmore 简介\negenmore 是 egen 一个十分重要的扩展，为我们在文字处理、时间序列数据的处理等方面提供了便利，此处主要对 egenmore 提供的部分文字处理函数进行介绍。\n*-ntos() 函数： number to string\nsysuse auto, clear\n*将 rep78 中的 1 到 5 依次转换为\"优秀\"到\"差\"，并将结果保存在变量 grade 中\negen grade = ntos(rep78), from(1/5) to (\"优秀\" \"好\" \"较好\" \"较差\" \"差\")\nlist rep78 grade in 1/5\n     +---------------+\n     | rep78   grade |\n     |---------------|\n  1. |     3    较好 |\n  2. |     3    较好 |\n  3. |     .         |\n  4. |     3    较好 |\n  5. |     4    较差 |\n     +---------------+\n*-ston() 函数的用法与之类似\n\n*-incss() 函数：在查询一些重要的关键词时可以发挥一定作用\n\nuse bank_number.dta, clear //调用一份包含银行和非银行金融机构的数据\n\n*运用 incss 函数对银行机构进行标记，若字符串中包含“银行”二字，标记为1\n\negen isbank = incss(objbank), substr(\"银行\") \ndrop if isbank==0 //删除非银行金融机构\n\n\n3.2 ereplace 简介\nereplae 是在 egen 和 egenmore 的基础上进行了扩展，ereplace 允许用户运用 egen 或 egenmore 中的函数对已有变量进行替换，即将函数的运算结果存储在已有变量中。\nereplace 的语法结构如下：\nereplace [type] varname = fcn(arguments) [if exp] [in range] [, options]\n简单示例\nsysuse auto, clear\nereplace price=std(price) //将价格替换为标准化后的价格\nereplace make= sieve(make), omit(\" \") //调用 egenmore 中的 sieve 函数，此处的作用为删去 make 变量中的空格",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>D5. egen 系列函数</span>"
    ]
  },
  {
    "objectID": "body/D5-egen函数.html#总结",
    "href": "body/D5-egen函数.html#总结",
    "title": "D5. egen 系列函数",
    "section": "4. 总结",
    "text": "4. 总结\negen 命令的功能十分强大，提供了各类生成新变量的函数， egenmore 和 ereplace 等的出现，进一步强化了egen 的功能，熟悉egen 提供的各种函数，将大大提升数据处理工作的效率。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>D5. egen 系列函数</span>"
    ]
  },
  {
    "objectID": "body/D6_类别变量和分组统计.html",
    "href": "body/D6_类别变量和分组统计.html",
    "title": "D6. 类别变量和分组统计",
    "section": "",
    "text": "D6.1 列表统计\n在正式进行实证分析之前，进行变量的分组统计有助于发现样本的基本特征，并初步验证预期是否合理。有的数据有明确的分组指标：如国有 vs 民营，外资 vs 内资，东部 vs 中西部；但有的数据没有明确的分组指标，这时可以根据变量的分位数、平均值或其他指标进行确定。\n有两种方式，一是列表，使用tabulate命令；二是画图，包括柱状图或饼图，使用graph bar等命令。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>D6. 类别变量和分组统计</span>"
    ]
  },
  {
    "objectID": "body/D6_类别变量和分组统计.html#d6.1-列表统计",
    "href": "body/D6_类别变量和分组统计.html#d6.1-列表统计",
    "title": "D6. 类别变量和分组统计",
    "section": "",
    "text": "D6.1.1 一维列表\n调用妇女工资数据资料 nlsw88.dta，看各行业内妇女的分布情况，可以用 tabluate 命令来实现：\nsysuse \"nlsw88.dta\", clear\ntabulate industry\n               industry |   Freq.   Percent     Cum.\n------------------------+---------------------------\n  Ag/Forestry/Fisheries |      17      0.76     0.76\n                 Mining |       4      0.18     0.94\n           Construction |      29      1.30     2.24\n          Manufacturing |     367     16.44    18.68\n Transport/Comm/Utility |      90      4.03    22.72\n Wholesale/Retail Trade |     333     14.92    37.63\nFinance/Ins/Real Estate |     192      8.60    46.24\n    Business/Repair Svc |      86      3.85    50.09\n      Personal Services |      97      4.35    54.44\n  Entertainment/Rec Svc |      17      0.76    55.20\n  Professional Services |     824     36.92    92.11\n  Public Administration |     176      7.89   100.00\n------------------------+---------------------------\n                  Total |   2,232    100.00\n或者画柱状图，更加直观地呈现数据分布特征\ngraph hbar (count) idcode,over(industry) ///\n      blabel(bar,position(outside) format (%3.0f) ///\n                 color(blue) size(small))\n\n或者画饼图\ngraph pie, over(industry) sort\n\n加sort选项后，饼图按面积从小到大顺时针排列，与图下方的图例一一对应\n\n\nD6.1.2 二维列表\n适用情形为样本中有两个或两个以上的类别变量，基于两个或多个变量看交叉的数据分布。\ntabulate industry collgrad\n                      |   college graduate\n             industry | not colle  college g |  Total\n----------------------+----------------------+-------\nAg/Forestry/Fisheries |        14          3 |     17 \n               Mining |         4          0 |      4 \n         Construction |        26          3 |     29 \n        Manufacturing |       334         33 |    367 \nTransport/Comm/Utilit |        79         11 |     90 \nWholesale/Retail Trad |       295         38 |    333 \nFinance/Ins/Real Esta |       164         28 |    192 \n  Business/Repair Svc |        69         17 |     86 \n    Personal Services |        94          3 |     97 \nEntertainment/Rec Svc |        12          5 |     17 \nProfessional Services |       479        345 |    824 \nPublic Administration |       133         43 |    176 \n----------------------+----------------------+-------\n                Total |     1,703        529 |  2,232 \n如果要显示每个类别里样本数的占比，则用以下命令:\ntabulate industry collgrad, column nofreq\n\n                      |   college graduate\n             industry | not colle  college g |   Total\n----------------------+----------------------+--------\nAg/Forestry/Fisheries |      0.82       0.57 |    0.76 \n               Mining |      0.23       0.00 |    0.18 \n         Construction |      1.53       0.57 |    1.30 \n        Manufacturing |     19.61       6.24 |   16.44 \nTransport/Comm/Utilit |      4.64       2.08 |    4.03 \nWholesale/Retail Trad |     17.32       7.18 |   14.92 \nFinance/Ins/Real Esta |      9.63       5.29 |    8.60 \n  Business/Repair Svc |      4.05       3.21 |    3.85 \n    Personal Services |      5.52       0.57 |    4.35 \nEntertainment/Rec Svc |      0.70       0.95 |    0.76 \nProfessional Services |     28.13      65.22 |   36.92 \nPublic Administration |      7.81       8.13 |    7.89 \n----------------------+----------------------+--------\n                Total |    100.00     100.00 |  100.00 \n或者用tabplot可以画图，更加直观\ntabplot industry collgrad, ///\n        bfcolor(none) horizontal barw(1) ///\n        percent(collgrad) subtitle(% at each industry) ///\n        showval(offset(0.05))\n\n也可以根据两个分类变量来统计第三个变量的一些基本统计特征\ntabulate industry collgrad, summarize(wage) means\n           |  college graduate\n  industry | not colle  college g |     Total\n-----------+----------------------+----------\n Ag/Forest | 5.3122251  7.0626361 | 5.6211211\n    Mining | 15.349593          . | 15.349593\n Construct | 6.3992254   17.66774 | 7.5649338\n Manufactu | 6.8861197  13.730761 | 7.5015779\n Transport | 11.195142  13.225958 | 11.443353\n Wholesale | 5.8526317  8.2472956 | 6.1258966\n Finance/I | 9.4961749  11.875596 | 9.8431737\n Business/ | 6.4778803  11.728484 | 7.5157904\n Personal  | 4.3603053   5.679114 | 4.4010932\n Entertain | 5.9703888  8.5340567 | 6.7244088\n Professio | 6.2705725  10.093487 | 7.8711858\n Public Ad | 8.2137595  12.039293 |  9.148407\n-----------+----------------------+----------\n     Total | 6.9259835  10.543932 | 7.7834633\n或者用图形成呈现：\ngraph hbar (mean) wage, over(industry) over(collgrad) ///\n      intensity(*0.4) scheme(slmono) ///\n      blabel(bar,position(outside) format (%3.1f) ///\n                 color(blue) size(small))",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>D6. 类别变量和分组统计</span>"
    ]
  },
  {
    "objectID": "body/D6_类别变量和分组统计.html#d6.2-连续变量转换为类别变量",
    "href": "body/D6_类别变量和分组统计.html#d6.2-连续变量转换为类别变量",
    "title": "D6. 类别变量和分组统计",
    "section": "D6.2 连续变量转换为类别变量",
    "text": "D6.2 连续变量转换为类别变量\n更为一般的情形是，数据里只有连续变量，那如何将它们转换成类别变量？\n. sysuse nlsw88.dta,clear\n. sort wage\n. gen g_wage = group (5) //将工资等分成三组\n. tab g_wage\n\n g_wage |   Freq.   Percent      Cum.\n--------+----------------------------\n      1 |     450     20.04     20.04\n      2 |     449     19.99     40.03\n      3 |     449     19.99     60.02\n      4 |     449     19.99     80.01\n      5 |     449     19.99    100.00\n--------+----------------------------\n  Total |   2,246    100.00\n新变量g_wage取值是1-5，可以使用lable define 和label value对 g_wage设置一个数字文字对应表\nlabel define g_wage 1 \"Low\" 2 \"High\"\nlabel value g_wage g_wage\n进行初步统计分析\ntabstat wage age married union collgrad south, ///\n        stat(mean) by(g_wage) format(%4.2f)\n g_wage |   wage     age  married   union  collgrad  south\n--------+-------------------------------------------------\n      1 |   3.12   39.26     0.61    0.11      0.11   0.54\n      2 |   4.68   39.14     0.67    0.18      0.08   0.48\n      3 |   6.32   39.14     0.67    0.23      0.17   0.41\n      4 |   8.73   39.14     0.66    0.35      0.32   0.36\n      5 |  16.00   39.09     0.60    0.32      0.50   0.30\n--------+-------------------------------------------------\n  Total |   7.77   39.15     0.64    0.25      0.24   0.42\n----------------------------------------------------------\n命令label和tabstat分别对应B5和R5两讲。\n除了基本的列表分析外，还可以进行回归分析：\nlocal x \"age ttl_exp married union collgrad south c_city\"\nreg wage `x' if g_wage == 1,robust\nest store Low\nreg wage `x' if g_wage == 3,robust\nest store Mid\nreg wage `x' if g_wage == 5,robust\nest store High\nreg wage `x' ,robust\nest store Full\n\nlocal m \"Low Mid High Full\"\nesttab `m', mtitle(`m') nogap s(r2 r2_a N) b(%6.3f) ///\n            star(* 0.1 ** 0.05 *** 0.01)\n\n---------------------------------------------------------------\n              (1)            (2)           (3)           (4)   \n              Low            Mid          High          Full   \n---------------------------------------------------------------\nage         0.003          0.010         0.031        -0.048*  \n           (0.33)         (1.15)        (0.48)       (-1.82)   \nttl_exp     0.026***       0.021***      0.041         0.299***\n           (3.68)         (3.22)        (0.76)       (18.01)   \nmarried     0.159**       -0.030        -0.386        -0.123   \n           (2.37)        (-0.55)       (-0.90)       (-0.69)   \nunion       0.213**        0.105*       -0.345         0.705***\n           (2.45)         (1.71)       (-0.75)        (3.35)   \ncollgrad   -0.133          0.166**       0.910**       3.102***\n          (-1.05)         (2.46)        (2.12)       (13.22)   \nsouth      -0.222***      -0.055        -0.177        -1.347***\n          (-3.37)        (-1.03)       (-0.34)       (-7.95)   \nc_city      0.088          0.010         0.788*        0.495** \n           (1.13)         (0.19)        (1.67)        (2.57)   \n_cons       2.768***       5.658***     11.623***      5.188***\n           (6.98)        (16.23)        (4.68)        (4.91)   \n---------------------------------------------------------------\nr2          0.105          0.051         0.030         0.281   \nr2_a        0.085          0.034         0.013         0.279   \nN         320.000        400.000       391.000      1878.000   \n---------------------------------------------------------------\n分组分析有利于更加深入的讲故事，文献在也有根据分位数来分组，比如在33百分位和66百分位，将整个样本分为3组。到底要如何分组，最好根据理论分析或权威文献。\nhelp quantiles\nbysort industry: quantiles wage,gen(p_wage) nq(3)",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>D6. 类别变量和分组统计</span>"
    ]
  },
  {
    "objectID": "body/D7-赫芬达尔指数.html",
    "href": "body/D7-赫芬达尔指数.html",
    "title": "D7. HHI-赫芬达尔指数",
    "section": "",
    "text": "1. 赫芬达尔指数 （HHI） 简介\n在经济学领域，赫芬达尔指数具有非常广泛的应用。比如，在产业经济学领域，我们经常利用赫芬达尔指数来计算行业的集中度，或者在某一个行业内部竞争的程度；在微观经济学领域，我们也经常利用赫芬达尔指数来计算收入的不均等性。\n赫芬达尔-赫希曼指数 （Herfindahl-Hirschman Index，简称 HHI） ，简称赫芬达尔指数，是一种测量产业集中度的综合指数。它是指一个行业中各市场竞争主体所占行业总收入或总资产百分比的平方和，用来计量市场份额的变化，即市场中厂商规模的离散度。\n另参见 百度百科：HHI指数。\n赫芬达尔指数的计算方法具体如下：\n如果，\n\\(X\\) —— 市场的总规模 = (\\(x_1\\) + \\(x_2\\) + \\(x_3\\) + … + \\(x_N\\))\n\\(N\\) —— 该产业内的企业数\n\\(x_i\\) —— 第 \\(i\\) 个企业的规模\n\\(s_i\\) \\(= \\dfrac{x_i}{X}\\) —— 第 \\(i\\) 个企业的市场占有率\n那么，\n\\[\\text{HHI} = \\sum_{i=1}^N s_i^2 = (s_1^2 + s_2^2 + ... + s_N^2)\\]",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>D7. HHI-赫芬达尔指数</span>"
    ]
  },
  {
    "objectID": "body/D7-赫芬达尔指数.html#采用-stata-手动计算-hhi",
    "href": "body/D7-赫芬达尔指数.html#采用-stata-手动计算-hhi",
    "title": "D7. HHI-赫芬达尔指数",
    "section": "2. 采用 Stata 手动计算 HHI",
    "text": "2. 采用 Stata 手动计算 HHI\n首先，我们可以采用 egen 命令提供的 pc 函数和 total 函数手动计算赫芬达尔指数 HHI。\n首先，针对全样本，计算 “行业-年度” 层面的 HHI 指数。\n这里，我们采用 1968 年美国年轻女性 （14-26岁） 纵向调查数据集 nlswork.dta 进行演示。\nwebuse \"nlswork.dta\", clear\ngen sale = ln_wage\n    \nsort   ind_code year\nbrowse ind_code year sale\n    \nbysort ind_code year: egen pc_sale = pc(sale)\nbysort ind_code year: egen hhi = total(pc_sale^2)\nComments:\n\n如何计算 HHI5 , 即行业内前五名的 HHI ？\n部分行业中的公司数量过少如何解决？",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>D7. HHI-赫芬达尔指数</span>"
    ]
  },
  {
    "objectID": "body/D7-赫芬达尔指数.html#使用-hhi5-命令计算-hhi",
    "href": "body/D7-赫芬达尔指数.html#使用-hhi5-命令计算-hhi",
    "title": "D7. HHI-赫芬达尔指数",
    "section": "3. 使用 hhi5 命令计算 HHI",
    "text": "3. 使用 hhi5 命令计算 HHI\n更为便捷的方法是，我们直接采用连玉君老师编写的命令 hhi5 计算赫芬达尔指数 HHI。\n由于 hhi5 命令是外部命令，需要采用 findit 或 ssc install 命令下载安装。\nssc install hhi5, replace\n接下来，我们可以键入 help hhi5 查看一下 hhi5 命令的帮助。\nhelp hhi5\nhhi5 的基本语法\nhhi5 varlist [if] [in], by(groupvar) \n     [ prefix(str) top(#) mimobs(#) \n       percentage outfile(str) \n       replace noexpand \n     ]\n其中，by(groupvar) 是 hhi5 命令的必选项。下表为 hhi5 命令的选项解释。\n\n\n\n\n\n\n\n选项\n含义\n\n\n\n\nby(groupvar)\n设定分组变量，必选项\n\n\nprefix(str)\n设定新生成变量的前缀，默认为 hhi_\n\n\ntop(#)\n设定采用每个分组内最高的 # 个值参与计算\n\n\nmimobs(#)\n设定参与计算的每个分组的最少观测值数量\n\n\npercentage\n设定采用百分数的形式\n\n\noutfile(str)\n设定将计算结果数据输出为 csv 格式的数据\n\n\nreplace\n设定替换原变量\n\n\nnoexpand\n设定严格采用 top(#) 选项或 mimobs(#) 选项限定后的子样本参与计算，默认是拓展为全样本\n\n\n\n然后，我们还是采用数据集 nlswork.dta 举例演示。\nuse \"nlswork.dta\", clear\ngen sale = ln_wage\n（1） 采用行业-年度分组，并设定 percentage 选项\nhhi5 sale, by(ind_code year) percentage //产生新变量: hhi_sale\nbr ind_code sale hhi_sale\n（2） 采用每个分组中 sale 排名前 5 的观测值，并设定 prefix 选项\nhhi5 sale, by(ind_code year) top(5) prefix(hhi5)\nbr ind_code year sale hhi*\n（3） 在（2）的基础上，进一步设定每个分组中的观察值个数大于 2\nhhi5 sale, by(ind_code year) top(5) prefix(hhi5_2) minobs(2) \nbr ind_code year sale hhi*\n*-Note: 注意第 242 行的变化\n（4） 在（2）的基础上，进一步设定不扩充至 top5 以外的观察值\nhhi5 sale, by(ind_code year) top(5) prefix(HHI) noexpand\nbr ind_code year hhi* HHI*\nComments:\n\nhhi5 可以一次性计算多个变量的 HHI 指数\n附加的 percentage 选项得到的 HHI 指数将放大 10000 倍",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>D7. HHI-赫芬达尔指数</span>"
    ]
  },
  {
    "objectID": "body/D7-赫芬达尔指数.html#总结",
    "href": "body/D7-赫芬达尔指数.html#总结",
    "title": "D7. HHI-赫芬达尔指数",
    "section": "4. 总结",
    "text": "4. 总结\n连玉君老师编写的 hhi5 命令提供了非常丰富和灵活的选项设定，我们之后在计算赫芬达尔指数 HHI 时，可以直接使用。",
    "crumbs": [
      "数据处理",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>D7. HHI-赫芬达尔指数</span>"
    ]
  },
  {
    "objectID": "body/G1-Stata绘图概览.html",
    "href": "body/G1-Stata绘图概览.html",
    "title": "G1. Stata 绘图概览",
    "section": "",
    "text": "G1.1 几个简单的例子\n对于日常使用中这些二维图，stata都能提供非常简洁的命令来绘制，其中包括散点图、折线图、区域图等，较为复杂的包括矩阵图、条形图、饼图等。在时间序列分析中，我们也可以用stata命令来绘制相关系数图、偏相关系数图以及VAR分析中的脉冲响应函数图。\n如果想对stata绘图命令有一个整体的了解，我们可以查看 help graph_intro 这个帮助文件，它介绍了常用的stata绘制的二维图形的命令以及对应的选项，其中，【A quick tour】这一部分提供了一系列的绘图命令以及相关教程，点击每条命令下的蓝色链接就可以看到这条命令的执行效果。\n下面通过几个简单的案例，来让大家感受一下stata绘图的精美之处。\n首先我们来看一直彩色的蝴蝶，这支蝴蝶就是通过我们将要在第四讲中介绍的函数图来实现的。\n第二幅图形是一张密度函数曲线，附带了一系列的背景的带状。在做宏观经济分析里面，我们经常要反映不同的宏观经济学周期，这就可以通过这种带状来实现。\n我们再看一个韦恩图，我们可以通过这三个简单的圆圈来描述三个变量之间的关系以及他们重叠的程度，在R1这一讲介绍线性回归的拟合优度时，我们会利用韦恩图给出一个非常直观的展示。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>G1. Stata 绘图概览</span>"
    ]
  },
  {
    "objectID": "body/G1-Stata绘图概览.html#g1.1-几个简单的例子",
    "href": "body/G1-Stata绘图概览.html#g1.1-几个简单的例子",
    "title": "G1. Stata 绘图概览",
    "section": "",
    "text": "do G1_butterfly.do    //函数图: 一只蝴蝶, G4_function.do\n\n\n    do G1_color_brand.do  //彩色带状背景\n\n\n    sysuse nlsw88, clear\n    pvenn married collgrad south //韦恩图,  R1_regression.do",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>G1. Stata 绘图概览</span>"
    ]
  },
  {
    "objectID": "body/G1-Stata绘图概览.html#g1.2-二维图命令的基本结构",
    "href": "body/G1-Stata绘图概览.html#g1.2-二维图命令的基本结构",
    "title": "G1. Stata 绘图概览",
    "section": "G1.2 二维图命令的基本结构",
    "text": "G1.2 二维图命令的基本结构\n我们首先先通过几个简答的图形范例，让大家有一个直观的感受，然后在做一个整体上的总结。\n\n例 1：一些简单的图形\n\n我们先导入标准普尔500指数的数据，包含了2001年sp500指数258个交易日的全部资料，然后绘制最高价的走势。在 G2_line 这一讲里我们也会对这种线性趋势图进行详细的讨论。\n. sysuse sp500, clear\n. twoway line high date       // G2_line.do\n\n我们也可以绘制散点图，只需要把图形种类改成 scatter，同时我们设置散点的种类是 “+”\n    twoway scatter high date, m(+)\n\n除此之外，我们可以通过下面的命令绘制出连线图，我们看到的是一个黑白的图片，这时候我们是通过选项模板 scheme(s2mono) 来进行设定的，stata给我们提供了十几种模板，我们可以通过帮助文件来查看。有些模板是彩色的有些是黑白的，我们按照自己的需要进行设定。\n    twoway connect high date, scheme(s2mono)\n    help schemes      //绘图模板\n\n我们再看一个直方图，它与之前的二维图的规制方式不太一样，它是用了一个专属的命令 histogram 来呈现某一变量的分布情况，在 G3_histogram 这一讲里面我们会详细介绍直方图的绘制方法。\n    histogram change  //直方图,  G3_histogram.do\n\n\n例 2：两根折线图\n\n上面呈现的图形只是一幅简单的图片， 我们可以看第二个例子，绘制两根折线图。\n    twoway (line high date) (line low date) \n    twoway line high date || line low date   //等价命令\n蓝色和红色的两条线分别代表最高和最低价的走势，我们在绘制的时候实际上是通过两个透明的胶片来呈现的，第一个括号里面是第一个透明胶片，它呈现了最高价的走势，对应的第二个括号里面的是第二个透明胶片，表示最低价的走势图。这两个透明胶片是通过两个不同括号把他们分隔开的，与它等价的是，我们也可以通过 \"||\" 把它们分开，stata里面我们是使用了这种图层的概念，我们可以附加很多个图层，每一个图层呈现不同的元素。\n\n最后，我们再来看一个相对完整的例子.\n这张图也是绘制的最高价和最低价的走势图，和上面不一样的是我们增加了一系列的选项，例如图形的标题以及标题框，这是通过 title 这个选项来实现的； X 轴和 Y 轴的标题我们都对应的通过xtitle 和 ytitle 来选定，而两个轴上面的标签则通过xlabel 和 ylabel 来呈现。另外，这幅图的图例是在图的内部，这里我们是用 legend 这个命令在设置的，在随后的讲解里面 我们会非常详细的介绍这个选项的设置方法。最后我们也填写了 note 和 caption这两个注释，它们的文字说明都放在了左下角。\n完成这幅图片之后，我们可以通过几种方式来保持，一种方式是直接在生成他的过程中就通过 saving 这个选项来保存成stata默认格式 gph，但是这种图形格式在Word兼容方面并不是非常好，所以我们在实际中也可以通过一行命令 graph export 来更改图片保存格式。\nsysuse \"sp500\", clear\n\ntwoway (line high date) (line low date)         ///\n       ,                                        ///  \n   title(\"图1：股票最高价与最低价时序图\", box)    /// //图形标题\n   xtitle(\"交易日期\", margin(medsmall))         /// //x轴标题\n   ytitle(\"股票价格\")                           /// //y轴标题\n   ylabel(900(200)1400) ymtick(##5)            /// //y轴刻度标签\n   xlabel(,angle(20))                          /// //x轴刻度标签\n   legend(col(1) ring(0) position(7))          /// //图例\n   note(\"资料来源：Stata公司，SP500.dta\")       ///\n   caption(\"说明：我做的第一幅Stata图形！\")      ///\n   saving(mypig.gph, replace)                       //存储图片\n       \ngraph export G1_mygraph.wmf, replace  //输出为 .wmf 格式  \n\n\n小结\n\n最后做一个简单的总结，无论是多么复杂的图形，实际上构成的元素无非是点线面，stata 里面是通过主绘图命令以及一些选项来控制这些元素的特征，所以stata绘图过程中的关键在于选项的填写。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>G1. Stata 绘图概览</span>"
    ]
  },
  {
    "objectID": "body/G1-Stata绘图概览.html#g1.3-常用帮助文档",
    "href": "body/G1-Stata绘图概览.html#g1.3-常用帮助文档",
    "title": "G1. Stata 绘图概览",
    "section": "G1.3 常用帮助文档",
    "text": "G1.3 常用帮助文档\n在我们实际绘图过程中，可以通过下面的一些帮助文档来提升我们绘图的美感。\n  help graph_intro    //绘图导航图\n \n  help graph          //基本命令: 图形种类,保存,打印,合并等\n  \n  help graph_other    //其他图形\n  \n  help graph set      //有关图形颜色,字体等的设定\n  \n  help set scheme     //设定绘图模板\n  \n  help graph text     //在图形中添加特殊字符\n  \n  help twoway_options //图形选项,重要, 【点-线-面-文字】\n  \n  help graph_editor   //图形编辑器",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>G1. Stata 绘图概览</span>"
    ]
  },
  {
    "objectID": "body/G2 折线图和连线图.html",
    "href": "body/G2 折线图和连线图.html",
    "title": "G2. 折线图和连线图",
    "section": "",
    "text": "G2.1 折线图\n实证分析中往往需要以图形的方式更直观的呈现结果，常用的包括：折线图、连线图和线性拟合图。本讲将通过3个小节重点介绍实证分析中常用类型图形的绘制方式。\n输入 help twoway line 可以查看折线图的帮助文件。这里以 Stata 自带的 sp500.dta 数据为例，来演示其基本使用方法。\n首先，我们来绘制一副最简单的的折线图：只需指定纵轴 (high) 和横轴变量 (date) 即可：\n输出图形如下：\n上面这个图形存在一些问题，比如横轴的最右侧的刻度标签出边了，纵轴刻度默认为横置，不太符合多数期刊的排版要求。此时，我们可以通过附加选项来美化图形：\n执行上述命令后可得下图：",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>G2. 折线图和连线图</span>"
    ]
  },
  {
    "objectID": "body/G2 折线图和连线图.html#g2.1-折线图",
    "href": "body/G2 折线图和连线图.html#g2.1-折线图",
    "title": "G2. 折线图和连线图",
    "section": "",
    "text": ". sysuse sp500,clear\n. twoway line high date\n\n\n\n#delimit ;\ntwoway line high low date  in 1/20, /// 只绘制前20个样本\n         scheme(s1mono)               ///  黑白模板\n         xlabel(,angle(50))           /// 不设定X轴标签的数值和个数，位置旋转50度\n         ylabel(,angle(0) grid)       /// 不设定Y轴日期标签的显示格式和最优分割点，标签位置正常，增加浅色的横线\n         ymtick(##5)                  /// Y轴的两个显示刻度之间增加5个小的刻度，但不附加文字说明\n        lpattern(solid dash)         ///折线的类型，分别是实线和虚线\n        lcolor(green*1.2 black*0.7)  /// 折线的颜色，分别是标准绿色的加重（1.2）和标准黑色的淡化（0.7）\n        lwidth(*1.2 *1.3)            /// 折线的加粗或变细\n        graph export \"$path\\_Results\\myline.wmf\", replace ///图形绘制完成之后，可以进行保存，选择输出为wmf格式，以便插入word。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>G2. 折线图和连线图</span>"
    ]
  },
  {
    "objectID": "body/G2 折线图和连线图.html#g2.2-连线图简介",
    "href": "body/G2 折线图和连线图.html#g2.2-连线图简介",
    "title": "G2. 折线图和连线图",
    "section": "G2.2 连线图/简介",
    "text": "G2.2 连线图/简介\n连线图的绘制命令为：twoway connect，设定与折线图相似，图形中加入了许多连接符，更加明显的呈现样本的位置。 下面以一个例子来说明连线图的绘制，首先调入数据，来计算大学毕业与否两组样本在 1968-1988 年期间的平均值：\n\n use \"nlswork.dta\", clear   \nbrowse idcode year collgrad ln_wage /// /*查看原始数据*/ \ngen wage = exp(ln_wage)             ///工资的对数值转换为水平值\nreplace year = year+1900           ///年份转换为公元纪年\nbysort collgrad year: egen mwage = mean(wage) /// 根据年份和毕业与否，计算每一类别的妇女的平均工资\n\nkeep collgrad year mwage  /// 只保留绘图所用到的三个变量\nduplicates drop collgrad year, force  /// 删除重复值\n\nxtset year collgrad   ///设置面板数据\ngen diff = D.mwage ///计算一阶差分值\n\ntwoway (connect mwage year if collgrad==0)    \n       (connect mwage year if collgrad==1)   \n      (connect diff  year), ///  画了三个类别的折线\n      scheme(s1mono)        \n      ytitle(\"Mean Wage\")   ///  Y轴的标题\n      ylabel(2(1)10, angle(0) grid) /// Y轴的标签\n      xlabel(1968(2)1988, grid)     ///   X轴的标签\n      legend(label(1 \"Non College Graduate\") ///  图例的说明\n      label(2 \"College Graduate\")     \n      label(3 \"Difference\")           \n      col(1) ring(0) position(11))  /// 图例的位置是在11点钟的位置（position），ring在绘图区中\n执行上述命令后可得下图：",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>G2. 折线图和连线图</span>"
    ]
  },
  {
    "objectID": "body/G2 折线图和连线图.html#g2.3-线性拟合图",
    "href": "body/G2 折线图和连线图.html#g2.3-线性拟合图",
    "title": "G2. 折线图和连线图",
    "section": "G2.3 线性拟合图",
    "text": "G2.3 线性拟合图\nols 回归的线性拟合图和非线性拟合图的绘制命令分别为： \n twoway lfit\n twoway qfit  \n下面以一个例子进行说明，首先调入数据，\n    sysuse auto, clear\n    twoway (scatter price weight) (lfit price weight)   绘制两个图：散点图和拟合线\n\n分组绘制拟合图，例如分别绘制进口车和国产车各自的散点和拟合线\ntwoway (scatter price weight if foreign==1) \n      (lfit price weight if foreign==1)\n      (scatter price weight if foreign==0) \n       (lfit price weight if foreign==0) , \n       legend(label(1 \"Foreign\")\n         label(2 \"\")\n         label(3 \"Demestic\")\n         label(4 \"\")\n         position(4) ring(0)\n     )\n执行上述命令后可得下图：\n\n此外，我们还可以利用外部命令 aaplot，更加简单直接的呈现两个变量之间的线性关系：\naaplot gpm weight\n加入选项之后的复杂形式为：\n    aaplot gpm weight,  ///\n           lopts(lcolor(black*0.8) lpattern(dash)) ///\n           aformat(%04.3f)     ///\n           bformat(%06.4f)     ///\n           rmseformat(%4.3f)   ///\n           scheme(s1mono)",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>G2. 折线图和连线图</span>"
    ]
  },
  {
    "objectID": "body/G3-直方图.html",
    "href": "body/G3-直方图.html",
    "title": "G3. 直方图",
    "section": "",
    "text": "1. 直方图简介\n首先，让我们用一个简单的例子来演示直方图背后的含义。我们调入美国 1988 年妇女工资数据 （nlsw88），查看年龄的分布情况有多种方式： * sum 命令，可以展示变量的简单统计信息：比如样本个数、最小年龄、最大年龄、平均值和标准差。\n这两种呈现方式虽然非常准确，但是不够直观。 histogram 这个命令可以帮助我们更加直观的观察数据分布。\n此时可以看到该样本中，年龄为 35 和 36 岁的人数最多。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>G3. 直方图</span>"
    ]
  },
  {
    "objectID": "body/G3-直方图.html#直方图简介",
    "href": "body/G3-直方图.html#直方图简介",
    "title": "G3. 直方图",
    "section": "",
    "text": "sysuse nlsw88, clear\n(NLSW, 1988 extract)\n\nsum age\n\n Variable |    Obs      Mean   Std. Dev.  Min  Max\n----------+---------------------------------------\n      age |  2,246  39.15316   3.060002    34   46\n\ntab 命令可以列示不同年龄段的妇女分布的频数、比例和累计占比。\n\ntab age\n\n  age in |\n current |\n    year |   Freq.     Percent        Cum.\n---------+--------------------------------\n      34 |      53        2.36        2.36\n      35 |     260       11.58       13.94\n      36 |     257       11.44       25.38\n      37 |     225       10.02       35.40\n      38 |     219        9.75       45.15\n      39 |     234       10.42       55.57\n      40 |     208        9.26       64.83\n      41 |     222        9.88       74.71\n      42 |     160        7.12       81.83\n      43 |     165        7.35       89.18\n      44 |     163        7.26       96.44\n      45 |      78        3.47       99.91\n      46 |       2        0.09      100.00\n---------+--------------------------------\n   Total |   2,246      100.00\n\n\nhistogram age, frequency xlabel(34(1)46)\n\n\n\n\n图1 直方图1\n\n\n\n\nhistogram age, fraction  xlabel(34(1)46) 此时每个纵轴代表频率，所以纵轴之和等于1。\n\n\n\n\n图2 直方图2\n\n\n\nhistogram age, percent   xlabel(34(1)46) 此时纵轴之后加总等于 100 %。\n\n\n\n\n图3 直方图3",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>G3. 直方图</span>"
    ]
  },
  {
    "objectID": "body/G3-直方图.html#直方图详解",
    "href": "body/G3-直方图.html#直方图详解",
    "title": "G3. 直方图",
    "section": "2. 直方图详解",
    "text": "2. 直方图详解\n刚展示的 age 是一个离散变量，下面我们用 wage 这个连续变量来进一步介绍。总样本量是2246个妇女，直方图的实现在于将这2246个妇女划分为若干组，统计每一组里出现的观察值的个数。再基于总样本数算出每组的频率或 累计占比等。\nhistogram wage \n(bin=33, start=1.0049518, width=1.2042921)\n如上所示， Stata 给出了 wage 变量的带宽数量、初始值和宽度这三个信息。\n\n\n\n图4 直方图4\n\n\n下面我们具体来看一下这三个参数是如何确定的：\n\n最优的组数\n\n由一系列统计学家研究过，Stata 中采用的是下面这个公式：\n\\[\n\\mathrm{k}=\\min \\{\\operatorname{sqrt}(\\mathrm{N}) ; \\quad 10 \\ln (\\mathrm{N}) / \\ln (10)\\}\n\\]\n两者比较取最小值。 我们可以分别计算出这两个数，最后选取的33为组数。\ndis sqrt(_N)\n47.391982\n\ndis 10*ln(_N)/ln(10) \n33.514098\n\n组宽\n\n组宽是用极差除以组数得出的。极差就是一个变量的最大值减去最小值。\nsum wage\n\n Variable |    Obs      Mean   Std. Dev.       Min        Max\n----------+--------------------------------------------------\n     wage |  2,246  7.766949   5.755523   1.004952   40.74659\n\ndis \"Max = \" r(max)    //see P1_scalar.do\nMax = 40.74659\n\ndis \"Min = \" r(min)\nMin = 1.0049518\n\ndis \"Range = \" r(max)-r(min)       //极差\nRange = 39.741638\n\ndis \"width = \" (r(max)-r(min))/33  //组宽=极差/组数(bins)\nwidth = 1.2042921\n有了前面对细节的理解，下面我们画出 工资 这个变量的直方图。\nhistogram wage, frequency  \nhistogram wage, fraction   \nhistogram wage, percent    \nhistogram wage\n\n\n\n图5 分组直方图",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>G3. 直方图</span>"
    ]
  },
  {
    "objectID": "body/G3-直方图.html#直方图的美化",
    "href": "body/G3-直方图.html#直方图的美化",
    "title": "G3. 直方图",
    "section": "3. 直方图的美化",
    "text": "3. 直方图的美化\n得到直方图后，我们可以通过一系列的选项更改直方图的外观。 * 附加正态分布密度曲线\nhistogram wage, normal\n\n\n\n图6 直方图6\n\n\n其中正态分布曲线是由 工资 变量的均值和标准差决定的。\n\n附加核密度函数曲线\n\nhistogram wage, kdensity\n\n\n\n图7 直方图7\n\n\n\n长条的显示\n\n此外，我们还可以对小柱状体的宽度和颜色，图片的颜色进行设置。\nhistogram wage, gap(50)  // 小柱状体间距缩小为默认值的 50%\nhistogram wage, gap(90) scheme(s1mono)  //黑白图形    \nhistogram wage, gap(60) scheme(s1mono) fcolor(white) lcolor(black) lwidth(*0.8)\n\nNotes:\n\n\nfcolor 代表图七中第三个图里，小柱状体里填充的是白色。\n\nlcolor代表柱体的边框为黑色。\n\n\n\n\n图8 直方图8\n\n\n\n附加标签\n\nhistogram age, freq  addlabels\n可以在直方图中标示出每组数据的频次。\n\n\n\n图9 直方图9",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>G3. 直方图</span>"
    ]
  },
  {
    "objectID": "body/G3-直方图.html#分组绘制直方图",
    "href": "body/G3-直方图.html#分组绘制直方图",
    "title": "G3. 直方图",
    "section": "4. 分组绘制直方图",
    "text": "4. 分组绘制直方图\n如果我们想看大学毕业与否会怎样影响妇女的工资，可以使用以下命令：\nhistogram wage, by(collgrad) gap(80) scheme(s1mono) percent\n\n\n\n图10 直方图10\n\n\n可以看到，大学毕业的妇女平均工资 （10） 比没有大学毕业的妇女平均工资 （5） 高。但是观察两端的数据， 比如收入等于40，两组之间并没有很大差别。看起来，大学毕业只是有助于一个人平均工资的增加。对于能力特别强的人 是否上大学对他的工资水平没有太大影响。\n外部命令 byhist 可以使图十中两个直方图交错的展现在一张图里。\nsysuse nlsw88,clear\nbyhist wage, by(collgrad) frac tw(legend(row(2) ring(0) position(1)))\n  \nbyhist wage, by(collgrad) density ///\ntw1(color(black))          ///\ntw2(color(blue))           ///\ntw(legend(label(1 \"Otherwise\")  ///\nlabel(2 \"College Graduate\") ///\ncol(1) ring(0) pos(1)))\n\n\n\n图11 直方图11\n\n\n比直方图更精简的展示，可以使用核密度函数图：\ntwoway (kdensity wage if collgrad==0)     /// \n(kdensity wage if collgrad==1),    /// \nxtitle(\"Hourly wage\")              ///\nlegend(label(1 \"Otherwise\")        ///\nlabel(2 \"College Graduate\") ///\ncol(1) ring(0) pos(3))\n\n\n\n图12 核密度图\n\n\n此时得到的结果，与直方图展示的信息完全一样。但是它更加突出两个组之间平均工资的差别。\nbihist 命令可以展示对称直方图。\nsysuse nlsw88, clear\n    \nbihist wage, by(collgrad) frac \n    \nbihist wage, by(collgrad) frac tw(legend(col(1)) scheme(s1mono)) \n\n\n\n图13 直方图13\n\n\n右边设成黑白色的图片更适合投稿。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>G3. 直方图</span>"
    ]
  },
  {
    "objectID": "body/G4-函数图.html",
    "href": "body/G4-函数图.html",
    "title": "G4. 函数图",
    "section": "",
    "text": "1. 函数图概览\n我们通常利用函数图来完成两个基本的目的:\n我们常用 twoway function 命令来绘制函数图。比如，绘制一个最简单的函数 \\(y=x\\) 。Stata 画出的图的纵横比不是 1:1 ，显示的不是一个正方形。aspect(1) 选项可以解决这个问题。具体示例如下：\n在 Stata 默认的情况下，x 的取值范围是 0-1 之间。 range选项可以改变 x 的取值范围。可以呈现出更完整的二次曲线形状。 xline选项可以给该图增加一条蓝色虚线的对称轴。 具体 Stata 命令操作和图案效果如下：",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>G4. 函数图</span>"
    ]
  },
  {
    "objectID": "body/G4-函数图.html#函数图概览",
    "href": "body/G4-函数图.html#函数图概览",
    "title": "G4. 函数图",
    "section": "",
    "text": "twoway function y = x\ntwoway function y = x, aspect(1) \n\n\n\n图1 函数图1\n\n\n\ntwoway function y = -2*x^2 + 8*x + 10\ntwoway function y = -2*x^2 + 8*x + 10, range(-10 10)\ntwoway function y = -2*x^2 + 8*x + 10, range(-10 10) xline(2, lpattern(dash) lcolor(blue))\n\n\n\n图2 函数图2\n\n\n\n\n\n图3 函数图3\n\n\n\n\n\n图4 函数图4",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>G4. 函数图</span>"
    ]
  },
  {
    "objectID": "body/G4-函数图.html#多幅函数图叠加",
    "href": "body/G4-函数图.html#多幅函数图叠加",
    "title": "G4. 函数图",
    "section": "2. 多幅函数图叠加",
    "text": "2. 多幅函数图叠加\nStata 可以画出多种随机数分布的密度曲线，我们画一个 t 分布的密度函数曲线为例。\ntwoway  (function Normal = normalden(x), range(-8 8))  ///\n        (function    t20 = tden(20,x), range(-8 8))    ///\n        (function    t3  = tden(3 ,x), range(-8 8))    ///\n        (function    t1  = tden(1 ,x), range(-8 8)),   ///\n        legend(col(1) position(1) ring(0) size(*1.1))  ///\n        xtitle(\"t distribution\", margin(t+2) size(*1.3))\n\n\n\n图5 函数图5\n\n\n图五中有四条曲线，分别是一条正态分布曲线，其它三条是自由度分别为 20， 3， 1 的 t 分布曲线。命令中的 legend 选项是设定图例样式的； size 可以调节字体大小为默认值的多少倍 （示例中是 1.1 倍）；margin (t+2)可以将图片标题与 x 轴拉开一定的距离。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>G4. 函数图</span>"
    ]
  },
  {
    "objectID": "body/G4-函数图.html#添加特殊字符和文字",
    "href": "body/G4-函数图.html#添加特殊字符和文字",
    "title": "G4. 函数图",
    "section": "3. 添加特殊字符和文字",
    "text": "3. 添加特殊字符和文字\nStata 中添加字符，是用简写的代码对应具体的希腊字母，代码书写并不直观。 在 help graph text 命令下，打开蓝色字体的 text 可以阅读详细 PDF 文档。\n\n\n\n图6 函数图6\n\n\n下面我们绘画一个卡方分布的曲线：\ntwoway function y = gammaden(3/2,2,0,x), range(0 10) ///\ntitle(\"{&chi}{sup:2}(3) distribution\")\n\n\n\n图7 卡方分布图1\n\n\n注意此处卡方分布的书写方式，就是引用了对应的代码。\n我们也可以用 text 选项为图中的多条曲线加注名字。 text 后括号中的前两个数值，分别对应所附加文字的纵坐标和横坐标。具体数值大小需用肉眼判断位置，调试几次后即可。具体命令和图片示例如下：\ntwoway ///\n    (function chi1 = gammaden(1/2,2,0,x), range(0 10))  ///\n    (function chi3 = gammaden(3/2,2,0,x), range(0 10))  ///\n    , ///\n    legend(off) ///\n    subtitle(\"{&chi}{sup:2} distribution\", ///\n              margin(t+2) size(*1.3)) ///\n    text(1.5 0.4 \"{&chi}{sup:2}(1)\")  ///\n    text(0.3 0.4 \"{&chi}{sup:2}(3)\") \n\n\n\n图8 卡方分布图2",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>G4. 函数图</span>"
    ]
  },
  {
    "objectID": "body/P1-单值.html",
    "href": "body/P1-单值.html",
    "title": "P1. 单值",
    "section": "",
    "text": "P1.1 单值简介\nStata 的基本操作对象是变量，比如调入汽车价格这份数据：\n浏览数据窗口，每列是一个变量，每一行的观察值是常数，如红色方框中的3799。这些常数在 Stata 里被称为单值。\n另外，在做基本统计分析时（summarize) ，每一个基本统计量都是一个常数，也称为单值，可以通过一系列的命令，把这些基本统计量更为有序地排列为一个表格，插入 Word 中，即为论文中常见的第一张表（基本统计量表格）。\n在做回归分析时，表中的基本统计量如 t 值、R2 也是单值，可以通过一系列命令呈现在回归分析表格中，即为论文中常见的表 2、表 3 等。\n因此，简单来讲，单值就是一些常数。在写程序时，操作对象通常是变量；但是中间计算结果有一些常数和文件，分别对应为 单值 (scalar)、暂元 (local) 和后续要介绍的 临时性文件 (tempfile) 等。",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>P1. 单值</span>"
    ]
  },
  {
    "objectID": "body/P1-单值.html#p1.1-单值简介",
    "href": "body/P1-单值.html#p1.1-单值简介",
    "title": "P1. 单值",
    "section": "",
    "text": ". sysuse auto,clear\n. browse\n\n\n\n. sysuse \"auto.dta\", clear\n. sum price\n\n Variable |    Obs       Mean    Std. Dev.    Min     Max\n----------+----------------------------------------------\n    price |     74   6165.257    2949.496    3291   15906\n\n\n\nP1.1.1 定义单值：存放数字\n首先，我们可以利用单值来存放数字。\n我们定义单值 a，使用等号为其赋值，在 a 单值内存了数字3，可以看成一个小盒子。\n使用 display 可以呈现该单值。如果要引用该单值，只需要引用其名称，如 dis b 则会自动计算出结果。\n利用单值的最大好处是，我们只需知道单值的名称，每次用其名称即可引用数值，而不必记住具体何值。\nscalar a = 3\nscalar b = ln(a)+3^a\ndis a \ndis b\n\n\nP1.1.2 定义单值：存放字符串\n单值不仅能存放数字，还能存放字符串。比如在 c 单值内，我们存放了 .a；在s1单值内，存放了两个单词，外加中间一个逗号和一个空格。如想提出其中的第一个单词，可以使用 substr 函数进行提取，并将该单词呈现出来。\nscalar c = .a\ndis c\nscalar s1 = \"hello, Arlion\"\nscalar s2 = substr(s1,1,5)\ndis c\ndis s1\ndis s2\ndisplay 命令还是一个简单的计算器。display 命令还是一个好用的计算器，除加总求和等简单计算以外，也可以计算一些复杂的表达式。为了增加美感度，可以定义小数点后保留2位。\ndis 124.3+900.2*2+15*23\ndis %6.2f ln(3)+(3^4.2)/exp(2)",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>P1. 单值</span>"
    ]
  },
  {
    "objectID": "body/P1-单值.html#p1.2-执行命令后的单值结果",
    "href": "body/P1-单值.html#p1.2-执行命令后的单值结果",
    "title": "P1. 单值",
    "section": "P1.2 执行命令后的单值结果",
    "text": "P1.2 执行命令后的单值结果\n接下来看一些更为实用的结果，比如将执行命令后的一些基本统计量存放在单值内。\n首先调入汽车价格数据，计算价格的基本统计量，进行 summarize 后呈现了五个基本统计量：样本数，平均值，标准差，最小值和最大值。\n完成 summarize 后，输入return list，返回值并列示在屏幕上。屏幕中呈现出7个基本统计量，除了上午所述的5个统计量之外，还有额外的统计量如观察值的和、方差、权重求和等。关于单值的命名，我们在上文中自行定义了a、b、c等简洁的名称，这里的单值名称自动生设置为 r(N)、r(sum_W) 等。\n. sysuse \"auto.dta\", clear\n. sum price\n. return list\n\nscalars:\n                  r(N) =  74\n              r(sum_w) =  74\n               r(mean) =  6165.256756756757\n                r(Var) =  8699525.974268789\n                 r(sd) =  2949.495884768919\n                r(min) =  3291\n                r(max) =  15906\n                r(sum) =  456229\n我们可以通过 r(N)、r(sd) 分别来引用样本量和标准差的单值。\ndis r(N)\ndis r(sd)\n在呈现论文的第一张表（基本统计量表格）的时候经常使用这个tabstat 命令。\n在 stata 命令的选项中，可以选择很多种统计量来呈现，我们不需要用 r( ) 的形式来指明呈现何种统计量，只需要提供核心的名字（如 mean 等) 即可。如果查看帮助文件，可以看到十余种可选择的统计量。\nstat 中还可以加 p25 , p50 等，用来统计第25百分位数和中位数。\ntabstat price weight length mpg,stat(mean sd min max) ///\n        format(%4.2f) column(stat)\n    variable |      mean        sd       min       max\n-------------+----------------------------------------\n       price |   6165.26   2949.50   3291.00  15906.00\n      weight |   3019.46    777.19   1760.00   4840.00\n      length |    187.93     22.27    142.00    233.00\n         mpg |     21.30      5.79     12.00     41.00\n------------------------------------------------------\n回归分析中也可以引用单值，如用汽车价格对汽车重量、长度、耗油量进行回归。屏幕上右上角是一些基本统计量，甚至系数也可以视为单值。敲入 e(return) 即可呈现。\n. sysuse \"auto.dta\", clear\n. reg price weight length mpg\n\n  Source |       SS           df       MS      Number of obs   =        74\n---------+----------------------------------   F(3, 70)        =     12.98\n   Model |   226957412         3  75652470.6   Prob &gt; F        =    0.0000\nResidual |   408107984        70  5830114.06   R-squared       =    0.3574\n---------+----------------------------------   Adj R-squared   =    0.3298\n   Total |   635065396        73  8699525.97   Root MSE        =    2414.6\n--------------------------------------------------------------------------\n   price |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]\n---------+----------------------------------------------------------------\n  weight |      4.365      1.167     3.74   0.000        2.036       6.693\n  length |   -104.868     39.722    -2.64   0.010     -184.090     -25.646\n     mpg |    -86.789     83.943    -1.03   0.305     -254.209      80.630\n   _cons |  14542.434   5890.632     2.47   0.016     2793.940   26290.929\n--------------------------------------------------------------------------\n\n. ereturn list\n\nscalars:\n                  e(N) =  74\n               e(df_m) =  3\n               e(df_r) =  70\n                  e(F) =  12.97615618434597\n                 e(r2) =  .3573764422666367\n               e(rmse) =  2414.562912972107\n                e(mss) =  226957411.8725975\n                e(rss) =  408107984.2490242\n               e(r2_a) =  .3298354326494926\n                 e(ll) =  -679.3516104997997\n               e(ll_0) =  -695.7128688987767\n               e(rank) =  4\n\nmacros:\n            e(cmdline) : \"regress price weight length mpg\"\n              e(title) : \"Linear regression\"\n          e(marginsok) : \"XB default\"\n                e(vce) : \"ols\"\n             e(depvar) : \"price\"\n                e(cmd) : \"regress\"\n         e(properties) : \"b V\"\n            e(predict) : \"regres_p\"\n              e(model) : \"ols\"\n          e(estat_cmd) : \"regress_estat\"\n\nmatrices:\n                  e(b) :  1 x 4\n                  e(V) :  4 x 4\n\nfunctions:\n             e(sample)   \n在 Stata 中，对于只做统计而不回归的命令，在返回值的时候都可以使用 return list来列示 list 中存储的返回值。涉及到回归的命令，在返回值的时候则需要用 ereturn list，包括几大类：单值（scalars)、暂元（macros)等，这里我们重点关注单值，如样本数 e(N) ，R2 e(r2)，调整后的R2 e(r2_a)，对数似然函数值 e(ll) 等。\n在回归完后，可以用 est store 命令把结果存储起来，进而使用外部命令 esttab 或 outreg2 统一呈现结果 (参见 专题：结果输出)，非常类似于论文中看到的表格样式。表中重点的内容有如下几项，包括 scalar（下面列示的最下方的4行）。\n. sysuse \"auto.dta\", clear\n. reg price weight length mpg\n. est store m1\n. reg price weight length mpg foreign\n. est store m2\n. esttab m1 m2, scalar(N r2 r2_a F) nogap\n\n--------------------------------------------\n                      (1)             (2)   \n                    price           price   \n--------------------------------------------\nweight              4.365***        5.716***\n                   (3.74)          (5.63)   \nlength             -104.9*         -92.48** \n                  (-2.64)         (-2.75)   \nmpg                -86.79          -13.41   \n                  (-1.03)         (-0.19)   \nforeign                            3550.2***\n                                   (5.42)   \n_cons             14542.4*         5515.6   \n                   (2.47)          (1.05)   \n--------------------------------------------\nN                      74              74   \nr2                  0.357           0.549   \nr2_a                0.330           0.523   \nF                   12.98           21.01   \n--------------------------------------------\nt statistics in parentheses\n* p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>P1. 单值</span>"
    ]
  },
  {
    "objectID": "body/P1-单值.html#p1.3-一些特殊的单值",
    "href": "body/P1-单值.html#p1.3-一些特殊的单值",
    "title": "P1. 单值",
    "section": "P1.3 一些特殊的单值",
    "text": "P1.3 一些特殊的单值",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>P1. 单值</span>"
    ]
  },
  {
    "objectID": "body/P1-单值.html#p1.3.1-系统变量",
    "href": "body/P1-单值.html#p1.3.1-系统变量",
    "title": "P1. 单值",
    "section": "P1.3.1 系统变量",
    "text": "P1.3.1 系统变量\nstata 还提供了一些非常特殊的单值，如系统变量、系统参数等。\n系统变量基本都存储在以下划线开头的变量里面，help 文件中列示了一些最基本的系统变量，如常数项、样本标号、样本总数等。\nhelp _variables\ndis _pi   //圆周率\nsysuse nlsw88,clear\ndis _N",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>P1. 单值</span>"
    ]
  },
  {
    "objectID": "body/P1-单值.html#p1.3.2-系统参数设置",
    "href": "body/P1-单值.html#p1.3.2-系统参数设置",
    "title": "P1. 单值",
    "section": "P1.3.2 系统参数设置",
    "text": "P1.3.2 系统参数设置\nStata 的系统参数很多，可以通过 creturn list 来查看。屏幕中列示了很多内容，现阶段可以不必深究。\n如：\n\nc(current_date) 显示当前日期\nc(current_time) 显示当前时间\nc(sysdir_stata) 显示 Stata 的安装路径\n\n还有 Stata 的版本等，都是通过特定的单值名称存储了起来。这些参数在编程序的时候非常有用，只需要相应的名称即可调用。\n. creturn list\n\nSystem values\n\n    ---------------------------------------\n        c(current_date) = \"23 Dec 2020\"\n        c(current_time) = \"17:05:01\"\n\n(省略……)\n\nDirectories and paths\n\n    ---------------------------------------\n        c(sysdir_stata) = \"D:\\stata15/\"              (sysdir)\n         c(sysdir_base) = \"D:\\stata15\\ado\\ba..\"      (sysdir)\n         c(sysdir_site) = \"D:\\stata15\\ado\\si..\"      (sysdir)\n         c(sysdir_plus) = \"D:\\stata15/ado\\pl..\"      (sysdir)\n     c(sysdir_personal) = \"D:\\stata15/ado\\pe..\"      (sysdir)",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>P1. 单值</span>"
    ]
  },
  {
    "objectID": "body/P2-暂元.html",
    "href": "body/P2-暂元.html",
    "title": "P2. 暂元",
    "section": "",
    "text": "1 引言\n「暂元」顾名思义就是暂时性的存储单元。在 Stata 里面又分成「局域暂元」和「全局暂元」，并分别通过 local 和 global 来定义。实际上，暂元是用来临时存储复杂计算的中间结果，一旦命令执行完，暂元中的数字或文字便会自动消失，故不占用硬盘空间。\n关于暂元的详细介绍，可以通过 help local 或 help macro 查看电子手册 [P] macro – Macro definition and manipulation。",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>P2. 暂元</span>"
    ]
  },
  {
    "objectID": "body/P2-暂元.html#局域暂元-local",
    "href": "body/P2-暂元.html#局域暂元-local",
    "title": "P2. 暂元",
    "section": "2 局域暂元 (local)",
    "text": "2 局域暂元 (local)\n\n2.1 暂元的基本功能\n\n存放数字\n\n与定义单值 scalar a = 5 类似，暂元也是通过 local a = 5 这种方式定义。然后，需要通过 dis `a' 命令列示暂元 a 内容。暂元的引用格式为键盘 Tab 键上方「反引号」加键盘 Enter 键 左边「单引号」，即 `a' 格式。\n若单独运行 local a = 5 和 display `a'， 则不会有结果输出。这是因为运行 local a = 5时，结果会存储在一个临时文件，而当文件关闭时，暂元被释放。因此，只有在一个临时文件中运行，即同时选中 local a = 5 和 display `a' 两条命令并运行，才会输出暂元内容。\n\n\n\n图1 利用暂元存放数字1\n\n\n此时，若同时再运行 local b = `a' + 7 和 dis `b'，显示结果会为 7，而不是 12。这主要是因为存放暂元 a 的临时性文件已经关闭，一个新的临时性文件已经打开。若要输出结果 12，那么 local a = 5、dis `a'、local b = `a' + 7 和 dis `b' 这四条命令需要同时运行。\n\n\n\n图2 利用暂元存放数字2\n\n\n当然，若要是在「命令窗口」输入 local a = 5，那么暂元 a 会一直存在，直到 Stata 关闭。\n\n\n\n图3 利用暂元存放数字3\n\n\n\n存放变量名称\n\n接下来介绍一下暂元存放文字。首先调入一份汽车价格资料 sysuse auto, clear；然后定义暂元 xx 来存放汽车价格资料中四个变量名称 local xx \"price weight mpg foreign\"；再定义同名暂元 xx，在存放原有变量基础上，增加「1978 年汽车维修次数」类别变量，即 local xx price weight mpg foreign i.rep78；最后进行 sum `xx' 和 reg `xx' 操作。具体代码如下：\nsysuse auto, clear\nlocal xx \"price weight mpg foreign\"\nlocal xx \"price weight mpg foreign i.rep78\"\nsum `xx'\nreg `xx'\n若同时运行上述代码前四行，则会执行第二个 local 定义，第一个被自动覆盖。但是，修改「变量值」只能通过 repalce 命令，而不能两次使用 generate 命令。\n\n\n\n图4 利用暂元存放变量\n\n\n很显然，若同时运行前五行，则会输出第二个 local 定义的变量的描述性统计和回归结果。实际上，在初步的回归分析中，通过定义多个同名暂元，我们可以用命令前加「*」注释的方式筛选最后要分析的暂元对象。如下：\nsysuse auto, clear\nlocal xx \"price weight mpg foreign\"\n*local xx \"price weight mpg foreign i.rep78\"\nsum `xx'\nreg `xx'\n\n变量的系数估计值\n\n变量系数的估计值也可以存储在暂元中。以「nlsw88」这份数据资料为例，进行简单回归 reg wage hours i.race。其中 i.race 为种族虚拟变量，1 为白人，2 为黑人，3为其他人种。\n\n\n\n图5 利用暂元存放系数估计值1\n\n\n然后，通过 _b[*] 形式引用系数值，如 local b0 = _b[_cons] 和 local b1 = _b[hours]，通过 _se[*] 的形式引用标准误，如 local se_b1 = _se[hours]。当然，我们也可以通过调用这些系数值去构造「估计的方程」和「生成拟合值」。具体代码如下：\nsysuse nlsw88, clear\nreg wage hours i.race\nlocal b0 = _b[_cons]      //常数项估计值\nlocal b1 = _b[hours]      //系数估计值\nlocal b2 = _b[2.race]     //虚拟变量的估计值\nlocal b3 = _b[3.race]\nlocal se_b1 = _se[hours]  //标准误\ndis \"wage = `b0' + `b1'*hours + `b2'*2.race + `b3'*3.race\"    //估计方程\ngen wage_fit = `b0' + `b1'*hours + `b2'*2.race + `b3'*3.race  //拟合值\nbr wage*  //列出以 wage 开头变量  \ndis \"SE(b1) = \" `se_b1'  //列出标注误\n\n\n\n图6 利用暂元存放系数估计值2\n\n\n\n\n2.2 暂元中的暂元\n以上介绍都是单一的暂元，在实际分析中，我们有时还需在「暂元中再包括暂元」。我们以几个例子来说明，local a1 = 2、local a2 \"var\"、local a3 = 2*`a1' 和 local a4 `a`a1''，暂元 a3 为「2 * 2 = 4」，暂元 a4 内容可以分解为 `a[`a1']' 这种形式，[ ] 里面`a1' 为 2，即暂元 a4 内容为暂元 a2 的值「var」。\nlocal a1 = 2\nlocal a2 \"var\"\nlocal a3 = 2*`a1'\nlocal a4 `a`a1''\n    \ndis  `a1'\ndis \"`a2'\"  \ndis  `a3' \ndis \"`a4'\"",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>P2. 暂元</span>"
    ]
  },
  {
    "objectID": "body/P2-暂元.html#全局暂元-global",
    "href": "body/P2-暂元.html#全局暂元-global",
    "title": "P2. 暂元",
    "section": "3 全局暂元 (global)",
    "text": "3 全局暂元 (global)\n从功能上来说，「全局暂元」和「局域暂元」类似，并且「局域暂元」使用居多。我们仍以「nlsw88」这份数据为例，以 global 命令定义全局暂元，如 global xx \"hours ttl_exp married union\"，以美元符号 $ 来引用全局暂元，如 $xx。「全局暂元」和「局域暂元」最大的不同是，无论何时定义「全局暂元」，只要 Stata 不关闭，我们都可以调用。\nsysuse nlsw88, clear\nglobal xx \"hours ttl_exp married union\"\n\nreg wage $xx\nest store homo\nreg wage $xx, robust\nest store het\nreg wage $xx i.occupation, robust\nest store het_occu\n\nlocal s \"using mytable.csv\"  //输出 Excel 文档\nlocal m \"homo het het_occu\"\nesttab `m' `s', mtitle(`m') nogap s(r2_a N) replace\n我们可以点击下图「mytable.csv」方式打开存储的回归结果。\n\n\n\n图7 暂元结果的输出1\n\n\n当然，也可以通过在 esttab 命令中去掉文件路径暂元 s，将结果输出在屏幕上。\n\n\n\n图8 暂元结果的输出2",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>P2. 暂元</span>"
    ]
  },
  {
    "objectID": "body/P2-暂元.html#相关阅读",
    "href": "body/P2-暂元.html#相关阅读",
    "title": "P2. 暂元",
    "section": "4 相关阅读",
    "text": "4 相关阅读\n\n进一步阅读\n\nhelp extended_fcn  //暂元的扩展功能\nhelp return        //返回值\nhelp ereturn \nhelp creturn",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>P2. 暂元</span>"
    ]
  },
  {
    "objectID": "body/P3-循环语句.html",
    "href": "body/P3-循环语句.html",
    "title": "P3. 循环语句",
    "section": "",
    "text": "1. while 循环语句\n实证研究中经常需要做一些重复性工作，比如分年度回归、分行业回归，等等。重复性工作最为无聊，但是也恰恰是计算机最为擅长的。本讲介绍如何用 Stata 中的循环语句来高效完成重复性工作。\n本节介绍三类循环语句，包括：条件循环、针对数字的循环和针对变量、暂元、文件的循环，涉及的 Stata 语句包括：while、forvalues 和 foreach 等。\n几乎所有的计算机语言中都包含 while 语句，其基本语法是：\n在每一轮循环中，Stata 首先判断「条件」是否满足，若满足，则执行 { 和 } 之间的语句，即执行「动作」，否则便会停止循环。\n日常生活中，我们几乎每天都在执行这条语句，比如，你是个自律的人，要求自己晚上 11 点必须上床睡觉：\n上述语句对应的场景是：晚上 10 点钟，你开始「玩手机」(动作)，每隔 10 分钟你都会看一下墙上的挂钟，看看是否到了睡觉时间 (条件)。如果没到 (条件满足)，那就继续玩 (循环继续)，直到 11 点上床睡觉 (循环结束)。\n再看一个可以用 Stata 实操的小例子,：\n具体解释如下： - 初始状态：local j=0，我们通过定义暂元 j 来设定初始值； - 判断条件：j'&lt;5** - 动作：**dis \\j’，显示暂元 j 中的内容 - 计数器：最后一条语句，让 j 的数值自动增加 1。\n下面是对以上循环的解释。首先定义暂元等于 0，也就是计数器。接下来用 while 语句定义一个条件 j&lt;5 ，从语法上讲有两个是非常重要的，左侧花括号与右侧花括号一定要配对出现，而且从写法上讲左侧花括号以后就不再写任何内容，右侧花括号另起一行，也是不再写任何内容，中间的部分就是 Stata 重复执行的命令。现在具体解读一下这几行命令。在第一轮时 j 取 0，0&lt;5，该条件为真，所以 Stata 继续执行里面的内容，执行内容里有两行，第一行是在屏幕上显示 j 的内容，显然会显示 0，接下来 j 被重新赋值为 0+1，变成 1，等到第二轮 j&lt;5，它会继续执行……等到程序完成的时候，它会显示 0,1,2,3 和 4。\n这种条件语句被广泛地用在求极大值和极小值的问题上，因为在定义极大值极小值的时候，是在两次计算出来的目标值之间比较。而在运用 Stata 写循环时候，这类循环使用相对较少。更多的是使用 forvalues 和 foreach 循环语句。",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>P3. 循环语句</span>"
    ]
  },
  {
    "objectID": "body/P3-循环语句.html#while-循环语句",
    "href": "body/P3-循环语句.html#while-循环语句",
    "title": "P3. 循环语句",
    "section": "",
    "text": "while (条件){\n   动作\n}\n\n\nclock = 22:00\nwhile clock&lt;=23:00{\n   玩手机\n   clock = clock + 10min\n}\n\n\nlocal j = 0\n    while `j'&lt;5{\n    dis  `j'\n    local j = `j'+1\n}\n\n*-结果：\n0\n1\n2\n3\n4",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>P3. 循环语句</span>"
    ]
  },
  {
    "objectID": "body/P3-循环语句.html#forvalues-循环语句",
    "href": "body/P3-循环语句.html#forvalues-循环语句",
    "title": "P3. 循环语句",
    "section": "2. forvalues 循环语句",
    "text": "2. forvalues 循环语句\n比较常用的是本节介绍的第二部分 forvalues 语句，即针对数字进行循环。以下是具体的写法。\nforvalues i = 1(2)14{\n  dis  `i'\n}\n所用的命令是 forvalues，i 是一个自动的计数器，实际上是一个等差数列，等差数列的起始值是 1，结束值是 14，公差是 2，运行结束屏幕上将显示 1,3,5,7,9,11,13，与 while 语句相比，没有给暂元赋值，原因是 forvalues 语句中（）会自动定义增加的数值。\n举一个比较实用的例子：分行业回归分析。\nsysuse nlsw88, clear\nglobal yx \"wage hours collgrad ttl_exp\"\nforvalues i = 1/4{        //公差为 1 的等差数列\n         dis _n(2) in yellow \"Occupation == \" in green `i'\n         reg $yx if occupation==`i'\n         est store m`i'\n}\nesttab m1 m2 m3 m4, nogap s(r2_a N)\n在上述命令中，对应的含义分别为：导入 Stata 系统自带数据集 nlsw88；第二行表示定义全局宏 yx 为 wage hours collgrad ttl_exp，在下面命令使用中$yx 等价于 wage hours collgrad ttl_exp；第三行设定循环语句；第四行用黄色的语句来显示“occupation 等于什么，然后再用绿色语句显示 i 的内容；第五行根据职业类别进行回归；第六行将回归结果保存；第七行是将回归结果全部呈现在屏幕。以下是屏幕上呈现的内容：\nOccupation == 1\n\n      Source |       SS           df       MS      Number of obs   =       317\n-------------+----------------------------------   F(3, 313)       =     11.90\n       Model |  1305.36065         3  435.120218   Prob &gt; F        =    0.0000\n    Residual |  11440.8581       313  36.5522624   R-squared       =    0.1024\n-------------+----------------------------------   Adj R-squared   =    0.0938\n       Total |  12746.2188       316  40.3361354   Root MSE        =    6.0458\n\n------------------------------------------------------------------------------\n        wage |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n       hours |   .0095841   .0331267     0.29   0.773    -.0555951    .0747634\n    collgrad |   2.913874     .68075     4.28   0.000      1.57445    4.253299\n     ttl_exp |   .3785845   .0905836     4.18   0.000     .2003547    .5568143\n       _cons |   3.648188    1.72804     2.11   0.036     .2481452     7.04823\n------------------------------------------------------------------------------\n\n\nOccupation == 2\n\n      Source |       SS           df       MS      Number of obs   =       263\n-------------+----------------------------------   F(3, 259)       =     10.79\n       Model |  1646.23998         3  548.746659   Prob &gt; F        =    0.0000\n    Residual |  13168.1622       259   50.842325   R-squared       =    0.1111\n-------------+----------------------------------   Adj R-squared   =    0.1008\n       Total |  14814.4022       262  56.5435197   Root MSE        =    7.1304\n\n------------------------------------------------------------------------------\n        wage |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n       hours |   .0492543   .0559042     0.88   0.379    -.0608304    .1593389\n    collgrad |   4.453559   .9807532     4.54   0.000     2.522293    6.384824\n     ttl_exp |   .3417837   .1083125     3.16   0.002     .1284984    .5550689\n       _cons |   2.785092    2.83515     0.98   0.327    -2.797788    8.367971\n------------------------------------------------------------------------------\n\n\nOccupation == 3\n\n      Source |       SS           df       MS      Number of obs   =       726\n-------------+----------------------------------   F(3, 722)       =     14.36\n       Model |  1038.09946         3  346.033155   Prob &gt; F        =    0.0000\n    Residual |  17398.2126       722  24.0972473   R-squared       =    0.0563\n-------------+----------------------------------   Adj R-squared   =    0.0524\n       Total |   18436.312       725  25.4293959   Root MSE        =    4.9089\n\n------------------------------------------------------------------------------\n        wage |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n       hours |   .0290758   .0206129     1.41   0.159    -.0113926    .0695441\n    collgrad |   1.916592   .5706926     3.36   0.001      .796177    3.037007\n     ttl_exp |   .2059178   .0408893     5.04   0.000     .1256416    .2861939\n       _cons |   3.285375   .8204117     4.00   0.000     1.674697    4.896052\n------------------------------------------------------------------------------\n\n\nOccupation == 4\n\n      Source |       SS           df       MS      Number of obs   =       102\n-------------+----------------------------------   F(3, 98)        =      4.67\n       Model |  926.231653         3  308.743884   Prob &gt; F        =    0.0043\n    Residual |  6483.74127        98  66.1606252   R-squared       =    0.1250\n-------------+----------------------------------   Adj R-squared   =    0.0982\n       Total |  7409.97292       101  73.3660685   Root MSE        =    8.1339\n\n------------------------------------------------------------------------------\n        wage |      Coef.   Std. Err.      t    P&gt;|t|     [95% Conf. Interval]\n-------------+----------------------------------------------------------------\n       hours |   .1689017   .0642062     2.63   0.010     .0414866    .2963168\n    collgrad |  -.4487836   2.110148    -0.21   0.832    -4.636304    3.738737\n     ttl_exp |   .3357523   .1782149     1.88   0.063    -.0179093    .6894139\n       _cons |  -1.035403   2.683117    -0.39   0.700    -6.359962    4.289157\n------------------------------------------------------------------------------\n\n.         esttab m1 m2 m3 m4, nogap s(r2_a N)\n\n----------------------------------------------------------------------------\n                      (1)             (2)             (3)             (4)\n                     wage            wage            wage            wage\n----------------------------------------------------------------------------\nhours             0.00958          0.0493          0.0291           0.169**\n                   (0.29)          (0.88)          (1.41)          (2.63)\ncollgrad            2.914***        4.454***        1.917***       -0.449\n                   (4.28)          (4.54)          (3.36)         (-0.21)\nttl_exp             0.379***        0.342**         0.206***        0.336\n                   (4.18)          (3.16)          (5.04)          (1.88)\n_cons               3.648*          2.785           3.285***       -1.035\n                   (2.11)          (0.98)          (4.00)         (-0.39)\n----------------------------------------------------------------------------\nr2_a               0.0938           0.101          0.0524          0.0982\nN                     317             263             726             102\n----------------------------------------------------------------------------\nt statistics in parentheses\n* p&lt;0.05, ** p&lt;0.01, *** p&lt;0.001",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>P3. 循环语句</span>"
    ]
  },
  {
    "objectID": "body/P3-循环语句.html#foreach-循环语句",
    "href": "body/P3-循环语句.html#foreach-循环语句",
    "title": "P3. 循环语句",
    "section": "3. foreach 循环语句",
    "text": "3. foreach 循环语句\n接下来第三种循环语句是 foreach 语句。forvalues 语句只能针对有规律的等差数列进行运算，有时候需要针对某一些变量或者文件名称进行循环，这时就需要 foreach 这种更一般化的循环语句，其中分为几种情形：\n\n3.1 任意格式的 foreach 语句\n任意格式的 foreach 语句，写法是 foreach v in…，v 是 Stata 自动定义的暂元。假如你想购买一辆汽车，目前你只考虑购买奥迪、奔驰、宝马 3 种品牌。你朋友发给你了 300 份这相关的文本文件「其实你只是需要 3 份关于奥迪、奔驰、宝马的信息」。如果使用 excel 打开分析，你觉得可能不像一个经济学者做的事情，于是你需要要把 3 份文本文件转化成 Stata 格式，然后进一步希望把这 3 份合并成完整的数据文件。此时 Stata 的循环语句就派上用场了。第一步，将文本文件转换为 Stata 格式的文件；第二不，将前面转换好的文件合并在同一个文档中「如果你还在选择复制粘贴，那你就 out 了」 。\n*-将 txt 文件转化为 dta 格式\nforeach file in  Audi Benz BMW{\n        insheet  using `file'.txt,clear\n        save `file'.dta, replace\n}\n上述语句场景是：拿到资料后，你开始「将文本文件导入 Stata 」(动作)，检查一下是不是你想要的关于奥迪、奔驰、宝马的资料 (条件)。如果是 (条件满足)，那就将资料导入(循环继续)，直到这 3 个文本都成功导入 (循环结束)。\n*-合并样本\nuse Audi.dta, clear\nforeach file in  Benz BMW{\n        append using `file'.dta\n}\n为了方便起见，你希望把刚刚生成的 3 个 Stata 文件合并到一起。此时需要用到的命令是append,当然，依然需要用到循环，不然全都复制粘贴，哪有空闲时间玩手机「不，是学习其他的」。上述循环也就不难理解，先导入Audi 的资料，接着判断其他的是不是你想要的 Benz 和 BMW (条件满足)，如果是 (条件满足)，那就将数据集纵向合并(循环继续)，直到全部合并介绍。\n\n\n3.2 针对变量名的 foreach 语句\n下面是第二类的 foreach 语句，foreach v of varlist…，是针对变量名进行循环。先看第一个例子，针对多个变量进行缩尾处理 （Winsorized）。在这个例子里先调入美国 1988 年美国妇女工资水平的资料，接下来把一系列变量名称都放入 vars 这个暂元里，循环的第一轮会把 wage 放在 v 这个暂元里，针对 wage 进行缩尾处理，产生的新变量是 wage_w，依次对剩下几个变量进行缩尾处理。\nsysuse nlsw88, clear\nlocal vars \"wage hours ttl_exp grade\"\nforeach v of varlist `vars'{\n       winsor `v' , gen(`v'_w) p(0.01)\n}\n当然，连老师以前也编写过可以一次性处理多个变量的命令 winsor2，具体可以：\nhelp winsor2   //便捷的命令\n\n\n3.3 暂元循环\n第三类的 foreach 语句是暂元循环，foreach cc of local…，这里的 vars 并没有用暂元的方式，与第二类主要的区别是，这一类 local 后只需要暂元的名称，可以发现，关于第二类和第三类完全根据自己的喜好来决定。具体可以对比 3.2 节和 3.3 节内容。\nsysuse auto,clear\nlocal vars \"price weight length\"\nforeach v of local vars{\n       gen `v'_2 = `v'^2\n}",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>P3. 循环语句</span>"
    ]
  },
  {
    "objectID": "body/P4-ado文档-定义自己的程序.html",
    "href": "body/P4-ado文档-定义自己的程序.html",
    "title": "P4. ado 文档：定义自己的程序",
    "section": "",
    "text": "P4.1 Stata 程序的基本架构\n在 Stata 中使用的每一个命令的背后，都对应着一个ado文档。因此我们完全可以自己编写ado文件，相当于自行定义自己的程序。\n首先，我们定义了一个非常简单的程序（共4行），实质内容只有 display “I Iove This Game!” 这一行，即在屏幕上显示一句话。\n第一行命令指明：将要定义一个程序，并定义了一个程序的名称（myprog)，结尾 end，中间是程序的实质性过程。\n在上方，我们还定义了 version。定义 version 的好处是，无论之后 Stata 更新到什么版本，当时在12.0版本下的语法定义的内容依然可以兼容。\n并且，程序的名称必须由英文字母和数字构成，且不能和已有的命令冲突。",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>P4. ado 文档：定义自己的程序</span>"
    ]
  },
  {
    "objectID": "body/P4-ado文档-定义自己的程序.html#p4.1-stata-程序的基本架构",
    "href": "body/P4-ado文档-定义自己的程序.html#p4.1-stata-程序的基本架构",
    "title": "P4. ado 文档：定义自己的程序",
    "section": "",
    "text": "program define myprog\n     version 12.0\n        display \"I Iove This Game!\"\n     end",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>P4. ado 文档：定义自己的程序</span>"
    ]
  },
  {
    "objectID": "body/P4-ado文档-定义自己的程序.html#p4.2-程序的执行",
    "href": "body/P4-ado文档-定义自己的程序.html#p4.2-程序的执行",
    "title": "P4. ado 文档：定义自己的程序",
    "section": "P4.2 程序的执行",
    "text": "P4.2 程序的执行\n对于定义的程序，有两种执行方式。\n\n第一种执行方式：ado 文档执行方式\n把刚才定义的这一段命令或程序保存在一个文档中，建立一个空白的do文件。保存时有两点需要特别注意：\n\n保存的文件名称必须和程序完全一致，所以通常复制程序名称进行保存，可以保存文件在任意位置。\n文件的保存类型默认的是.do，但是不符合保存程序的要求，需要点开下拉菜单，选择 ado，进行保存，即保存为 myprog.ado (文件的扩展名为 `.ado’)。另外，程序的名称不能与现有命令名称冲突\n\n保存后，我们就可以关闭do文件了，这时候 Stata 就新增了myprog这个命令，在屏幕上输入该命令即可进行执行。\n能够成功运行的前提是之前已经执行了adopath+这条命令（见下方），即把刚才的存放路径通过adopath+命令添加到了Stata 能够执行的目录。\n    myprog\n    adopath + \"D:\\stata12\\ado\\personal\\LY_stata\\_plus\"\n    myprog\n执行这条命令后，屏幕上会显示多条路径，每执行一条命令的时候，Stata 会依次在这些路径中寻找一个名称为 myprog 后缀为.ado的文件，一旦找到，就会执行这个程序内的所有内容。Stata 在这些路径以外的地方，并不会进行查询，以提升运行速度。\n有以下建议供参考：\n\n把自己编写的程序统一存放于 ._Myado 下；\n并在 profile.do 文件中定义如下 stata     adopath + D:\\stata11\\ado\\personal\\_Myado\n该文件夹下可进一步设定 a-z 等子文件夹，尤其是如果平时自行设定的命令较多\n存放相应字母开头的文件\n对于临时的 ado 文档，可以采用 adopath +命令定义存放地址\n对于需要经常执行的命令，采用这种方式很好，与 Stata 官方命令完全相同。\n\n\n\n第二种执行方式：run\n\nStep 1: 将程序内容读入内存 具体方法：选中, 点击`Execute Quietly(run)’键 （快捷键：Ctrl+R）\nStep 2：执行程序（方式同前，快捷键：Ctrl+D）\n  program define mynike\n    version 12.0\n    dis in red \"Just do it! \"\n  end  \n\n  mynike",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>P4. ado 文档：定义自己的程序</span>"
    ]
  },
  {
    "objectID": "body/P4-ado文档-定义自己的程序.html#p4.3-程序的管理",
    "href": "body/P4-ado文档-定义自己的程序.html#p4.3-程序的管理",
    "title": "P4. ado 文档：定义自己的程序",
    "section": "P4.3 程序的管理",
    "text": "P4.3 程序的管理\n如果想要编辑已经存在的程序，如编辑刚才定义好的 myprog.ado，可以使用adoedit命令。正如doedit可以编辑do文件。\nadoedit myprog.ado   // 修改和编辑程序\nadoedit winsor2.ado\n注意程序的名称一定要和ado文件相一致。\n如果想要修改已经存在内存中的程序，首先要进行program drop ， 这时只是删除内存中调入的程序，但不影响硬盘中存储的文件 。\n之后运行再mynike，会显示错误信息，因为程序已不在内存中。\nprogram drop mynike   \nmynike              \n修改程序后，必须重新读入内存才能使新代码生效。\nprogram define mynike\n    version 12.0\n    dis in red \"Just do it! haha\"\nend  \nmynike\n我们可以在定义程序前，可以加一个capture program drop。 如此一来，无论第一次执行还是反复执行，都不会报错。\n    capture program drop mynike        // 新增语句\n    program define mynike\n      version 8.0\n      dis in red \"Just do it! ha   ha! \"  // 请修改后执行\n    end  \n          \n    mynike",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>P4. ado 文档：定义自己的程序</span>"
    ]
  },
  {
    "objectID": "body/P4-ado文档-定义自己的程序.html#p4.4-避免列印过多的结果",
    "href": "body/P4-ado文档-定义自己的程序.html#p4.4-避免列印过多的结果",
    "title": "P4. ado 文档：定义自己的程序",
    "section": "P4.4 避免列印过多的结果",
    "text": "P4.4 避免列印过多的结果\n接下来将一些定义程序时的小技巧。\n首先，避免打印过多的结果。通常在执行一个程序的时候，总有很多中间计算结果，需要借助 Stata 现有的命令进行中间结果的计算。可以用 quietly 命令实现“悄悄计算”的结果，所有中间计算的统计量都会存储在内存中。\n比如调入汽车价格，通过sum统计 price 的平均值，以 r(mean) 的单值形式存储了均值，并定义为 avg进行存储。如果有多行命令需要静悄悄执行，可以用花括号”{}“来隐藏中间一系列代码的执行效果，仅呈现最终所需的价格差（diff）。\nsysuse auto, clear\n  quietly sum price, meanonly   // 静悄悄地做，单行\n  scalar avg = r(mean)\n  dis avg\n\n  qui{                          // 静悄悄地做，整段\n     sum price if foreign == 0\n     scalar avg1 = r(mean)\n     sum price if foreign == 1\n     scalar avg2 = r(mean)\n     scalar diff = avg2 - avg1\n  }\n  dis diff",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>P4. ado 文档：定义自己的程序</span>"
    ]
  },
  {
    "objectID": "body/P4-ado文档-定义自己的程序.html#p4.5-避免数据在程序执行过后有所变动",
    "href": "body/P4-ado文档-定义自己的程序.html#p4.5-避免数据在程序执行过后有所变动",
    "title": "P4. ado 文档：定义自己的程序",
    "section": "P4.5 避免数据在程序执行过后有所变动",
    "text": "P4.5 避免数据在程序执行过后有所变动\n通常用户使用我们定义的程序，主要目的有两个：\n\n做基本统计分析，配合制作图形。\n进行回归分析。\n多数情况下，我们不希望用户更改数据，除非生成新变量或剔除缺漏值/离群值等，可以使用preserve 和 restore 配合使用。\npreserve执行时，Stata 会把当前的数据进行备份并存在内存的某个位置上，接下来可以执行删除 的动作，再去做基本统计分析，或存一份更改后的数据等。但是一旦执行restore,就会回到preserve时的数据状态，不会产生影响。\n\n  sysuse auto, clear\n    preserve                      // 备份当前状态 s1\n      keep price weight foreign\n      drop if price &gt; 10000\n      sum \n      save auto_new.dta, replace\n    restore                       // 恢复到状态 s1\n  sum  \n\n  use auto_new.dta,clear\n以下为注意事项：\n\n多数情况下，我们改动资料都是为了得到特定的结果；\n在 preserve和 restore 之间对资料进行的任何修改都无法保留；\npreserve 和 restore 不可“嵌套”使用，即只能使用一次，这是先天的缺陷。\nStata 11 及之后，提供了新的命令——snapshot，“嵌套”功能，”快照“功能，可以嵌套一千次。\n\n*-Also See                         | 主页: lianxh.cn |\n\n  help program   //程序相关命令菜单\n  \n  help capture   //避免程序因小错误而中断\n  \n  help syntax    //输入项的语法格式\n  \n  help simulate  //Monte Carlo Simulation",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>P4. ado 文档：定义自己的程序</span>"
    ]
  },
  {
    "objectID": "body/P5_随机抽样.html",
    "href": "body/P5_随机抽样.html",
    "title": "P5. 随机抽样",
    "section": "",
    "text": "1. 无放回抽样\n本讲主要介绍两种随机抽样方法：无放回抽样和有放回抽样。\n在 Stata 中，通过 sample 命令实现无放回抽样。\n通过以上命令，我们可以得到一列 1 到 10 的整数，如下图所示。",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>P5. 随机抽样</span>"
    ]
  },
  {
    "objectID": "body/P5_随机抽样.html#无放回抽样",
    "href": "body/P5_随机抽样.html#无放回抽样",
    "title": "P5. 随机抽样",
    "section": "",
    "text": "数据产生过程\n\n    clear\n    set obs 10\n    gen x = _n\n    save P4_data1.dta, replace\n\n        x\n  1.    1\n  2.    2\n  3.    3\n  4.    4\n  5.    5\n  6.    6\n  7.    7\n  8.    8\n  9.    9\n 10.   10\n\n1.1 按比例抽取\n-抽取 30% 的观察值\n    use P4_data1, clear\n    browse\n    sample 30\n通过以上命令，可以得到 3 个观察值，例如：\n       x\n  1.   4\n  2.   7\n  3.   3\n如果对这三行命令重复多次，得到的结果有所差别，这也是所谓“随机”抽样的含义。在 Stata 内部，通过人为设定的随机数发生器来实现随机抽样，所以这样的“随机”抽样虽然名义上是“随机”抽样，但实质上是伪随机的，其中存在一个函数的发生器。\n\n\n1.2 按计数抽取\n-随机抽取 5 个观察值\n    use P4_data1, clear\n    sample 5, count\n    browse\n通过以上命令，可以得到 5 个观察值，例如：\n       x\n  1.   7\n  2.   3\n  3.   4\n  4.   2\n  5.   9\n同样的，重复多次，得到的结果也是“随机”的。\n\n\n1.3 分组抽样 (sampling for each group)\n分组抽样是更为复杂的抽样，我们可以在每一个组里依次去抽取一定量的观察值。\n-范例 1\n基于 Stata 中自带的“P4_xtdata.dta”面板数据，如下图所示。\n      id   year     x\n  1.    1   2001    .1\n  2.    1   2002    .2\n  3.    1   2003    .3\n  4.    1   2004    .4\n  5.    2   2001    .5\n  6.    2   2002    .6\n  7.    2   2003    .7\n  8.    2   2004    .8\n  9.    3   2001    .9\n 10.    3   2002     1\n 11.    3   2003   1.1\n 12.    3   2004   1.2\n 13.    4   2001   1.3\n 14.    4   2002   1.4\n 15.    4   2003   1.5\n 16.    4   2004   1.6\n 17.    5   2001   1.7\n 18.    5   2002   1.8\n 19.    5   2003   1.9\n 20.    5   2004     2\n这份数据一共有 3 个变量，分别为“id”，“year”，“x”，下表介绍了其具体含义：\n\n\n\n变量名\n说明\n\n\n\n\nid\n公司代码\n\n\nyear\n年份\n\n\nx\n研究关注的某个连续变量\n\n\n\n使用如下代码：\n    use P4_xtdata, clear\n    browse\n    sample 50, by(id)\n    xtset id year\n每家公司 4 年的资料我们随机抽取两年（50%）， xtset 将其示例成 Panel Data，相当于分别对 id 和 year 逐个进行排序。\n抽样结果例如下图所示：\n       id   year     x\n  1.    1   2002    .2\n  2.    1   2004    .4\n  3.    2   2003    .7\n  4.    2   2004    .8\n  5.    3   2002     1\n  6.    3   2004   1.2\n  7.    4   2003   1.5\n  8.    4   2004   1.6\n  9.    5   2002   1.8\n 10.    5   2003   1.9\n如上图，第 1 家公司被抽中 02 和 04 年的观察值，而第二家公司被抽中 03 和 04 年的观察值。\n-范例 2\n基于 88 年妇女工资资料数据“nlsw88.dta”。\n    sysuse nlsw88, clear\n    des, short\n    sample 50, by(race)\n    des, short\n使用des, short选项可以在屏幕上列示出数据的基本状况，如下所示，一共包含了 2246 个观察值。\n Contains data from C:\\Program Files\\Stata16\\ado\\base/n/nlsw88.dta\n obs:         2,246                          NLSW, 1988 extract\n vars:            17                          1 May 2018 22:52\n Sorted by: idcode\n从这份数据中按照种族，每个种族内部分别抽取 50%的观察值，再次利用des, short命令可以查看抽样结果，如下所示，剩下 1124 个观察值，基本接近一半。\n Contains data from C:\\Program Files\\Stata16\\ado\\base/n/nlsw88.dta\n obs:         1,124                          NLSW, 1988 extract\n vars:            17                          1 May 2018 22:52\n Sorted by: race\n\n\n1.3 分块抽样 (sampling blocks)\n同样使用“P4_xtdata.dta”面板数据。这里需要介绍一个外部命令 gsample ，即一般化的 sample。\n-按计数抽取\n   help gsample  //外部命令\n   use P4_xtdata, clear\n   browse\n   gsample 3, cluster(id) wor          //随机抽取三家公司\n附加选项 cluster(id) 表示以公司为单位进行抽取，而不是以行（观察值）为单位进行抽取。 附加选项 wor 表示不可重复的抽样，也就是不放回抽样。抽样结果如下图所示：\n       id   year     x\n  1.    4   2001   1.3\n  2.    4   2002   1.4\n  3.    4   2003   1.5\n  4.    4   2004   1.6\n  5.    2   2001    .5\n  6.    2   2002    .6\n  7.    2   2003    .7\n  8.    2   2004    .8\n  9.    1   2001    .1\n 10.    1   2002    .2\n 11.    1   2003    .3\n 12.    1   2004    .4\n-按比例抽取\n use P4_xtdata, clear\n browse\n gsample 40, cluster(id) wor percent //随机抽取 60% 的公司",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>P5. 随机抽样</span>"
    ]
  },
  {
    "objectID": "body/P5_随机抽样.html#有放回抽样",
    "href": "body/P5_随机抽样.html#有放回抽样",
    "title": "P5. 随机抽样",
    "section": "2. 有放回抽样",
    "text": "2. 有放回抽样\n在 Stata 中，通过 bsample 命令来实现有放回抽样，’b’是 bootstrap（自抽样）的简写。\n-范例 1: 截面数据\n同样使用 1 到 10 的 10 个整数作为总体，代码如下：\n use P4_data1.dta, clear\n browse\n bsample\n sort x\n抽样结果如下图所示，其中命令 sort 表示对观察值进行排序，观察值 4 被抽取了四次，6 被抽取了两次。\n        x\n  1.    2\n  2.    4\n  3.    4\n  4.    4\n  5.    4\n  6.    6\n  7.    6\n  8.    8\n  9.    9\n 10.   10\n-范例 2: 面板数据\n面板数据同样可以进行有放回的抽样，设置选项 cluster(id) 表示抽样是以公司为单位进行的，或者理解为每次抽取的是公司的编号而不是行（观察值），代码如下：\n use P4_xtdata, clear\n browse\n\n bsample, cluster(id) idcluster(idnew)\n xtset idnew year\n附加选项 idcluster(idnew) 重新确定了抽样样本出现的先后顺序，如下图所示：\n  1.    1   2001    .1       1\n  2.    1   2002    .2       1\n  3.    1   2003    .3       1\n  4.    1   2004    .4       1\n  5.    1   2001    .1       2\n  6.    1   2002    .2       2\n  7.    1   2003    .3       2\n  8.    1   2004    .4       2\n  9.    1   2001    .1       3\n 10.    1   2002    .2       3\n 11.    1   2003    .3       3\n 12.    1   2004    .4       3\n 13.    3   2001    .9       4\n 14.    3   2002     1       4\n 15.    3   2003   1.1       4\n 16.    3   2004   1.2       4\n 17.    4   2001   1.3       5\n 18.    4   2002   1.4       5\n 19.    4   2003   1.5       5\n 20.    4   2004   1.6       5\nid 为 1 的公司被抽取了 3 次，分别被 idnew 标记为 1、2、3，如果多次重复运行代码，抽取的结果会发生变化。\n近年中，bootstrap 方法的应用非常广泛。在 Stata 学术论文专题中介绍的面板门限模型中，主要是运用 bootstrap 来进行假设检验。\n\nNote: gsample 可以完全替代 bsample 的功能，且有扩展。\n\n-应用：bootstrap 标准误\n可重复的抽样主要应用在 bootstrap 中，我们可以使用 bootstrap 去获取系数的标准误。在 Stata 中做线性回归，想要采用 bootstrap 去获得标准误，只需要在前面附加前缀bootstrap, reps(300):,代表我们进行 300 次可重复抽样，每一次可重复抽样的样本称为经验样本，用经验样本可以估计出变量的系数。 示例代码如下：\n sysuse auto, clear\n bootstrap, reps(300):  ///\n     reg price weight mpg foreign, noheader\n对于 300 次重复抽样的系数，比如 weight 变量，我们可以计算出一个标准差，它可以作为 weight 变量对应系数的标准误。\n-等价写法:\n reg price weight mpg foreign,  ///\n     vce(bootstrap, reps(300) seed(1357))\n等价写法是把 bootstrap 参数写在 vce() 选项中。\n\nNotes：\n\n\n\n90% 以上的 Stata 命令都支持 vce(bootstrap) 选项。\n\n\n本部分的详细介绍见 R7_robustSE.do",
    "crumbs": [
      "程序初步",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>P5. 随机抽样</span>"
    ]
  },
  {
    "objectID": "body/R1-OLS简介.html",
    "href": "body/R1-OLS简介.html",
    "title": "R1. OLS简介",
    "section": "",
    "text": "1. 基本假设\n在探究解释变量 x 与被解释变量 y 之间的关系时，最经常使用的是简单线性回归模型：\n\\[\ny=\\beta_0+\\beta_1 x+u\n\\] 其中，\\(\\beta_1\\)代表斜率，\\(\\beta_0\\)代表截距，\\(u\\)代表误差项。\n在估计方程斜率和截距大小时，普通最小二乘法 (Ordinary Least Square, OLS) 是被运用最多的参数估计方法，其中斜率的计算公式为 \\[\n\\hat{\\beta}_1=\\frac{\\sum_{i=1}^n(x_i-\\bar{x})(y_i-\\bar{x})}{\\sum_{i=1}^n(x_i-\\bar{x})^2}\n\\] 截距计算公式为 \\[\n\\hat{\\beta}_0=\\bar{y}-\\hat{\\beta}_1\\bar{x}\n\\] OLS在判断拟合值和观测值接近程度的标准是残差平方和 (sum of squared residuals, SSR) \\[\n\\sum_{i=1}^n \\hat{u}_i^2=\\sum_{i=1}^n (y_i-\\hat{\\beta}_0-\\hat{\\beta}_1x_i)^2\n\\] 尽可能地小。\n在利用OLS对变量x和变量y的关系进行估计时，使用的数据首先应该满足以下假设：",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>R1. OLS简介</span>"
    ]
  },
  {
    "objectID": "body/R1-OLS简介.html#基本假设",
    "href": "body/R1-OLS简介.html#基本假设",
    "title": "R1. OLS简介",
    "section": "",
    "text": "1.1 线性于参数\n在总体模型中，因变量y与自变量x和误差u应满足如下关系： \\[\ny=\\beta_0+\\beta_1 x+u\n\\] 其中，\\(\\beta_0\\) 和 \\(\\beta_1\\)分别表示总体的截距和斜率。\n\n\n1.2 非完全多重共线性\nX 是满秩的，i.e. \\(rank(X) = k\\)\n\n\n1.3 零条件均值\n给定变量x的任何值，误差的期望值都为零，也即\\(E(u|x)=0\\)\n\n\n1.4 弱外生性\n变量x的观测值与真实值相比是没有误差的\n\n\n1.5 同方差\n给定变量x的任何值，误差都有相同的方差，也即\\(Var(u|x)=\\sigma^2\\)",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>R1. OLS简介</span>"
    ]
  },
  {
    "objectID": "body/R1-OLS简介.html#结果解释",
    "href": "body/R1-OLS简介.html#结果解释",
    "title": "R1. OLS简介",
    "section": "2. 结果解释",
    "text": "2. 结果解释\n\n2.1 系数估计值\n系数度量的是自变量x与因变量y之间存在关系的强弱，表示的是当自变量x变化一个单位时，因变量y随之变化多少；\n在 Stata 中，可通过命令 reg y x 得出相应结果。\n\n\n2.2 标准误与t值\n系数标准误度量的是系数的不确定性程度，为了检验自变量x与因变量y是否存在联系还需要进行t检验。t检验的原假设H0是系数等于0（自变量x与因变量y之间不存在联系），当t统计量大于相应显著性水平和自由度下的t值时，我们就可以说在该显著性水平上，自变量x与因变量y是否存在联系。\nt统计量的计算公式为 \\[\nt=\\frac{\\hat{\\beta}_1}{se}\n\\] 在 Stata 中，可通过命令dis \"t-value = \" %4.2f _b[weight]/_se[weight]得出相应结果。\n\n\n2.3 拟和值与残差\n拟和值是指给定自变量x的某一特定值，根据斜率估计值\\(\\beta_1\\)和截距估计值\\(\\beta_0\\)计算出的因变量拟和值\\(\\hat{y}\\)；\n残差是因变量观测值与估计值时间的差值。\n在 Stata 中，可通过自动计算和手动计算两种方式得出，具体代码如下：\n    regress price weight\n    \n    predict price_fit, xb  // 拟合值, xb 选项可以省略,默认\n    gen price_fit2 = _b[_cons] + _b[weight]*weight //手动计算\n    \n    predict e, residual    // 残差, residual 选项是必须的, 可以简写为 r\n    gen e2 = price - price_fit //手动计算\n    \n    br price weight price_* e*\n\n\n2.4 拟合优度\n拟合优度度量的是自变量x多好地解释了因变量y，计算公式为 \\[\nR^2=\\frac{MSS}{TSS}\n\\] 其中，\\(TSS=\\sum_{i=1}^n(y_i-\\bar{y}\\)代表因变量y总的波动；\n\\(MSS=\\sum_{i=1}^n(\\hat{y_i}-\\bar{y}\\)代表模型度量的因变量y的波动。\n\n\n\n2.5 多个自变量与拟合优度\n情况1: \\(X_1\\)与\\(X_2\\)对因变量y的解释部分不重合，单独放入\\(X_1\\)时系数显著；继续加入\\(X_2\\)时，\\(X_1\\)和\\(X_2\\)的系数依然显著，同时拟合优度增加。\n\n情况2: \\(X_1\\)与\\(X_2\\)对因变量y的解释部分重合，单独放入\\(X_1\\)时系数显著；继续加入\\(X_2\\)时，\\(X_1\\)的系数不再显著。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>R1. OLS简介</span>"
    ]
  },
  {
    "objectID": "body/R1-OLS简介.html#参考文献",
    "href": "body/R1-OLS简介.html#参考文献",
    "title": "R1. OLS简介",
    "section": "参考文献",
    "text": "参考文献\n\n伍德里奇. 计量经济学导论: 现代观点. 清华大学出版社, 2014.\n维基百科：http://en.wikipedia.org/wiki/Ordinary_least_squares",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>R1. OLS简介</span>"
    ]
  },
  {
    "objectID": "body/R2-相关系数矩阵.html",
    "href": "body/R2-相关系数矩阵.html",
    "title": "R2. 相关系数矩阵",
    "section": "",
    "text": "1. 相关矩阵散点图\n在线性回归分析时，我们呈现相关系数矩阵有两个主要目的：其一是呈现变量之间的相关性；其二是线性回归要求解释变量之间不存在严重的多重共线性问题，运用相关系数矩阵可以对此进行初步判断。\n我们可以借助相关矩阵散点图初步判断变量之间的相关性，在 Stata 中，我们可以使用 graph matrix 命令作相关矩阵散点图。\n如下图所示，相关矩阵散点图非常直观地呈现出了变量之间的相关性，我们可以通过交点判断每幅图呈现的是哪两个变量之间的相关性。例如下图中红色框内图形所示，该图表示的是 weight 与 length 之间的散点图，我们可以看到二者存在较强的相关性，因为散点基本位于一条直线上。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R2. 相关系数矩阵</span>"
    ]
  },
  {
    "objectID": "body/R2-相关系数矩阵.html#相关矩阵散点图",
    "href": "body/R2-相关系数矩阵.html#相关矩阵散点图",
    "title": "R2. 相关系数矩阵",
    "section": "",
    "text": "help graph matrix\nsysuse auto, clear\ngraph matrix price weight length mpg\n\n\n\n\n图1 相关矩阵散点图",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R2. 相关系数矩阵</span>"
    ]
  },
  {
    "objectID": "body/R2-相关系数矩阵.html#pearson-相关系数",
    "href": "body/R2-相关系数矩阵.html#pearson-相关系数",
    "title": "R2. 相关系数矩阵",
    "section": "2. Pearson 相关系数",
    "text": "2. Pearson 相关系数\n为了验证这种猜想，我们可以使用 Stata 提供的correlate(可简写为corr)命令计算 pearson 相关系数。\nhelp corr\ncorr weight length\n如下结果显示：weight 与 length 之间的相关性达到 0.946，与上所述散点图较强相关性的结果一致。\n* Pearson 相关系数结果\ncorr weight length\n(obs=74)\n\n             |   weight   length\n-------------+------------------\n      weight |   1.0000\n      length |   0.9460   1.0000\n此外，我们还可以使用 Stata 官方命令 pwcorr 进行分析。\nhelp pwcorr   //pearson correlation\n如下结果所示，该方法存在两个缺陷: (1) 小数点后保留了四位; (2) 没有标注显著性水平。这些都不太符合我们在论文中呈现结果的要求或期刊对结果呈现的要求。\n\nsig选项\n\n我们可以通过 Stata 提供的选项 sig 进行改进，如下结果所示，grade 与 age 的相关系数为 -0.0330 , 对应的 p 值为 0.1182 ，即二者的相关系数在统计上不显著。但这也不太符合论文中呈现结果的要求，我们还需根据p值将显著性水平转换成相应的星号(*)。\n\nstar选项\n\n为了加星号(*)，我们可以通过 Stata 提供的选项 star 进一步改进，如下结果所示，加了星号后看起来简洁很多，但小数位仍保留了四位，不太符合我们对呈现结果的要求，并且当变量较多时手动整理相关系数矩阵的小数位数不太方便。\n. sysuse nlsw88, clear\n\n*-stata 官方命令\n. global x \"age grade wage hours ttl_exp tenure\"\n\n. pwcorr $x  \n//缺陷: (1)小数点后两位为宜; (2)没有标注显著水平;\n\n         |      age    grade     wage    hours  ttl_exp   tenure\n---------+------------------------------------------------------\n     age |   1.0000 \n   grade |  -0.0330   1.0000 \n    wage |  -0.0362   0.3254   1.0000 \n   hours |  -0.0279   0.0871   0.1591   1.0000 \n ttl_exp |   0.1243   0.1982   0.2655   0.2295   1.0000 \n  tenure |   0.0737   0.1228   0.1777   0.1608   0.5766   1.0000 \n\n. pwcorr $x, sig   //局限：整理起来很麻烦\n\n         |      age    grade     wage    hours  ttl_exp   tenure\n---------+------------------------------------------------------\n     age |   1.0000 \n   grade |  -0.0330   1.0000 \n         |   0.1182\n         |\n    wage |  -0.0362   0.3254   1.0000 \n         |   0.0866   0.0000\n         |\n   hours |  -0.0279   0.0871   0.1591   1.0000 \n         |   0.1874   0.0000   0.0000\n         |\n ttl_exp |   0.1243   0.1982   0.2655   0.2295   1.0000 \n         |   0.0000   0.0000   0.0000   0.0000\n         |\n  tenure |   0.0737   0.1228   0.1777   0.1608   0.5766   1.0000 \n         |   0.0005   0.0000   0.0000   0.0000   0.0000\n         |\n\n.     pwcorr $x, star(0.05) //小数点后两位不易调整;\n\n         |      age    grade     wage    hours  ttl_exp   tenure\n---------+------------------------------------------------------\n     age |   1.0000 \n   grade |  -0.0330   1.0000 \n    wage |  -0.0362   0.3254*  1.0000 \n   hours |  -0.0279   0.0871*  0.1591*  1.0000 \n ttl_exp |   0.1243*  0.1982*  0.2655*  0.2295*  1.0000 \n  tenure |   0.0737*  0.1228*  0.1777*  0.1608*  0.5766*  1.0000 \n通过使用自编命令pwcorr_a、pwcorr_c可以很好地解决上述问题，结果如下所示：\n*-自编命令 (by 连玉君)\n. pwcorr_a $x, format(%7.3f)\n\n         |  age         grade      wage       hours      ttl_exp  tenure  \n---------+----------------------------------------------------------------\n   age   |   1.000   \n  grade  |  -0.033      1.000   \n   wage  |  -0.036*     0.325***   1.000   \n  hours  |  -0.028      0.087***   0.159***   1.000   \n ttl_exp |   0.124***   0.198***   0.265***   0.230***   1.000   \n  tenure |   0.074***   0.123***   0.178***   0.161***   0.577***   1.000   \n\n. pwcorr_c $x, star(0.05) format(%7.2f) //比较符合多数期刊的要求\n\n         |      age    grade     wage    hours  ttl_exp   tenure\n---------+------------------------------------------------------\n     age |     1.00 \n   grade |    -0.03     1.00 \n    wage |    -0.04     0.33*    1.00 \n   hours |    -0.03     0.09*    0.16*    1.00 \n ttl_exp |     0.12*    0.20*    0.27*    0.23*    1.00 \n  tenure |     0.07*    0.12*    0.18*    0.16*    0.58*    1.00",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R2. 相关系数矩阵</span>"
    ]
  },
  {
    "objectID": "body/R2-相关系数矩阵.html#spearman-相关系数",
    "href": "body/R2-相关系数矩阵.html#spearman-相关系数",
    "title": "R2. 相关系数矩阵",
    "section": "3. Spearman 相关系数",
    "text": "3. Spearman 相关系数\n我们可以通过 Stata 提供的命令 spearman 呈现 Spearman 相关系数，语法与 person 命令完全一致。\n. help spearman //Spearman correlation \n\n. spearman $x, star(0.05)\n(obs=2225)\n\n         |      age    grade     wage    hours  ttl_exp   tenure\n---------+------------------------------------------------------\n     age |   1.0000 \n   grade |  -0.0319   1.0000 \n    wage |  -0.0120   0.4533*  1.0000 \n   hours |  -0.0373   0.1120*  0.2367*  1.0000 \n ttl_exp |   0.1326*  0.1935*  0.4141*  0.2300*  1.0000 \n  tenure |   0.0433*  0.1184*  0.3663*  0.1721*  0.5332*  1.0000  \n\n. help pwcorrs  //外部命令，结合了上述两个命令",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R2. 相关系数矩阵</span>"
    ]
  },
  {
    "objectID": "body/R2-相关系数矩阵.html#spearman-和-pearson-相关系数矩阵的合并呈现",
    "href": "body/R2-相关系数矩阵.html#spearman-和-pearson-相关系数矩阵的合并呈现",
    "title": "R2. 相关系数矩阵",
    "section": "4. Spearman 和 Pearson 相关系数矩阵的合并呈现",
    "text": "4. Spearman 和 Pearson 相关系数矩阵的合并呈现\n发表论文时，有些期刊会要求将 Spearman 和 Pearson 相关系数矩阵以上三角和下三角的形式合并呈现。为此，我们可以使用外部命令 corsp 实现。\nhelp corsp\ncorsp $x, format(%7.3f)\ncorsp $x, format(%7.3f) pvalue\nStata 结果如下所示：\n.   corsp $x, format(%7.3f)\n\nPearson/Spearman correlation matrix\n\n\n             |     age    grade     wage    hours  ttl_exp   tenure \n-------------+------------------------------------------------------\n         age |   1.000   -0.032   -0.012   -0.037    0.133    0.043 \n       grade |  -0.034    1.000    0.453    0.112    0.194    0.118 \n        wage |  -0.036    0.326    1.000    0.237    0.414    0.366 \n       hours |  -0.026    0.089    0.159    1.000    0.230    0.172 \n     ttl_exp |   0.123    0.196    0.263    0.229    1.000    0.533 \n      tenure |   0.073    0.121    0.178    0.161    0.576    1.000 \n\n.   corsp $x, format(%7.3f) pvalue\n\nPearson/Spearman correlation matrix\n\n\n             |     age    grade     wage    hours  ttl exp   tenure \n-------------+------------------------------------------------------\n         age |   1.000   -0.032   -0.012   -0.037    0.133    0.043 \n             |   0.000    0.133    0.570    0.079    0.000    0.041 \n             |                                                      \n       grade |  -0.034    1.000    0.453    0.112    0.194    0.118 \n             |   0.106    0.000    0.000    0.000    0.000    0.000 \n             |                                                      \n        wage |  -0.036    0.326    1.000    0.237    0.414    0.366 \n             |   0.088    0.000    0.000    0.000    0.000    0.000 \n             |                                                      \n       hours |  -0.026    0.089    0.159    1.000    0.230    0.172 \n             |   0.224    0.000    0.000    0.000    0.000    0.000 \n             |                                                      \n     ttl exp |   0.123    0.196    0.263    0.229    1.000    0.533 \n             |   0.000    0.000    0.000    0.000    0.000    0.000 \n             |                                                      \n      tenure |   0.073    0.121    0.178    0.161    0.576    1.000 \n             |   0.001    0.000    0.000    0.000    0.000    0.000 \n             |   \n\nNote:\n\n\nPearson 相关系数, 下三角\n\n\nSpearman相关系数, 上三角\n\n\n可以根据 p-value 自行添加星号, 标注显著水平\n\n\nNote: 二者的区别\n\n\n连续变量, 正态分布, 线性关系。二者均可, Pearson 相关系数较好\n\n\n上述任一条件不满足，用 spearman 相关系数，不能用 Pearson 相关系数\n\n\n扩展阅读\n\n连享会：结果输出专题 view browse “https://www.lianxh.cn/blogs/22.html”",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>R2. 相关系数矩阵</span>"
    ]
  },
  {
    "objectID": "body/R3-基本统计量的呈现.html",
    "href": "body/R3-基本统计量的呈现.html",
    "title": "R3. 基本统计量的呈现",
    "section": "",
    "text": "1. 简介\n我们在看论文的时候，常常在第一张表呈现基本统计量，便于读者了解我们使用的数据形态，也可以用于判断样本中是否包含严重的离群值。本文介绍几个快捷的命令以呈现基本统计量。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>R3. 基本统计量的呈现</span>"
    ]
  },
  {
    "objectID": "body/R3-基本统计量的呈现.html#stata-官方命令-sum-和-tabstat",
    "href": "body/R3-基本统计量的呈现.html#stata-官方命令-sum-和-tabstat",
    "title": "R3. 基本统计量的呈现",
    "section": "2. Stata 官方命令: sum 和 tabstat",
    "text": "2. Stata 官方命令: sum 和 tabstat\n\n2.1 summarize 命令\n首先调入 Stata 官方的妇女工资的数据，执行 summarize 命令（简写为 sum），所有变量的基本统计量都将被列示。\nsysuse nlsw88.dta, clear\nsum               //粗看\nsum wage, detail  //查看分布和离群值\n执行 sum 命令后汇报的基本统计量共有 5 列，分别为观测值个数、平均值、标准差、最小值和最大值。通过观察最大值 (Max)、最小值 (Min)，可以判断数据是否有离群值；通过观察标准差 (Std. Dev.)，可以判断数据的离散情况；通过观察观测值个数 (Obs)，可以判断变量是否存在缺失值。\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n      idcode |      2,246    2612.654    1480.864          1       5159\n         age |      2,246    39.15316    3.060002         34         46\n        race |      2,246    1.282725    .4754413          1          3\n     married |      2,246    .6420303    .4795099          0          1\nnever_marr~d |      2,246    .1041852    .3055687          0          1\n-------------+---------------------------------------------------------\n       grade |      2,244    13.09893    2.521246          0         18\n    collgrad |      2,246    .2368655    .4252538          0          1\n       south |      2,246    .4194123    .4935728          0          1\n        smsa |      2,246    .7039181    .4566292          0          1\n      c_city |      2,246    .2916296    .4546139          0          1\n-------------+---------------------------------------------------------\n    industry |      2,232    8.189516    3.010875          1         12\n  occupation |      2,237    4.642825    3.408897          1         13\n       union |      1,878    .2454739    .4304825          0          1\n        wage |      2,246    7.766949    5.755523   1.004952   40.74659\n       hours |      2,242    37.21811    10.50914          1         80\n-------------+---------------------------------------------------------\n     ttl_exp |      2,246    12.53498    4.610208   .1153846   28.88461\n      tenure |      2,231     5.97785    5.510331          0   25.91667\n如果想了解某个变量更为详细的信息，可以附加一个 detail 选项，可以看到，除了列举平均值、标准差等外，页面中还列示了各分位点的信息，以进一步判断离群值的严重程度。\n                         hourly wage\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%     1.930993       1.004952\n 5%     2.801002       1.032247\n10%     3.220612       1.151368       Obs               2,246\n25%     4.259257       1.344605       Sum of Wgt.       2,246\n\n50%      6.27227                      Mean           7.766949\n                        Largest       Std. Dev.      5.755523\n75%     9.597424       40.19808\n90%     12.77777       40.19808       Variance       33.12604\n95%     16.52979       40.19808       Skewness       3.096199\n99%     38.70926       40.74659       Kurtosis       15.85446\n\n\n2.2 tabstat 命令\n论文中呈现基本统计量通常不再使用 summmarize 命令，因为其格式不太符合多数期刊的要求（通常期刊要求保留三位或两位有效数字），更多时候使用 tabstat 命令。\ntabstat wage age hours  married collgrad race, ///\n    stat(N mean sd min max p25 p50 p75)      ///\n    format(%4.2f) columns(statistics)\ncolumns (statistics) 表示每一列呈现基本统计量，则每一行呈现变量名称。格式通过 format 命令 （可简写为 f ）来控制，.2f 表示保留两位有效数字。注意，在将表格插入 Word 文档时需要进行一个小的处理，即需要把观测值个数中的 “.00” 手动删掉。\n另外，每一列呈现的基本统计量是通过 Statistics 选项来控制的，可简写为 s 或 Stat，可在 help 文档中查看各种统计量的名称并进行列举。\n上述命令简写后如下：\nlocal x \"wage age hours  married collgrad race\"\nlocal x \"wage age hours  married collgrad race\"\ntabstat `x',  ///\n    s(N mean sd min max p25 p50 p75)  ///\n    f(%4.2f) c(s)\n注意，表格插入 Word 有两种方式：\n\n使用 logout 命令输出为 Excel 表格。\n选中后，右键复制表格。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>R3. 基本统计量的呈现</span>"
    ]
  },
  {
    "objectID": "body/R3-基本统计量的呈现.html#stata-外部命令fsum",
    "href": "body/R3-基本统计量的呈现.html#stata-外部命令fsum",
    "title": "R3. 基本统计量的呈现",
    "section": "2. Stata 外部命令：fsum",
    "text": "2. Stata 外部命令：fsum\n在基本设定下，在 Stata 中输入 fsum 可以快速呈现基本统计量，呈现的结果和 sum 很接近，但也存在细微的差别，比如输入 sum 口令时，基本统计量的小数点位数并不完全一致，但是 fsum 基本保留了小数点后两位，符合多数期刊的要求。\n      Variable |     N     Mean       SD      Min      Max\n---------------+------------------------------------------\n        idcode |  2246  2612.65  1480.86     1.00  5159.00\n           age |  2246    39.15     3.06    34.00    46.00\n          race |  2246     1.28     0.48     1.00     3.00\n       married |  2246     0.64     0.48     0.00     1.00\n never_married |  2246     0.10     0.31     0.00     1.00\n         grade |  2244    13.10     2.52     0.00    18.00\n      collgrad |  2246     0.24     0.43     0.00     1.00\n         south |  2246     0.42     0.49     0.00     1.00\n          smsa |  2246     0.70     0.46     0.00     1.00\n        c_city |  2246     0.29     0.45     0.00     1.00\n      industry |  2232     8.19     3.01     1.00    12.00\n    occupation |  2237     4.64     3.41     1.00    13.00\n         union |  1878     0.25     0.43     0.00     1.00\n          wage |  2246     7.77     5.76     1.00    40.75\n         hours |  2242    37.22    10.51     1.00    80.00\n       ttl_exp |  2246    12.53     4.61     0.12    28.88\n        tenure |  2231     5.98     5.51     0.00    25.92\nfsum 最大的优势在于呈现类别统计量时非常有效率，以下面的命令为例。\nglobal x \"wage age hours  married collgrad race occupation\" \n\nfsum $x,  ///\n    s(N mean median sd min max abspct) ///\n    pctvar(married collgrad)  ///\n    catvar(race occupation)   ///\n    format(8.2) \n全局暂元中包含了两个类别变量，分别为 occupation 和 race。pctvar 选项后的 married 和 collgrad 都为虚拟变量，在执行 fsum 后，呈现出的是变量取 0/1 的比例。比如在数据中，有64.2%的妇女已婚，有23.69%的妇女的学历是大学毕业。注意虚拟变量并不需要呈现最小值和最大值，中位数也完全可以通过平均值判断，比如平均值是0.642，则显然中位数是1（即1的个数多于0的个数）。\n再往下看，catvar 选项中设定了所有类别变量， race 共有三个类别，则会呈现三个类别分别的统计情况，如白种人占了72.89%。在没有 fsum 命令时，统计类别变量的占比时还需要 tab 命令来处理。\n          Variable |       N  AbsPct    Mean      SD  Median     Min     Max  \n-------------------+--------------------------------------------------------\n              wage |    2246    0.00    7.77    5.76    6.27    1.00   40.75  \n               age |    2246    0.00   39.15    3.06   39.00   34.00   46.00  \n             hours |    2242    0.18   37.22   10.51   40.00    1.00   80.00  \n           married |    2246    0.00   64.20                                    \n          collgrad |    2246    0.00   23.69                                    \n              race |    2246    0.00    1.28    0.48    1.00    1.00    3.00  \n        white (%)  |    1637    0.00   72.89\n        black (%)  |     583    0.00   25.96\n        other (%)  |      26    0.00    1.16\n        occupation |    2237    0.40    4.64    3.41    3.00    1.00   13.00  \n Professional (%)  |     317    0.00   14.17\nManagers/admin(%)  |     264    0.00   11.80\n        Sales (%)  |     726    0.00   32.45\n    unskilled (%)  |     102    0.00    4.56\n    Craftsmen (%)  |      53    0.00    2.37\n   Operatives (%)  |     246    0.00   11.00\n    Transport (%)  |      28    0.00    1.25\n     Laborers (%)  |     286    0.00   12.78\n      Farmers (%)  |       1    0.00    0.04\nFarm laborers (%)  |       9    0.00    0.40\n      Service (%)  |      16    0.00    0.72\n    Household (%)  |       2    0.00    0.09\n        Other (%)  |     187    0.00    8.36\n我们也可以加入 uselabel 选项，可显示数据中已经定义好的标签，或用 char 临时定义标签，标签内容将呈现在表格左侧。\n除上文介绍的命令外， tabout 命令也可以呈现基本统计量，比较灵活，功能强大，可以配合 latex 使用。\npublish 的功能也很庞大，但是语法较为复杂，还是建议使用前文提到的若干命令，更加方便使用。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>R3. 基本统计量的呈现</span>"
    ]
  },
  {
    "objectID": "body/R4-组间均值差异检验.html",
    "href": "body/R4-组间均值差异检验.html",
    "title": "R4. 组间均值差异检验",
    "section": "",
    "text": "1. 简介\n检验连续变量在两组中的均值是否存在显著差异是一项非常重要的统计工作。在本文中，我们又将均值差异检验分为三种情形：第一种「单变量组间差异检验」，如检验是否大学毕业的两组人群 工资 是否存在显著差异；第二种「多变量组间差异检验」，如检验是否大学毕业的两组人群在 工资、每周工作时数、工作年限 等方面是否存在显著差异；第三种「变量在多组之间差异检验」，如工资在是否大学毕业、黑人和白人、是否工会成员等组中存在显著差异。\n当然，在运行命令前，还需安装一些外部命令。可通过以下方式加载：首先，将「LY_sata」文件放置在「..\\ado\\personal」文件夹下，「..」对应自己 Stata 安装路径；然后，运行一下命令可以加载相应外部命令。\n我们也可以将外部命令放在自己 Stata 安装路径下 「plus」文件夹。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R4. 组间均值差异检验</span>"
    ]
  },
  {
    "objectID": "body/R4-组间均值差异检验.html#简介",
    "href": "body/R4-组间均值差异检验.html#简介",
    "title": "R4. 组间均值差异检验",
    "section": "",
    "text": "global path \"`c(sysdir_personal)'\\LY_stata\" \ncd \"$path\\_Results\"\nadopath + \"$path\\_plus\"  //外部命令统一存放于此处",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R4. 组间均值差异检验</span>"
    ]
  },
  {
    "objectID": "body/R4-组间均值差异检验.html#单变量组间差异-t-test",
    "href": "body/R4-组间均值差异检验.html#单变量组间差异-t-test",
    "title": "R4. 组间均值差异检验",
    "section": "2. 单变量组间差异 t-test",
    "text": "2. 单变量组间差异 t-test\n以「nlsw88」这份数据为例，研究工资在女性是否大学毕业两组中是否存在显著差异。在 Stata 中，我们可以使用 ttest 命令进行检验，即 ttest wage, by(conllgrad)，其中 conllgrad 为是否大学毕业的分类变量，而 wage 为工资连续变量。\n下图为 ttest wage, by(conllgrad) 命令运行结果。可以看出，没有大学毕业女性组样本数为 1714，均值为 6.910561，而大学毕业组样本数为 552，均值为 10.52606，二者差异为 -3.615502。原假设为「H0: diff = 0」，三个备择假设只有「Ha: diff &lt; 0」和「Ha: diff != 0」显著，说明没有大学毕业女性组工资显著小于大学毕业组。\n\n「nlsw88」数据中还有类别变量 race，其数值为 1、2 和 3，分别代表白种人、黑种人和其他人种。若想检验白种人和黑种人在工资上是否存在显著差异，直接运行 ttest wage, by(race) 命令会报错，因为 race 有三个组别。可行的做法是生产一个新的组别虚拟变量，或者加条件语句，即 ttest wage if race != 3, by(race)。\nhelp ttest\nsysuse nlsw88, clear\nttest wage, by(collgrad)  \nttest wage, by(race)            //错误命令\nttest wage if race!=3, by(race) //限定为两组即可",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R4. 组间均值差异检验</span>"
    ]
  },
  {
    "objectID": "body/R4-组间均值差异检验.html#多变量组间差异-t-test",
    "href": "body/R4-组间均值差异检验.html#多变量组间差异-t-test",
    "title": "R4. 组间均值差异检验",
    "section": "3 多变量组间差异 t-test",
    "text": "3 多变量组间差异 t-test\n多变量组间差异检验是更为一般的组间差异检验。实现该检验有两个主要命令，即 ttable3 和 normdiff。\n先看一下 ttable3 命令。我们仍以「nslw88」这份数据为例，不同的是，这次要考虑 wage 、hours、tenure、ttl_exp 这四个变量在是否大学毕业的两组中的差异。而 ttable3 命令工作原理就是对上述四个变量循环运行 ttest。\nsysuse nlsw88, clear\nglobal x \"wage hours tenure ttl_exp\" //待检验变量列表\nttable3 $x, by(collgrad) \n从下图可以看出，大学毕业组与非大学毕业组均值差异在 1% 的统计水平上显著。由于在 hours、tenure、ttl_exp 三个变量也存在显著差异，故不能认为是否大学毕业是工资差异的原因，否则就可能存在自选择问题。\n\nttable 命令有两个缺陷，一是无法报告 t 值，二是无法提供「标准化」的均值差异检验，而 normdiff 命令可以克服这两个问题。\n「输出 t 值或 p 值」命令为 normdiff $x, over(collgrad) diff t p n(below) f(%16.2f) quietly nonormdiff。与 ttest 命令中 by 一样，normdiff 用 over 来分组。\n*-输出 t 值或 p 值 \nnormdiff $x, over(collgrad)   ///\n             diff t p n(below) f(%16.2f) quietly nonormdiff \n\n「标准化差异」命令为 normdiff $x, over(collgrad) diff t p n(below) f(%16.2f) quietly，就是将 nonormdiff 这个选项去掉。\n标准化的差异为下式，详见 Imbens & Wooldridge (2009, JEL, p24)。\n\\[\n\\Delta x = (x_1 - x_0) / \\sqrt{(s^2_1+s^2_2)}\n\\]\n其中，\\(x\\) 为样本均值，\\(s^2\\) 为样本方差。\n*-标准化差异      \nqui reg $x\nkeep if e(sample) //保证所有的变量有相同的观察值个数\nnormdiff $x, over(collgrad)   ///\n             diff t p n(below) f(%16.2f) quietly",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R4. 组间均值差异检验</span>"
    ]
  },
  {
    "objectID": "body/R4-组间均值差异检验.html#变量在多组之间的差异",
    "href": "body/R4-组间均值差异检验.html#变量在多组之间的差异",
    "title": "R4. 组间均值差异检验",
    "section": "4 变量在多组之间的差异",
    "text": "4 变量在多组之间的差异\n最后一种情形就是变量在多个组中的差异检验，命令为 ttestplus。以工资在是否结婚、是否工会成员、是否大学毕业和是否住在南部差异检验为例，命令语句为 ttestplus wage, by(married union collgrad south)。\nhelp ttestplus     //t-tests on one or more dimensions\nsysuse nlsw88, clear\nttestplus wage, by(married union collgrad south)\n下图为变量在多组间差异检验结果。以 married 为例，Group1 为未婚，Group2 为已婚，未婚女性工资在 5% 的统计水平上显著高于已婚女性。3.18e-11 为科学计数法，等价于 \\(3.18e^{-11}\\)。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R4. 组间均值差异检验</span>"
    ]
  },
  {
    "objectID": "body/R4-组间均值差异检验.html#扩展阅读",
    "href": "body/R4-组间均值差异检验.html#扩展阅读",
    "title": "R4. 组间均值差异检验",
    "section": "5. 扩展阅读",
    "text": "5. 扩展阅读\nhelp dmout     //类似于 ttable3, 呈现 se 或 p 值\nhelp pwmean    //Pairwise comparisons of means\nhelp ttab      //分层列表\nhelp cendif    //各个分位点上的差异检验  \nhelp signrank  //Equality tests on   matched data\nhelp ranksum   //Equality tests on unmatched data\nhelp sdtest    //Variance-comparison tests\nhelp nptrend   //Test for trend across ordered groups",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>R4. 组间均值差异检验</span>"
    ]
  },
  {
    "objectID": "body/R5-基本统计量和相关系数的输出.html",
    "href": "body/R5-基本统计量和相关系数的输出.html",
    "title": "R5. 统计表格输出为 Excel/Word",
    "section": "",
    "text": "R5.1 描述性统计结果输出\n在统计分析中，我们常常利用 tabstat 命令生成变量的描述性统计，如何将它输出为 Excel/Word 格式呢？\n最为传统的方式是复制粘贴，在stata中选中表格，然后单击右键，选择copy table，粘贴到Excel，整理后再复制到word中。\n另外，在 stata 命令中，利用 logout 可直接简便的将结果输出 (word、excel、tex)，它的命令格式为：\n下面我们通过一个例子来了解输出变量的描述性统计。\n由以上命令可知，利用 logout 输出描述性统计结果，即是在原有的 tabstat 命令基础上加入一行命令，以实现格式的设定。最后生成一个蓝色的链接，点击链接即可查看 Excel 格式的结果。需要注意的是，这个表格被自动保存在了当前的工作路径里。\nNotes:",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>R5. 统计表格输出为 Excel/Word</span>"
    ]
  },
  {
    "objectID": "body/R5-基本统计量和相关系数的输出.html#r5.1-描述性统计结果输出",
    "href": "body/R5-基本统计量和相关系数的输出.html#r5.1-描述性统计结果输出",
    "title": "R5. 统计表格输出为 Excel/Word",
    "section": "",
    "text": ". sysuse nlsw88, clear\n\n. logout, save(tab_stat1) excel replace fix(3):     ///  \n    tabstat wage age hours  married collgrad  race, ///\n            s(N mean sd min max p25 p50 p75)        ///\n            f(%4.2f) c(s) \n\n\n\n\nsave() 选项中指定文件名，并保存于当前工作路径下\n\n\nexcel 更换为 word, 则输出 word 文档\n\n\nfix(3) 用于控制将文字转换为表格过程中对空格的敏感度",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>R5. 统计表格输出为 Excel/Word</span>"
    ]
  },
  {
    "objectID": "body/R5-基本统计量和相关系数的输出.html#r5.2-fsum-命令",
    "href": "body/R5-基本统计量和相关系数的输出.html#r5.2-fsum-命令",
    "title": "R5. 统计表格输出为 Excel/Word",
    "section": "R5.2 fsum 命令",
    "text": "R5.2 fsum 命令\n第二个例子是之前介绍的外部命令：fsum，可以帮助我们快速得到想要的统计结果。\n. sysuse nlsw88, clear\n. logout, save(tab_stat2) excel replace fix(15):       ///  \n    fsum wage age hours tenure married collgrad  race, ///\n         s(N mean median sd min max abspct) ///\n         pctvar(married collgrad)           ///\n         catvar(race)                       ///\n         f(8.2) uselabel    \n\n*-Note: 请将 fix(15) 改为 fix(3), 看看结果有何差异\n*-秘诀: try, try, try, ..",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>R5. 统计表格输出为 Excel/Word</span>"
    ]
  },
  {
    "objectID": "body/R5-基本统计量和相关系数的输出.html#r5.3-相关系数矩阵",
    "href": "body/R5-基本统计量和相关系数的输出.html#r5.3-相关系数矩阵",
    "title": "R5. 统计表格输出为 Excel/Word",
    "section": "R5.3 相关系数矩阵",
    "text": "R5.3 相关系数矩阵\n第三个例子是用 logout 命令输出相关系数矩阵，\n. sysuse nlsw88, clear\n. logout, save(tab_corr) excel replace fix(5): /// \n     pwcorr wage age hours tenure ttl_exp, star(0.05) \n与前面一致，也是在 pwcorr 前面加入一行命令即可实现。此外，若希望控制相关系数矩阵中统计值的小数点后有效数字位数，以及显著水平的标注，可以使用连老师编写的 pwcorr_a 命令，参见 pwcorr_a：输出相关系数矩阵至 Word 和 Excel。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>R5. 统计表格输出为 Excel/Word</span>"
    ]
  },
  {
    "objectID": "body/R5-基本统计量和相关系数的输出.html#r5.4-回归结果的输出",
    "href": "body/R5-基本统计量和相关系数的输出.html#r5.4-回归结果的输出",
    "title": "R5. 统计表格输出为 Excel/Word",
    "section": "R5.4 回归结果的输出",
    "text": "R5.4 回归结果的输出\n对于回归结果，输出相对复杂一些，但借助 esttab, asdoc， outreg2 等外部命令，这个工作也来越轻松了。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>R5. 统计表格输出为 Excel/Word</span>"
    ]
  },
  {
    "objectID": "body/R6-拟合值和残差.html",
    "href": "body/R6-拟合值和残差.html",
    "title": "R6. 拟合值和残差",
    "section": "",
    "text": "1. 简介\n以妇女工资与妇女工作时间为例，图中\\(y_{i-fit}\\)是工作时间为3小时对应的工资拟和值，\\(y_i\\)是工资的实际观测值，两者差值\\(e_i\\)即为残差。\n可以通过以下命令获得拟和值和残差",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>R6. 拟合值和残差</span>"
    ]
  },
  {
    "objectID": "body/R6-拟合值和残差.html#简介",
    "href": "body/R6-拟合值和残差.html#简介",
    "title": "R6. 拟合值和残差",
    "section": "",
    "text": "sysuse nlsw88, clear\nreg wage hours\npredict wage_hat\npredict e, res",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>R6. 拟合值和残差</span>"
    ]
  },
  {
    "objectID": "body/R6-拟合值和残差.html#范例-1-超额工资水平",
    "href": "body/R6-拟合值和残差.html#范例-1-超额工资水平",
    "title": "R6. 拟合值和残差",
    "section": "2. 范例 1: 超额工资水平",
    "text": "2. 范例 1: 超额工资水平\n\n2.1 计算正常工资和超额工资\n假定工资由年龄 ( age ) 、工作时间 ( hours ) 、终身职位年数 ( tenure ) 、是否大学毕业 ( collgrad ) 以及是否在南方地区 ( south ) 决定，其中回归得到的线性拟和值即为正常工资，残差项即为超额工资；具体代码如下：\nglobal x \"age hours tenure collgrad married south\"\nreg wage $x\nkeep if e(sample)   //仅保留参与回归的观察值, 参见 D3_miss.do\n  \npredict normal_wage       //正常工资(线性拟合值)\n  \npredict excess_wage, res  //超额工资(残差, 可正可负)\n\n\n2.2 进一步分析\n作出超额工资直方图后发现，极少数妇女获得了特别高的超额工资。\n\n进一步对行业进行分组统计后发现运输业和金融业有较高的超额工资，而农林牧渔的超额工资则为负；其他行业特征读者们可以此类推。\n    tabstat excess_wage, by(industry)  c(s)   /// //统计分析\n            s(mean N sd p50 min max) f(%4.2f)\n\n最后，我们对残差进行回归分析探究超额工资的可能影响因素。\n    global z \"i.race union never_married\"   \n    reg excess_wage $z    //影响因素,不完整\n结果显示，黑种人相对于白种人有显著更低的超额工资，工会成员有显著更高的工资水平，婚姻状况对超额工资无影响。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>R6. 拟合值和残差</span>"
    ]
  },
  {
    "objectID": "body/R6-拟合值和残差.html#范例-2-分行业-分年度计算超额工资水平",
    "href": "body/R6-拟合值和残差.html#范例-2-分行业-分年度计算超额工资水平",
    "title": "R6. 拟合值和残差",
    "section": "3. 范例 2: 分行业-分年度计算超额工资水平",
    "text": "3. 范例 2: 分行业-分年度计算超额工资水平\n经过数据预处理后，我们根据以下代码计算出分行业-分年度的超额工资水平，再根据第 2 部分的方法进行分析。\n  gen ex_wage = .\n  local xx \"age nev_mar collgrad south ttl_exp tenure\" \n  qui sum ind_year\n  global N = r(max)  // 行业-年度个数\n    \n  forvalues i = 1/$N{         // 参见 P3_loop.do\n    qui reg ln_wage `xx' if (ind_year==`i')\n    qui predict e if e(sample), res\n    qui replace ex_wage = e if e(sample) \n    drop e\n  }",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>R6. 拟合值和残差</span>"
    ]
  },
  {
    "objectID": "body/R6-拟合值和残差.html#参考文献和扩展阅读",
    "href": "body/R6-拟合值和残差.html#参考文献和扩展阅读",
    "title": "R6. 拟合值和残差",
    "section": "参考文献和扩展阅读",
    "text": "参考文献和扩展阅读\n\nRichardson, S., 2006, Over-investment of free cash flow, Review of Accounting Studies, 11 (2): 159-189. -PDF-\n叶德珠, 连玉君, 黄有光, 李东辉, 2012, 消费文化、认知偏差与消费行为偏差, 经济研究, (2): 80-92. -PDF-\n李增福, 董志强, 连玉君. 应计项目盈余管理还是真实活动盈余管理? ――基于我国 2007 年所得税改革的研究. 管理世界, 2011(1): 121-134. -PDF-",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>R6. 拟合值和残差</span>"
    ]
  },
  {
    "objectID": "body/R7-稳健型标准误.html",
    "href": "body/R7-稳健型标准误.html",
    "title": "R7. 稳健型标准误的获取",
    "section": "",
    "text": "1. 引言\n在线性回归分析中，系数是一个随机变量，我们通常采用标准误衡量其准确程度。并且，基于不同假设，标准误的计算方式也不同，导致系数除以标准误得到的 t 统计量也有所差异，最终影响到统计推断。在本文中，我们将介绍三种常用的标准误计算方法：一是只考虑异方差的「White 异方差稳健型标准误」，二是允许组内相关、组间不相关的「聚类调整后的标准误」，三是假设更为灵活的「自抽样法 (Bootstrap) 稳健型标准误」。\n在介绍三类常用标准误计算前，我们先回顾一下标准误和统计推断的概念。经过 ols 回归之后，我们可以得到系数值 \\(b\\)，而标准误计算的最基本假设是干扰项满足独立同分布假设 (IID)。在小样本情况下，系数除以标准误就是 \\(t\\) 统计量，且服从自由度为 \\(N-k\\) 的 \\(t\\) 分布，其中 \\(N\\) 为样本数，\\(k\\) 为模型中估计参数个数。在大样本情况下，系数除以标准误就是 \\(z\\) 统计量，且服从正态分布。当 \\(t\\) 分布自由度 $ N - k&gt; 30$ 时，\\(t\\) 统计量和 \\(z\\) 统计量在分布上没有太大差别。\n\\[\n\\begin{array}{l}\nb / \\mathrm{se}(b)=t \\sim t(N-k) \\quad \\text {Small sample} \\\\\nb / \\mathrm{se}(b)=z \\sim N(0, \\sigma^{2}) \\quad \\text {Lage sample}\n\\end{array}\n\\]",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>R7. 稳健型标准误的获取</span>"
    ]
  },
  {
    "objectID": "body/R7-稳健型标准误.html#white-异方差稳健型标准误",
    "href": "body/R7-稳健型标准误.html#white-异方差稳健型标准误",
    "title": "R7. 稳健型标准误的获取",
    "section": "2. White 异方差稳健型标准误",
    "text": "2. White 异方差稳健型标准误\nWhite (1980) 认为在异方差存在的情况下，ols 估计量仍是无偏、一致的，但是方差需要修正。此时，方差的正确形式为下式：\n\\[\n\\operatorname{Var}(b)=\\left(X^{\\prime} X\\right)^{-1}\\left(X^{\\prime} Q X\\right)\\left(X^{\\prime} X\\right)^{-1}\n\\]\n其中，\\(Q\\) 为 \\(n \\times n\\) 阶方阵，对角元素为 \\(\\sigma^2_{i}\\)，即第 \\(i\\) 个元素的方差，对角线意外的元素全部为零。并且，\\(\\sigma^2_{i}\\) 可由残差平方和 \\(\\hat{u}^2_{i}\\) 表示。\n在 Stata 中，我们仅需在回归命令后加 robust 就可实现异方差稳健标准误计算。具体代码如下:\nsysuse nlsw88, clear\nglobal x \"ttl_exp race age industry hours\"\nreg wage $x          //干扰项服从独立同分布\nest store homo\nreg wage $x, robust  // White(1980)\nest store robust\nesttab homo robust, mtitle(Homo Het_Robust) nogap    \n*-Note：这是 90% 以上的文献都采用的方法；\n*       后续复杂模型的稳健型标准误也基本上以 White(1980) 为基础 \n下图为普通 ols 结果和异方差调整后的 ols 结果，可以看出系数并没有发生变化，而 t 值发生了变化。这主要是因为 robust 调整的是标准误，与系数无关，而 t 值又是系数与标准误的比值。\n\n对于截面数据，异方差问题更为普遍，因此我们通常都需要对其进行调整。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>R7. 稳健型标准误的获取</span>"
    ]
  },
  {
    "objectID": "body/R7-稳健型标准误.html#聚类调整后的标准误",
    "href": "body/R7-稳健型标准误.html#聚类调整后的标准误",
    "title": "R7. 稳健型标准误的获取",
    "section": "3. 聚类调整后的标准误",
    "text": "3. 聚类调整后的标准误\n在异方差基础上，进一步放宽「干扰项独立同分布假设」，允许组内相关，而组间不相关，这时我们就要对方差进行聚类调整。\n\n一维聚类调整\n\n聚类调整只需在普通 ols 回归后加 cluster(clustvar) 或 vce(cluster clustvar)。以 reg wage $x, vce(cluster industry) 为例，vce 为「variance covariance estimation」缩写，cluster 表示聚类调整，industry 为聚类对象，表示同行业干扰项相关，而不同行业彼此不相关。\n\n\n二维聚类调整\n\n使用二维聚类调整时，方差估计量由三个方差矩阵计算得来，其公式的一般表达式为:\n\\[\n{\\mathrm{V}}_{2 \\mathrm{way}}[{b}]={\\mathrm{V}}_{1}[{b}]+{\\mathrm{V}}_{2}[b]-{\\mathrm{V}}_{1 \\cap 2}[{b}]\n\\]\n上述公式表明，二维聚类调整的本质即是在两个维度上分别进行一维的聚类调整，再将有交叉的部分去掉。\n二维聚类调整的 Stata 命令有 cluster2、cgmreg、vce2way、以及 vcemway。以 vce2way 为例，命令为 vce2way reg wage $x, cluster(industry occupation)。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>R7. 稳健型标准误的获取</span>"
    ]
  },
  {
    "objectID": "body/R7-稳健型标准误.html#自抽样法-bootstrap-稳健型标准误",
    "href": "body/R7-稳健型标准误.html#自抽样法-bootstrap-稳健型标准误",
    "title": "R7. 稳健型标准误的获取",
    "section": "4. 自抽样法 (Bootstrap) 稳健型标准误",
    "text": "4. 自抽样法 (Bootstrap) 稳健型标准误\n自抽样法假设当前样本是从总体中随机抽样得到，并且重复从总体中抽样得到的样本也会不同，实际上这种重复从总体中抽样并不现实，我们可以近似通过从样本中重复抽样来达到从总体重复抽样目的。\n关于自抽样法稳健型标注误实现步骤如下：\n\n采用 ols 估计原始模型, 得到 \\(x\\) 的估计系数 \\(b_{x}\\)；\n从样本中有放回地抽取 N 个观察值，执行 ols，记录系数估计值；\n将第 2 步重复进行 300 次，得到系数估计值的 300 个记录, 即 \\(b_{j} = \\{b_1, b_2, \\ldots, b_{300} \\}\\)；\n计算这 300 个估计值的标准差 \\(\\mathrm{sd}(b_{j}) = \\mathrm{sd} \\{b_1, b_2, \\ldots , b_{300}\\}\\)，将其视为实际估计值 \\(b_x\\) 的标准误，即 \\(\\mathrm{se}(b_x) = \\mathrm{sd} (b_{j})\\);\n计算 t 值: \\(t = b_x/\\mathrm{se}(b_x)\\), 以及相应的 p 值。\n\n在 Stata 中，我们仅需在回归中加上 vce(bs, rep(300)) 命令即可实现自抽样法稳健型标准误计算，其中 bs 为「bootstrap」简写，rep(300) 表示重复抽样 300 次。\nhelp bootstrap        \nsysuse nlsw88, clear\nreg wage hours, vce(bs,reps(300))\n\n*---------------------过程解析(了解思路即可)-------------------\nsysuse nlsw88, clear\ngen bj = .         //记录抽样估计结果\nforvalues j = 1/300{             // 参见 [P3_loop.do]\n    preserve                       // 参见 [P4_ado.do]\n        bsample       //Bootstrap 抽样, 参见 [P5_sample.do]\n        qui reg wage hours\n    restore\n    qui replace bj = _b[hours] in `j'\n}\n\nsum bj    // 计算标准差=SE(weight)\ndis \"Bootstrap SE = \" %6.4f r(sd)\n*--------------------------------------------------------------\n*-对比:\n  reg wage hours, vce(bs,reps(300) noheader nodots) \n  reg wage hours, robust noheader // White s.e.\n\n*-Notes:                | 主页: lianxh.cn |\n* (1) 多数情况下，1000 次可重复抽样即可获得非常稳定的结果;\n* (2) stata 中的多数命令都支持 vce(bs) 选项;\n      help vce_option\n      help bs\n* (3) 投稿前, 请设定种子值, 以保证结果可以重现;\n      reg price weight, vce(bs,reps(1000) seed(13579))\n      help seed",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>R7. 稳健型标准误的获取</span>"
    ]
  },
  {
    "objectID": "body/R8-平方项.html",
    "href": "body/R8-平方项.html",
    "title": "R8. 平方项——特殊的交叉项",
    "section": "",
    "text": "1. 初步图形分析\n在平时的回归分析中我们经常会面临非线性关系，通常的处理方法有两种，一种是进行分组回归，另一种则是引入交叉项，本文将从绘图、转折点的确定和经济意义3个方面介绍一种特殊的交叉项———二次项。\naaplot 命令\n研究女性工资收入和工龄之间是否存在非线性关系。首先用 aaplot 命令对其绘制散点图，观察是否存在线性关系,在此基础上加入平方项，使用 quadratic 绘制非线性拟合图，为了便于比较，最后将线性拟合图和非线性拟合图同时绘制出来，在Stata中运行代码如下：\n从拟合结果中可以看出非线性拟合方程的 \\(R^2\\) 出现了微小的变化，样本主体部分的线性拟合图和非线性拟合图基本重合，右侧个别样本点并不影响整体趋势，因此在本例中宜采用线性拟合。\n研究汽车价格和重量之间的关系。使用 aaplot 命令同时绘制线性拟合图和非线性拟合图，在 Stata 中输入如下代码：\n从回归方程来看，非线性拟合方程的的 \\(R^2\\) 显著大于线性拟合方程，从拟合图形也可以看出，两者走势存在显著差异，从图中可以直观地判断加入平方项能更好地刻画两者之间的关系。\n在本例中，非线性拟合图的转折点左右都有较多的样本观测值，因此平方项似乎具有一定的经济意义。进一步将样本分为进口车和国产车两组分别进行线性拟合，在 Stata 中运行如下代码：\n可以发现总体上的非线性关系在进行分组回归时，两组样本呈现出较好的线性拟合效果。对于这种情况，建议进行分组回归，而尽可能避免使用平方项。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>R8. 平方项——特殊的交叉项</span>"
    ]
  },
  {
    "objectID": "body/R8-平方项.html#初步图形分析",
    "href": "body/R8-平方项.html#初步图形分析",
    "title": "R8. 平方项——特殊的交叉项",
    "section": "",
    "text": "范例 1\n\n\n   sysuse nlsw88, clear\n   aaplot wage ttl_exp  //线性拟合\n   aaplot wage ttl_exp, quadratic qopts(lc(pink)) //非线性拟合 \n   aaplot wage ttl_exp, both lopts(lc(blue)) qopts(lc(pink))\n\n\n\n范例 2\n\n\n   sysuse auto, clear\n   aaplot price weight, both lopts(lc(blue)) qopts(lc(pink)) \n\n\n\n#delimit ;   \ntwoway (scatter price weight if foreign==1) \n       (lfit price weight if foreign==1)\n       (scatter price weight if foreign==0) \n       (lfit price weight if foreign==0), \n       legend(label(1 \"Foreign\")  label(2 \"\")\n              label(3 \"Demestic\") label(4 \"\")\n            position(4) ring(0)) ;\n   #delimit cr\n\n\n\nNote: 若能分组进行线性回归，就尽量不要使用平方项。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>R8. 平方项——特殊的交叉项</span>"
    ]
  },
  {
    "objectID": "body/R8-平方项.html#转折点的确定",
    "href": "body/R8-平方项.html#转折点的确定",
    "title": "R8. 平方项——特殊的交叉项",
    "section": "2. 转折点的确定",
    "text": "2. 转折点的确定\n\n2.1 二次函数回顾\n\\[\ny = ax^2 + bx + c\n\\]\n\n转折点： \\(tpoint = -b/2a\\)\n边际效应： \\(dy/dx = b + 2a*x\\)\n\n\nU 型关系: \\(a&gt;0\\)\n倒 U 型关系: \\(a&lt;0\\)\n\n\n\n2.2 估计系数的引用\n以上述女性工资和工龄之间的关系为例，在 Stata 中运行以下代码，可以调用估计系数：\n  sysuse nlsw88, clear\n  reg wage hours age   \n  dis _b[hours] \n  dis _b[_cons]\n\n\n2.3 转折点(The turnning point)\n在上面的示例中，引入工作年限的平方项对其进行回归，并分别使用 scatter 和 qfit 命令绘制出女性工资和工作年限的散点图和非线性拟合图：\nsysuse nlsw88, clear\nglobal controls \"hours age tenure married south i.race\"\ngen ttl_exp2 = ttl_exp^2   ///生成平方项\nreg wage ttl_exp ttl_exp2 $controls\n\npredict wage_hat if e(sample)\n\ntwoway (scatter wage ttl_exp, msize(*0.3)) ///\n       (qfit wage_hat ttl_exp )\n\n从图形上可以看出拟合线接近于一条直线，转折点右侧的观测值较少而不具有代表性。进一步计算出转折点的具体数值：\n. global tp = -_b[ttl_exp]/(2*_b[ttl_exp2])\n\n. dis \"Turn point = \" %4.2f $tp\nTurn point = 27.18",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>R8. 平方项——特殊的交叉项</span>"
    ]
  },
  {
    "objectID": "body/R8-平方项.html#转折点的经济含义",
    "href": "body/R8-平方项.html#转折点的经济含义",
    "title": "R8. 平方项——特殊的交叉项",
    "section": "3. 转折点的经济含义",
    "text": "3. 转折点的经济含义\n需要强调的是我们使用交叉项研究的是经济学问题，而不是数学问题，因此特别需要注意转折点两边的样本是否具有代表性。在具体的分析中，可以通过比较转折点与样本最大观测值，以及简单的统计分析来判断样本中有多少观测值位于转折点右侧。在 Stata 中运行如下代码：\n. keep if e(sample)\n(19 observations deleted)\n\n. sum ttl_exp \n\n Variable |   Obs       Mean    Std. Dev.       Min        Max\n----------+---------------------------------------------------\n  ttl_exp | 2,227   12.56003    4.605169   .1153846   28.88461\n\n. count if ttl_exp&gt;$tp\n  2\n返回值：\n通过 sum 命令进行统计分析，可以看到样本最大值为 28.88，使用 count 命令统计观测值大于转折点的样本有多少，可以看到仅有 2 个样本观测值位于转折点右侧。我们可以通过绘图直观地展示这一结果：\n  local b0 = _b[_cons]\n  local b1 = _b[ttl_exp]\n  local b2 = _b[ttl_exp2]\n  sum ttl_exp\n  local min = r(min)   \n  local max = r(max)\n  #delimit ;               \n  twoway ( function y = `b2'*x^2 + `b1'*x + `b0',\n               range(`min' `max') ) \n         ( function y = `b2'*x^2 + `b1'*x + `b0',\n               range(`max' 40) lp(dash) ) \n         ,\n         ytitle(\"wage\") \n         xtitle(\"ttl_exp\")\n               xline($tp,lp(dash) lc(green)) \n               xline(`max',lc(blue))\n               legend(off) \n               text( 9 24.5 \"Turn Point\") \n               text(10 30.4 \"Max\")\n               caption(\"The turn point is: $tp\")\n         ;\n    #delimit cr\n\n从图形中可以看到右侧虚线部分是无经济意义的，样本实际上只体现了图形左侧的关系。\n最后需要注意的是函数形式会影响转折点的位置，当被解释变量采用不同的形式如 ln(wage) 时，上述结果将会发生变化。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>R8. 平方项——特殊的交叉项</span>"
    ]
  },
  {
    "objectID": "body/R9-回归结果的呈现和输出.html",
    "href": "body/R9-回归结果的呈现和输出.html",
    "title": "R9. 回归结果的呈现和输出",
    "section": "",
    "text": "1. 线性拟合的表达式\n本章介绍如何把 Stata 产生的结果美观快捷的输出到屏幕、Excel 或 Word 文档中。\n在完成回归后，我们可以通过外部命令 regfit 将线性拟合表达式呈现在屏幕上 (Note：旧版程序名称为 equation，现已弃用)。\n举个例子：",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>R9. 回归结果的呈现和输出</span>"
    ]
  },
  {
    "objectID": "body/R9-回归结果的呈现和输出.html#线性拟合的表达式",
    "href": "body/R9-回归结果的呈现和输出.html#线性拟合的表达式",
    "title": "R9. 回归结果的呈现和输出",
    "section": "",
    "text": "ssc install regfit, replace  // 安装最新版\nhelp regfit\n\n. sysuse auto, clear\n. reg price weight mpg \n\n. regfit\n\nprice =  1946.07 + 1.75*weight - 49.51*mpg\n        (3597.05) (0.64)        (86.16)\n         N = 74, R2 = 0.29, adj-R2 = 0.27\nNote: S.E. in parentheses",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>R9. 回归结果的呈现和输出</span>"
    ]
  },
  {
    "objectID": "body/R9-回归结果的呈现和输出.html#输出到-excel-word-中",
    "href": "body/R9-回归结果的呈现和输出.html#输出到-excel-word-中",
    "title": "R9. 回归结果的呈现和输出",
    "section": "2. 输出到 Excel / Word 中",
    "text": "2. 输出到 Excel / Word 中\n将回归结果输出到 Excel / Word 中，使用的命令为 esttab。基本统计量表、相关系数矩阵表和回归结果表通常是论文的核心，这里仅详细介绍回归结果的输出。\nhelp esttab\n  \n*-调入数据\n  sysuse nlsw88.dta, clear\n \n*-设定存储变量名称的暂元  see P2_local.do\n  global xx \"wage age tenure ttl_exp hours married\"\n \n*-Table 1: 基本统计量     see R5_logout.do\n  logout, save(\"Tab1_statis\") excel replace: ///\n  tabstat $xx, stat(mean p50 sd min max)     ///\n           format(%3.2f) column(statis)\n        \n*-Table 2: 相关系数矩阵   see R5_logout.do\n  logout, save(\"Tab2_corr\") excel replace: ///\n      pwcorr_a $xx\n      \n*-Table 3: regression results  \n  reg $xx\n  est store full\n  reg $xx if race==1\n  est store white\n  reg $xx if race==2\n  est store black\n  reg $xx i.occupation\n  est store occu\n    \n*-基本用法\n  esttab full white black occu, nogap\n下图为 esttab full white black occu, nogap 命令输出的结果，full white black occu 为存储的回归结果，nogap 是使得行与行之间没有空格。但是，我们可以看出该输出结果有两个缺陷，一是列标题都是被解释变量，不容易区分；二是含有虚拟变量，通常在报告结果时，我们会在最后增加一行显示是否控制该变量，而非报告所有虚拟变量。\n\n为克服以上缺陷，我们看一段完整代码和结果。在运行以下代码时，我们没运行 local s \"using Tab3_reg.csv\" 这行，因此结果会直接输出到屏幕上，而非 Excel。\n*-完整设定                         \n*-----------------------------------------------------------\nlocal s \"using Tab3_reg.csv\"    // 输出 Excel 文档的暂元\nlocal m \"full white black occu\" // 放置模型名称的暂元 \nesttab `m' `s', nogap compress replace            ///\n        mtitle(\"Full\" \"White\" \"Black\" \"with_occu\") ///\n        b(%4.3f) t(%4.2f)                          /// \n        scalar(N r2_a)                             ///\n        star(* 0.1 ** 0.05 *** 0.01)               ///\n        drop(*.*)\n*-----------------------------------------------------------\n*-Note: 两种执行方法, 分别为屏幕呈现和输出 Excel \n\n*-----------------------选项的含义------------------------\n*- nogap     去掉空行\n*- compress  以比较紧凑的形式呈现结果\n*- replace   覆盖已经存在的旧文件\n*- b(%4.3f)  系数保留小数点后三位\n*- t(%4.2f)  t 值保留小数点后两位\n*- scalar()  最后两行的统计量: N-样本数; r2_a-adj-R2\n*- eret list //返回值列表\n*- drop()    不需要呈现的系数\n*---------------------------------------------------------  \n以下为输出结果，compress 是使得列与列间更加紧凑；mtitle 是给每列定义列名；b(%4.3f) t(%4.2f) 定义了系数和 t 值的显示格式，其中系数是小数后保留 3 位，t 值是小数后保留 2 位；scalar 设置输出统计量，这里输出了「样本数 \\(N\\)」和「调整后 \\(R^2\\)」；star 设置的显著水平对应几颗星，如 1 颗星代表 10% 的统计水平；drop(*.*) 是不呈现虚拟变量的回归系数。最后，要在结尾加上一行报告是否控制某个虚拟变量。",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>R9. 回归结果的呈现和输出</span>"
    ]
  },
  {
    "objectID": "body/R9-回归结果的呈现和输出.html#类似命令",
    "href": "body/R9-回归结果的呈现和输出.html#类似命令",
    "title": "R9. 回归结果的呈现和输出",
    "section": "3. 类似命令",
    "text": "3. 类似命令\n  help outreg2\n  help reg2docx\n  help publish",
    "crumbs": [
      "回归分析",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>R9. 回归结果的呈现和输出</span>"
    ]
  },
  {
    "objectID": "body/XT1_面板数据模型简介.html",
    "href": "body/XT1_面板数据模型简介.html",
    "title": "XT1. 面板数据模型简介",
    "section": "",
    "text": "1. 简介\n面板数据由于数据量比较大，有助于我们做更为稳健的统计推断，同时面板数据结合了截面数据与时间序列数据的特征，有助于我们控制一些不可观测的个体效应。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>XT1. 面板数据模型简介</span>"
    ]
  },
  {
    "objectID": "body/XT1_面板数据模型简介.html#简介",
    "href": "body/XT1_面板数据模型简介.html#简介",
    "title": "XT1. 面板数据模型简介",
    "section": "",
    "text": "1.1 举例说明\n首先以一个面试的例子展示不可观测的个体效应对分析的影响：十个学生参与面试，是否录取由面试成绩排名决定。\nuse FE_mark.dta, clear  //do FE_mark_DGP.do 数据生成过程\nlist, sep(6)  //面试成绩\n\n**结果显示\n     +-------------------+\n     | group   id   mark |\n     |-------------------|\n  1. |   A组    1     75 |\n  2. |   A组    2     73 |\n  3. |   A组    3     85 |\n  4. |   A组    4     81 |\n  5. |   A组    5     79 |\n  6. |   A组    6     87 |\n     |-------------------|\n  7. |   B组    1     85 |\n  8. |   B组    2     83 |\n  9. |   B组    3     95 |\n 10. |   B组    4     92 |\n 11. |   B组    5     88 |\n 12. |   B组    6     97 |\n     +-------------------+\n假设只录取 4 人，显然最终录取学生均来自于 B 组，主要原因在于分组面试过程中 A 组与 B 组学生面试打分的标准可能不同，猜测 A 组打分更严格。\ngsort -mark   //排名情况\nlist, sep(0)\n\n**结果显示\n     +-------------------+\n     | group   id   mark |\n     |-------------------|\n  1. |   B组    6     97 |\n  2. |   B组    3     95 |\n  3. |   B组    4     92 |\n  4. |   B组    5     88 |\n  5. |   A组    6     87 |\n  6. |   B组    1     85 |\n  7. |   A组    3     85 |\n  8. |   B组    2     83 |\n  9. |   A组    4     81 |\n 10. |   A组    5     79 |\n 11. |   A组    1     75 |\n 12. |   A组    2     73 |\n     +-------------------+\n我们可以做一下两组的统计分析，发现 A 组的平均成绩为 80，而 B 组平均成绩为 90，即 B 组整体上偏高 10 分。从标准差来看，两者的离散程度基本一致，即两组内部差异控制得基本一致。另外，从图形上我们也能直观地发现两组分数的明显差异，若最初学生在 A 组与 B 组之间的分配完全随机，则这样的差异不应该存在，我们需做出调整保证两个组的分数具有可比性。\ntabstat mark, by(group) s(mean sd min max) f(%4.2f)\n\n**结果显示\nSummary for variables: mark\n     by categories of: group (面试组别)\n\n group |      mean        sd       min       max\n-------+----------------------------------------\n   A组 |     80.00      5.48     73.00     87.00\n   B组 |     90.00      5.59     83.00     97.00\n-------+----------------------------------------\n Total |     85.00      7.42     73.00     97.00\n------------------------------------------------\n\n\n\n1.2 深入讨论\n面试成绩 = 面试官的偏好 + 个人实际能力 + 运气\n学生面试成绩由面试官偏好、个人实际能力以及运气决定，其中面试官偏好决定了整个组的平均面试成绩，而运气例如对题目的熟悉程度等可以被视为期望值为 0 的残差项。我们采用一个更为严谨的数学表达式来反映成绩的构成，面试成绩、面试官偏好、个人实际能力、运气分别用 \\(Y_{it}\\)、 \\(a_{i}\\) 、\\(X_{it}\\)、\\(e_{it}\\) 表示：\n\\[Y_{it}=a_{i}+X_{it}+e_{it}\\quad(1)\\]\n其中，\\(i\\) = 1,2 ，表示面试组别；t = 1,2,…6 表示面试者序号\n\n1.2.1 问题: 如何去除 \\(\\alpha_{i}\\) ?\n\\[\n\\bar{Y_{i}}=a_{i}+\\bar{X_{i}}+\\bar{e}_{i}\\quad(2)\n\\]\n上标\\(-\\)代表每一组的平均值,通过(1)-(2)，我们可以得到：\n\\[\nY_{it}-\\bar{Y_{i}}= X_{it}- \\bar{X_{i}}+ e_{it}- \\bar{e}_{i}\\quad(3)\n\\]\n​(1)-(2)式去除了 \\(a_{i}\\)，最终得到的(3)式中 \\(Y_{it}-\\bar{Y_{i}}\\) 表示面试者成绩-面试者所在组均值，能够更合理地反映了面试者个人实际能力的差别，这种方法称为组内去心或组内差分，是去除不可观测个体效应的主要方法，同时也借助了 Panel 的数据特征。\n\n\n1.2.2 面试成绩调整\n左、右两个图分别是 A、B 组的面试分数调整，在原来的分数上分别减去 A 组平均成绩 80 以及 B 组平均成绩 90。虽然此时的分数能够反映学生的个人实际能力，出于公布分数的需要，我们可以在此基础上加一个常数，保证排名不变。\n\n为了保证百分制，我们进一步调整时选择 85 作为常数项（其中 85 是 12 个学生的样本均值）\n\n总结而言，我们最终调整方案为:\n最终成绩 = 原始成绩 - 组内均值 + 样本均值\n调整后的最终面试成绩如下:\ngsort -mark_FE   //最终排名情况\nlist group id mark_FE, sep(6)\n\n**结果显示\n     +----------------------+\n     | group   id   mark_FE |\n     |----------------------|\n  1. |   A组    6        92 |\n  2. |   B组    6        92 |\n  3. |   A组    3        90 |\n  4. |   B组    3        90 |\n  5. |   B组    4        87 |\n  6. |   A组    4        86 |\n     |----------------------|\n  7. |   A组    5        84 |\n  8. |   B组    5        83 |\n  9. |   A组    1        80 |\n 10. |   B组    1        80 |\n 11. |   B组    2        78 |\n 12. |   A组    2        78 |\n     +----------------------+\n根据调整后的最终面试成绩，前 4 名中各有 2 名来自 A 组和 B 组，在面试学生随机分组的假设下，此时的面试结果更为合理。\n\n\n\n1.3 评论\n\n应用面板数据模型的一个主要目的就是控制不可观测的个体效应，即本例中的：面试评委偏好\n公司研究中，个体效应包括：公司文化, CEO 特征等\n个人消费行为研究中，个体效应包括：个人习惯, 能力, 消费理念等",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>XT1. 面板数据模型简介</span>"
    ]
  },
  {
    "objectID": "body/XT1_面板数据模型简介.html#面板数据特征",
    "href": "body/XT1_面板数据模型简介.html#面板数据特征",
    "title": "XT1. 面板数据模型简介",
    "section": "2 面板数据特征",
    "text": "2 面板数据特征\n\n2.1 面板数据的结构\n面板数据兼具截面资料和时间序列资料的特征,对于面板数据而言，需要标识两个变量，分别是个体变量 idcode 以及年份变量 year，实际操作中使用 Stata 命令 xtset idcode year。同时，xtset 、xtdes、xttab 可以帮助我们认清面板数据的结构, 其中, xtset 能识别面板 balanced or unbalanced，xtdes 更为详细地解析面板数据在个体和时间维度上的分布情况，xttab 能够对面板数据中类别变量的情况进行分析。具体操作见 help xtset,help xtdes 以及 help xtdes。\n\n\n2.2 好处\n\n扩大了样本量，有助于得到更为稳健的统计推断\n可以控制不可观测的个体效应; 通过组内差分解决\n\nhelp xt 详细介绍了 Stata 里面处理 panel 的一系列命令",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>XT1. 面板数据模型简介</span>"
    ]
  },
  {
    "objectID": "body/XT2_FE和RE模型.html",
    "href": "body/XT2_FE和RE模型.html",
    "title": "XT2. FE 和 RE 模型",
    "section": "",
    "text": "1. 基本原理\n本节学习最为常用的两个面板数据模型：固定效应模型 (Fixed Effects model，简称：FE) 和随机效应模型 (Random Effects model，简称：RE)",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>XT2. FE 和 RE 模型</span>"
    ]
  },
  {
    "objectID": "body/XT2_FE和RE模型.html#基本原理",
    "href": "body/XT2_FE和RE模型.html#基本原理",
    "title": "XT2. FE 和 RE 模型",
    "section": "",
    "text": "1.1 混合 OLS 估计 (POLS)\n首先回顾混合 OLS 模型，对于截面数据而言有以下线性表达式，其中 i 代表个体维度 (例如公司)，公式如下:\n\\[\ny_{i}=a+X_{i} \\beta+\\varepsilon_{i}\\quad (1)\n\\]\n对于 Panel Data 而言有以下表达式，其中 i 代表个体维度，t 代表时间维度\n\\[\ny_{it}=a+X_{it} \\beta+\\varepsilon_{i}\\quad (2)\n\\]\n若直接用 OLS 方法应用于 Panel Data，则被称为混合 OLS 估计 (POLS)。在 Stata 中直接输入 reg y x 就可以实现对该模型的混合 OLS 估计。其缺陷在于忽视了实际中个体效应对被解释变量的影响，如面试官的特征会对面试结果产生影响，公司不可观测的公司文化、CEO 的特征等会影响公司的业绩表现及财务决策，因此，将不变的截距项 \\(a\\) 替换成随个体变化的截距项 \\(\\alpha_{i}\\) 后，\\(\\alpha_{i}\\) 在经济意义上反映了每家公司不可观测的个体特征 (公司文化、CEO 特征等等)。\n接下来就转入考虑个体特征的模型。\n\n\n1.2 固定效应模型和随机效应模型\n\n1.2.1 固定效应模型\n首先看一下固定效应模型，模型右边所有的解释变量为 \\[\\color{Blue}X_{i t}^{\\prime} \\beta\\color{Black}+\\color{Blue}\\alpha_{i}\\color{Black}+\\color{Red}\\varepsilon_{i t}\\]\n其中，\\(\\color{Red}\\varepsilon_{i t}\\) 为随机扰动项，前两项中 \\(\\color{Blue}X_{i t}^{\\prime} \\beta\\) 项既随个体 \\(i\\) (公司)，又随时间 \\(t\\) 发生变化，而 \\(\\color{Blue}\\alpha_{i}\\) 项仅随个体 \\(i\\) 变化，不随时间 \\(t\\) 变化，被称为 “个体效应”。可以看到，固定效应模型在混合 OLS 模型基础上作了改进，允许个体之间有不同的截距项，这种截距项用来反映不同个体间不可观测的 “个体效应”。\n\\[\ny_{it}=\\color{Blue}X_{i t}^{\\prime} \\beta\\color{Black}+\\color{Blue}\\alpha_{i}\\color{Black}+\\color{Red}\\varepsilon_{i t}\\color{Black}\\quad (3)\n\\]\n\n\n1.2.2 随机效应模型\n再来看一下随机效应模型，与固定效应表达式相同，不同的是此时 \\(\\color{Red}\\alpha_{i}\\color{Black}+\\color{Red}\\varepsilon_{i t}\\) 被认为是模型的 (复合) 扰动项，第一项 \\(\\color{Red}\\alpha_{i}\\) 只随个体i发生变化，在时序维度上维持稳定 (即上述提及的 “个体效应”)，第二项 \\(\\color{Red}\\varepsilon_{i t}\\) 同时随个体和时间发生变化，即随机效应模型是在干扰项的设定上反映 “个体效应”。\n\\[\ny_{it}=\\color{Blue}X_{i t}^{\\prime} \\beta\\color{Black}+\\color{Red}\\alpha_{i}\\color{Black}+\\color{Red}\\varepsilon_{i t}\\color{Black}\\quad (4)\n\\]\n\n\n1.2.3 固定效应模型与随机效应模型不同之处\n固定效应模型和随机效应模型的表达式完全相同，但背后的含义完全不同。固定效应模型假定“个体效应” \\(\\alpha_{i}\\) 为模型解释变量的一部分，可与其他解释变量 \\(X_{i t}\\) 相关；随机效应模型将“个体效应”将 \\(\\alpha_{i}\\) 放入干扰项 (作为随机变量)，与解释变量 \\(X_{i t}\\) 不相关，这是两个模型假设方面的主要差别。\n在估计方法上，固定效应模型只需要在OLS基础上加入一系列 firm dummies，用来反映不同公司间截距项的差别，即“个体效应“；随机效应模型的干扰项相对复杂，由 \\(\\alpha_{i}\\) (不随时间变化) 和 \\(\\varepsilon_{i t}\\) (随时间变化) 两部分构成，导致异方差问题出现，此时需要采用广义最小二乘估计 (GLS) 方法。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>XT2. FE 和 RE 模型</span>"
    ]
  },
  {
    "objectID": "body/XT2_FE和RE模型.html#模型的-stata-实现",
    "href": "body/XT2_FE和RE模型.html#模型的-stata-实现",
    "title": "XT2. FE 和 RE 模型",
    "section": "2．模型的 Stata 实现",
    "text": "2．模型的 Stata 实现\n\n2.1 估计命令\n\n2.1.1 固定效应模型在Stata中的估计命令\nxtreg y x, fe                \n\nreg y x i.id\n\nareg y x, absorb(id)\n\n\n2.1.2 固定效应模型在Stata中的估计命令\nxtreg y x, re\n\n\n\n2.2 重点解读 Stata 中固定效应估计的具体思路\n\n2.2.1 原理\n\\[\ny_{it}=\\alpha_{i}+\\color{Black}X_{i t}^{\\prime} \\beta+\\varepsilon_{i t}\\color{Black}\\quad (5)\n\\]\n\n式为固定效应模型的表述\n\n\\[\n\\overline{y}_{i}=\\alpha_{i}\\color{Black}+\\overline{X}_{i}^{\\prime} \\beta+\\overline{\\varepsilon}_{i}\\quad (6)\n\\]\n\n式为每家公司内部进行了“压缩“处理，对每家公司时序上的作了平均处理 (计算组内平均值)：\\(\\overline{y}_{i}=(1/T_{i}) \\sum_{t=1}^{T_i} y_{it}\\)\n\n\\[\\overline{\\overline{y}}=\\overline{\\alpha}\\color{Black}+\\overline{\\overline{X}}^{\\prime}\\beta+\\overline{\\overline{\\varepsilon}}\\quad (7)\\]\n\n式为整个样本的“压缩“处理，得到：\\(\\overline {\\alpha}\\color {Black}=(1 / N) \\sum_{i=1}^{N} \\alpha_{i}\\)，被解释变量在整个样本内的平均处理：\\(\\overline {y}_{i} \\rightarrow \\overline {\\overline {y}}\\)\n\n\\[\\left(y_{i t}-\\overline{y}_{i}+\\overline{\\overline{y}}\\right)=\\overline{\\alpha}+\\left(X_{i t}^{\\prime}-\\overline{X}_{i}^{\\prime}+\\overline{\\overline{X}}^{\\prime}\\right) \\beta+\\left(\\varepsilon_{i t}-\\overline{\\varepsilon}_{i}+\\overline{\\overline{\\varepsilon}}\\right)\\quad (8)\\]\n\n\n\n去除了不可观测的 “个体效应”， (8) 式通过 (5) - (6) + (7) 得到，该变换称为组内去心，据此得到的估计量称为 Within-group Estimator (组内估计量) 或 De-meaned Estimator (去心估计量）\n\n\n\n\n\n2.2.2 Stata 中的操作\n先用数据处理方式计算 (5) - (6) + (7)，随后采取 OLS 方式：reg \\(\\tilde {y}_{i t}\\) \\(\\tilde {X}_{i t}^{\\prime}\\)，可得到固定效应模型估计值 \\(\\hat {\\beta}_{F E}\\)。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>XT2. FE 和 RE 模型</span>"
    ]
  },
  {
    "objectID": "body/XT2_FE和RE模型.html#混合-ols-与固定效应模型估计之间的差异",
    "href": "body/XT2_FE和RE模型.html#混合-ols-与固定效应模型估计之间的差异",
    "title": "XT2. FE 和 RE 模型",
    "section": "3. 混合 OLS 与固定效应模型估计之间的差异",
    "text": "3. 混合 OLS 与固定效应模型估计之间的差异\n\n3.1 举例说明\n\n3.1.1 Case I\n如下散点图，若直接进行 OLS 估计，得到红色的拟合线，反映 y 与 x 之间的负相关关系。\n\n\n\n若了解数据背后的特征：每个红圈内样本点对应三家公司，假设三家公司有相同的斜率，对应截距不同三条拟合平行线 (更好反映数据拟合的结果) 为我们通过固定效应模型估计得到的结果。\n\n\n\n同样的数据，POLS 和 FE 估计结果可能完全不同 (Case I 中 POLS 估计结果显著为负，而 FE 估计结果显著为正)。\n\n\n\n\n\n3.1.2 Case II\n散点图：三家公司在不同年份的样本点 (Panel Data)，整体拟合，可得到一条紫色的拟合线，即 x 和 y 存在正相关关系。\n\n\n\n考虑到个体特征，使用固定效应模型估计，得到三条平行蓝色拟合线 (斜率相同)，每家公司有其特定的截距项\n\n\n\n该种情形下，两种估计方法得到的估计值 (斜率) 都为正，但在数值上有所差异。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>XT2. FE 和 RE 模型</span>"
    ]
  },
  {
    "objectID": "body/XT2_FE和RE模型.html#在-stata-中的实例",
    "href": "body/XT2_FE和RE模型.html#在-stata-中的实例",
    "title": "XT2. FE 和 RE 模型",
    "section": "3.2 在 Stata 中的实例",
    "text": "3.2 在 Stata 中的实例\n\n3.2.1 不同模型估计: Stata 代码\n我们使用 invest2.dta 作为研究数据，invest2.dta 包含 100 个观察值：5 家公司，每家公司有 20 年资料，涉及公司 id、时间 t、投资支出 invest、市场价值 market、资本存量 stock 五个变量。有多种方法估计投资支出 invest、市场价值 market、资本存量 stock 三个变量之间的关系，假设我们想研究投资支出、资本存量对市场价值的影响，则在回归模型中被解释变量为市场价值 market，解释变量为投资支出 invest、资本存量 stock，不同模型和估计方法 Stata 命令如下：\n. ​use invest2.dta, clear \n. xtset id t\n\n. global y \"market\"\n. ​global x \"invest stock\"    \n \n. ​regress $y $x    //POLS    \n. est store POLS\n ​     \n. tab id, gen(dum)\n. ​regress $y $x dum2-dum5  //OLS+Dummies(id)    \n. est store OLSdum1\n  \n. regress $y $x dum1-dum5, nocons  //OLS+Dummies(id)\n. ​est store OLSdum2     \n \n. ​xtreg  $y $x, fe  //FE   \n. est store FE\n​     \n. xtreg  $y $x, re  //RE\n. ​est store RE\n\n. ​local m \"POLS OLSdum1 OLSdum2 FE RE\"\n​. esttab `m', mtitle(`m') nogap compress ///\n        scalar(N r2 r2_w r2_b r2_o) ​     ///\n        star(* 0.1 ** 0.05 *** 0.01) \n\n3.2.2 不同模型估计和解释\n\n\n\n第 (1) - (5) 列分别呈现了 POLS、OLS+Dummies(id) 有常数项、OLS+Dummies(id) 无常数项、FE、RE 模型估计结果。\n第 (2) - (4) 列的估计系数以及 t 值完全一样，即无论是 OLS+Dummies(id) 还是 xtreg，fe 进行固定效应的估计，估计系数及标准误完全相同。唯一的差别在于 R 的平方，固定效应 xtreg，fe 组内去心方式在计算 R 平方的时候已经去除了 “个体效应” 的贡献，及列 (2) R 平方 (0.936) 与列 (4) R 平方 (0.417) 的差异在于 Dummies(id) 对 R 平方的贡献。列 (5) 是随机效应模型估计结果，从系数值及方向上比较而言，与列 (4) 固定效应模型估计结果更相似。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>XT2. FE 和 RE 模型</span>"
    ]
  },
  {
    "objectID": "body/XT3_Hausman检验.html",
    "href": "body/XT3_Hausman检验.html",
    "title": "XT3. Hausman 检验",
    "section": "",
    "text": "1. Hausman 检验的基本思想\n常用的面板数据模型有固定效应模型和随机效应模型，由于这两个模型的设定思想和形式有所差异，因此估计结果是不同的，本节介绍的 Hausman 检验有助于判断哪个模型更为适用，主要涉及三个问题：Hausman 检验的基本思想、Stata 实现过程以及实际过程中 Hausman 检验值为负怎么办。\n我们先回顾一下固定效应模型和随机效应模型的模型设定：\n\\[\nFE:\\ y_{it}=\\color{Blue}X_{i t}^{\\prime} \\beta\\color{Black}+\\color{Blue}a_{i}\\color{Black}+\\color{Black}\\varepsilon_{i t}\\quad (1)\n\\]\n\\[\nRE:\\ y_{it}=X_{i t}^{\\prime} \\beta\\color{Black}+\\color{Red}\\alpha_{i}\\color{Black}+\\color{Red}\\varepsilon_{i t}\\color{Black}\\quad (2)\n\\]\n为了便于说明，此处用蓝色标记解释变量，红色标记干扰项。\n固定效应模型 (FE) 将“个体效应” \\(\\color{Blue}a_{i}\\) 视为解释变量的一部分。因此，为了得到 \\(\\beta\\) 的无偏估计，需要假设干扰项 \\(\\varepsilon_{i t}\\) 与 \\(\\color{Blue}X_{i t}\\) 和 \\(\\color{Blue}a_{i}\\) 不相关，即：\n随机效应模型 (RE) 将“个体效应” \\(\\color{Red}\\alpha_{i}\\) 视为干扰项的一部分。为了得到 \\(\\beta\\) 的无偏估计，需要假设干扰项 \\(u_{it} = \\color{Red}\\alpha_{i} + \\color{Red}\\varepsilon_{i t}\\) 与 \\(X_{i t}\\) 不相关，即：\n可以看出，FE 和 RE 的核心差别在于“个体效应” \\(\\alpha_{i}\\) 是否与解释变量 \\(X_{it}\\) 相关，即 \\(\\mathrm{H}_{3}\\) 是否成立。\n简要说明如下：\n因此，Hausman 检验思路是：完成 FE 和 RE 的估计后，对比 FE 和 RE 的估计结果。若没有明显差异，则认为 \\(\\mathrm{H}_{3}\\) 成立，否则，拒绝 \\(\\mathrm{H}_{3}\\)。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>XT3. Hausman 检验</span>"
    ]
  },
  {
    "objectID": "body/XT3_Hausman检验.html#hausman-检验的基本思想",
    "href": "body/XT3_Hausman检验.html#hausman-检验的基本思想",
    "title": "XT3. Hausman 检验",
    "section": "",
    "text": "\\(\\mathrm{H}_{1}: \\mathrm{E}(\\varepsilon_{it}\\,|\\,X_{it}, \\alpha_{\\mathrm{i}})=0\\)\n\n\n\n\\(\\mathrm{H}_{2}: \\mathrm{E}(\\varepsilon_{it}\\,|\\,X_{it})=0\\)\n且 \\(\\mathrm{H}_{3}: \\mathrm{E}(\\alpha_{i}\\,|\\,X_{it})=0\\)\n\n\n\n\n\n\\(\\mathrm{H}_{3}\\)\nFE\nRE\n\n\n\n\n成立\n无偏\n无偏 + 有效\n\n\n不成立\n无偏\n有偏\n\n\n\n\n\n若 \\(\\mathrm{H}_{3}\\) 成立， 则 FE 和 RE 估计量都是无偏的，但 RE 更有效；\n若 \\(\\mathrm{H}_{3}\\) 不成立，则 FE 仍然是无偏的，但 RE 有偏(不能用)；",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>XT3. Hausman 检验</span>"
    ]
  },
  {
    "objectID": "body/XT3_Hausman检验.html#stata-实例",
    "href": "body/XT3_Hausman检验.html#stata-实例",
    "title": "XT3. Hausman 检验",
    "section": "2. Stata 实例",
    "text": "2. Stata 实例\n我们使用一个典型面板数据 nlswork.dta，包含 4711 个妇女，15 个时间跨度，研究目标为妇女工资受什么因素影响，因此回归中被解释变量为工资对数值 ln_wage，解释变量分别为年龄 age、工作经验 ttl_exp 以及任职长短 tenure\nhelp hausman\n\nwebuse \"nlswork.dta\", clear    \nxtset idcode year\n\nxtreg ln_wage age ttl_exp tenure, fe\nest store fe\n\nxtreg ln_wage age ttl_exp tenure, re\nest store re\n\n​hausman fe re\n输出结果如下：\n. hausman fe re\n\n          ---- Coefficients ----                                  \n        |    (b)          (B)        (b-B)    sqrt(diag(V_b-V_B))\n        |     fe           re     Difference      Std. err.\n--------+---------------------------------------------------------\n    age | -.0030427    -.0050184    .0019757       .0005064\nttl_exp |  .029036      .0338343   -.0047983       .000826\n tenure |  .0116574     .0127792   -.0011218       .0003144\n------------------------------------------------------------------\n               b = Consistent under H0 and Ha; obtained from xtreg.\nB = Inconsistent under Ha, efficient under H0; obtained from xtreg.\n\nTest of H0: Difference in coefficients not systematic\n\n    chi2(3) = (b-B)'[(V_b-V_B)^(-1)](b-B)\n            = 323.40\nProb &gt; chi2 = 0.0000\nHausman 检验的结果显示，检验统计量为 \\(323.40\\)，对应的 p 值为 \\(0.0000\\)。由于 p 值小于 0.05，我们拒绝原假设 H0，即固定效应模型和随机效应模型之间的系数差异是系统性的。因此，基于 Hausman 检验的结果，我们应选择 固定效应模型（FE），因为它在此数据集上比随机效应模型更合适。",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>XT3. Hausman 检验</span>"
    ]
  },
  {
    "objectID": "body/XT3_Hausman检验.html#hausman-检验值为负怎么办",
    "href": "body/XT3_Hausman检验.html#hausman-检验值为负怎么办",
    "title": "XT3. Hausman 检验",
    "section": "3. hausman 检验值为负怎么办？",
    "text": "3. hausman 检验值为负怎么办？\n\n3.1 问题背景\n我们要研究的数据样本 invest2.dta 包含 100 个观察值：5 家公司，每家公司有 20 年资料，涉及公司 id、时间 t、投资支出 invest、市场价值 market、资本存量 stock 五个变量。有多种方法估计投资支出 invest、市场价值 market、资本存量 stock 三个变量之间的关系，假设我们想研究投资支出、资本存量对市场价值的影响，则在回归模型中被解释变量为市场价值 market，解释变量为投资支出 invest、资本存量 stock。分别使用固定效应模型、随机效应模型进行估计，进而通过 hausman 命令检验其差异。\nuse invest2.dta, clear\nxtdes\n​\nxtreg market invest stock, fe\nest store m_fe\n\nxtreg market invest stock, re\nest store m_re\n\nhausman m_fe m_re\n输出结果为：\n. hausman m_fe m_re\n\n                 ---- Coefficients ----\n             |      (b)          (B)            (b-B)     sqrt(diag(V_b-V_B))\n             |      m_fe         m_re        Difference       Std. err.\n-------------+----------------------------------------------------------------\n      invest |     3.05273     3.847014        -.794284               .\n       stock |   -.6763434    -.7981618        .1218184               .\n------------------------------------------------------------------------------\n                          b = Consistent under H0 and Ha; obtained from xtreg.\n           B = Inconsistent under Ha, efficient under H0; obtained from xtreg.\n\nTest of H0: Difference in coefficients not systematic\n\nchi2(2) = (b-B)'[(V_b-V_B)^(-1)](b-B)\n        = -47.57\n\nWarning: chi2 &lt; 0 ==&gt; model fitted on these data\n         fails to meet the asymptotic assumptions\n         of the Hausman test; see suest for a\n         generalized test.\n\n\n3.2 原因及解决方法\n参见如下推文：\n\n游万海, 连玉君, 2020, Stata: 面板数据模型一文读懂, 连享会 No.122.",
    "crumbs": [
      "**面板数据**",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>XT3. Hausman 检验</span>"
    ]
  }
]